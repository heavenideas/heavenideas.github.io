<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorcana Practice Dojo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Supabase & Fuse Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>

    <!-- Unified Win Probability Utilities Library -->
    <script
        src="https://cdn.jsdelivr.net/gh/heavenideas/heavenideas.github.io@main/utilities/unified_win_probability_utilities.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Custom Scrollbar for Game Log */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #4B5563;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6B7280;
        }

        .card {
            width: 100px;
            height: 140px;
            border-radius: 0.375rem;
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        .card.exerted {
            transform: rotate(90deg) scale(0.9);
            opacity: 0.8;
        }

        .card.exerted:hover {
            transform: rotate(90deg) scale(0.95);
        }

        .card-back {
            background-image: url('https://deckbuilder.lorcanajson.org/images/card-back.png');
            background-color: #1a202c;
        }

        /* Hand fanning effect */
        .hand-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: -50px;
            /* Overlap adjusted for larger cards */
        }

        .hand-container .card {
            margin-left: -40px;
            /* Adjusted for larger cards */
        }

        .hand-container .card:first-child {
            margin-left: 0;
        }

        /* Context Menu */
        #context-menu {
            position: fixed;
            background: #1F2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 4px;
            z-index: 100;
            display: none;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            min-width: 140px;
        }

        .context-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            color: #E5E7EB;
            font-size: 14px;
            transition: background 0.1s;
        }

        .context-item:hover {
            background: #374151;
        }

        .context-divider {
            height: 1px;
            background: #374151;
            margin: 4px 0;
        }

        /* Damage Counter */
        .damage-counter {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #EF4444;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 5;
        }

        .bg-player-top {
            background-color: #3f2e70;
        }

        .bg-player-bottom {
            background-color: #a86b32;
        }

        /* Drag & Drop Visuals */
        .drop-zone {
            transition: all 0.2s;
            border-radius: 0.375rem;
        }

        .drop-zone.drop-target-active {
            box-shadow: 0 0 0 4px #8B5CF6;
            background-color: rgba(139, 92, 246, 0.3) !important;
        }

        /* Drying State Visuals */
        .card.drying {
            filter: grayscale(80%) contrast(0.85);
        }

        .drying-badge {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #d1d5db;
            font-size: 9px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 12px;
            pointer-events: none;
            z-index: 10;
            border: 1px solid #4b5563;
            display: flex;
            align-items: center;
            gap: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200 h-screen w-screen flex flex-col font-sans select-none">

    <!-- Loading Screen -->
    <div id="loading-screen" class="absolute inset-0 z-50 bg-gray-900 flex flex-col items-center justify-center">
        <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-purple-500 mb-4"></div>
        <h2 class="text-2xl font-bold text-white mb-2">Lorcana Practice Dojo</h2>
        <p id="loading-text" class="text-gray-400">Fetching Card Database (This may take a moment)...</p>
    </div>

    <!-- Deck Setup Modal -->
    <div id="setup-modal" class="absolute inset-0 z-40 bg-black bg-opacity-80 flex items-center justify-center hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl w-[800px] max-w-full flex flex-col">
            <h2 class="text-2xl font-bold mb-4 border-b border-gray-700 pb-2">Setup Practice Decks</h2>
            <div class="flex gap-4 flex-1">
                <div class="flex-1 flex flex-col">
                    <label class="font-semibold text-purple-400 mb-1">Player 1 Decklist</label>
                    <select id="p1-deck-select"
                        class="w-full bg-gray-900 text-sm p-2 mb-2 rounded border border-gray-700 text-gray-300 focus:border-purple-500 focus:outline-none"
                        onchange="App.onDeckSelect(1, this.value)">
                        <option value="">-- Load from Database --</option>
                    </select>
                    <textarea id="deck1-input"
                        class="w-full flex-1 bg-gray-900 text-sm p-3 rounded border border-gray-700 focus:border-purple-500 focus:outline-none"
                        placeholder="Paste decklist here (e.g. 4 Tinker Bell - Giant Fairy)"></textarea>
                </div>
                <div class="flex-1 flex flex-col">
                    <label class="font-semibold text-orange-400 mb-1">Player 2 Decklist</label>
                    <select id="p2-deck-select"
                        class="w-full bg-gray-900 text-sm p-2 mb-2 rounded border border-gray-700 text-gray-300 focus:border-orange-500 focus:outline-none"
                        onchange="App.onDeckSelect(2, this.value)">
                        <option value="">-- Load from Database --</option>
                    </select>
                    <textarea id="deck2-input"
                        class="w-full flex-1 bg-gray-900 text-sm p-3 rounded border border-gray-700 focus:border-orange-500 focus:outline-none"
                        placeholder="Paste decklist here (e.g. 4 Maui - Hero to All)"></textarea>
                </div>
            </div>
            <div class="mt-4 flex justify-between items-center border-t border-gray-700 pt-4">
                <div class="flex items-center gap-4">
                    <input type="file" id="setup-import-file" class="hidden" accept=".json"
                        onchange="App.importTimelines(event)">
                    <button onclick="document.getElementById('setup-import-file').click()"
                        class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded transition flex items-center text-sm shadow-md">
                        <i class="fa-solid fa-file-import mr-2"></i> Resume Session
                    </button>
                    <p class="text-xs text-gray-400 hidden sm:block">or leave blank to use pre-generated demo decks.</p>
                </div>
                <button onclick="App.startGame()"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded transition shadow-lg">Start
                    Match</button>
            </div>
        </div>
    </div>

    <!-- Mulligan Modal -->
    <div id="mulligan-modal"
        class="absolute inset-0 z-50 bg-black bg-opacity-90 flex items-center justify-center hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl max-w-5xl w-full flex flex-col">
            <h2 class="text-2xl font-bold mb-2 border-b border-gray-700 pb-2 text-white" id="mulligan-title">Player
                Mulligan</h2>
            <p class="text-gray-400 mb-6">Select up to 7 cards to replace. The selected cards will be shuffled back into
                your deck.</p>
            <div id="mulligan-hand" class="flex flex-wrap justify-center gap-4 mb-8 min-h-[196px]">
                <!-- Cards injected here -->
            </div>
            <div class="flex justify-end gap-4">
                <button onclick="App.closeMulligan()"
                    class="px-6 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded transition">Cancel</button>
                <button onclick="App.confirmMulligan()"
                    class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded transition">Confirm
                    Mulligan</button>
            </div>
        </div>
    </div>

    <!-- Inspect Deck Modal -->
    <div id="inspect-deck-modal"
        class="absolute inset-0 z-50 bg-black bg-opacity-90 flex items-center justify-center hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl w-[90vw] h-[90vh] max-w-7xl flex flex-col">
            <h2
                class="text-2xl font-bold mb-4 border-b border-gray-700 pb-2 text-white flex justify-between items-center">
                <span id="inspect-deck-title">Inspecting Deck</span>
                <button onclick="App.closeInspectDeck()" class="text-gray-400 hover:text-white transition"><i
                        class="fa-solid fa-times"></i></button>
            </h2>
            <div id="inspect-deck-grid"
                class="flex-1 overflow-y-auto grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-4 p-2 content-start">
                <!-- Cards injected here -->
            </div>
        </div>
    </div>

    <!-- Time Jump Flash & Toast -->
    <div id="time-flash"
        class="absolute inset-0 bg-purple-500/20 z-40 pointer-events-none opacity-0 transition-opacity duration-300">
    </div>
    <div id="toast-container"
        class="fixed top-8 left-1/2 transform -translate-x-1/2 z-50 flex flex-col gap-2 pointer-events-none"></div>

    <!-- Main App Container -->
    <div id="app" class="flex-1 flex overflow-hidden hidden">

        <!-- Sidebar Game Log -->
        <div class="w-72 bg-[#1a1a1e] border-r border-gray-800 flex flex-col shadow-xl z-20 relative overflow-hidden">
            <div class="p-4 border-b border-gray-800 flex items-center justify-between">
                <h1 class="font-bold text-lg tracking-wide"><i class="fa-solid fa-khanda text-purple-500 mr-2"></i>
                    Practice Dojo</h1>
                <button onclick="App.showSetup()" class="text-gray-500 hover:text-white" title="Reset/Change Decks"><i
                        class="fa-solid fa-rotate-right"></i></button>
            </div>

            <div class="p-4 border-b border-gray-800 bg-[#151518]">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xs text-gray-400 font-bold uppercase tracking-wider">Players</span>
                </div>
                <div id="p0-badge"
                    class="py-1 px-2 rounded bg-gray-800 text-sm mb-1 border-l-2 border-orange-500 flex justify-between">
                    <span>Player 1 (You)</span> <span id="p0-cards">0 cards</span>
                </div>
                <div id="p1-badge"
                    class="py-1 px-2 rounded bg-gray-800 text-sm border-l-2 border-purple-500 flex justify-between text-gray-400">
                    <span>Player 2</span> <span id="p1-cards">0 cards</span>
                </div>
            </div>

            <!-- Win Probability Meters -->
            <div class="p-4 border-b border-gray-800 bg-[#1a1a1e] flex flex-col gap-3">
                <!-- BCR Meter -->
                <div class="group relative cursor-help">
                    <!-- Custom Tooltip -->
                    <div
                        class="absolute left-0 top-full mt-2 w-full p-3 bg-black/95 backdrop-blur-md text-gray-300 text-[11px] leading-relaxed rounded-lg border border-gray-700 shadow-2xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50 pointer-events-none transform group-hover:translate-y-0 -translate-y-1">
                        <div class="text-blue-400 font-bold text-xs uppercase tracking-wider mb-1"><i
                                class="fa-solid fa-scale-balanced mr-1"></i> Tug-of-War Meter</div>
                        Represents the percentage of the total Board Control Rating (BCR) currently controlled by each
                        player based <span class="text-white font-bold border-b border-gray-500">ONLY</span> on cards in
                        the field.
                    </div>

                    <div class="text-xs text-gray-400 font-bold uppercase tracking-wider mb-1 flex justify-between">
                        <span>Board Control (BCR)</span>
                        <i class="fa-solid fa-khanda text-blue-400 group-hover:text-white transition-colors"></i>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2 flex overflow-hidden">
                        <div id="bcr-p1" class="bg-orange-500 h-2 transition-all duration-500" style="width: 50%"></div>
                        <div id="bcr-p2" class="bg-purple-500 h-2 transition-all duration-500" style="width: 50%"></div>
                    </div>
                    <div class="flex justify-between text-xs mt-1">
                        <span id="bcr-val-p1" class="text-orange-400">0.0</span>
                        <span id="bcr-val-p2" class="text-purple-400">0.0</span>
                    </div>
                </div>

                <!-- LVI Meter -->
                <div class="group relative cursor-help">
                    <!-- Custom Tooltip -->
                    <div
                        class="absolute left-0 top-full mt-2 w-full p-3 bg-black/95 backdrop-blur-md text-gray-300 text-[11px] leading-relaxed rounded-lg border border-gray-700 shadow-2xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50 pointer-events-none transform group-hover:translate-y-0 -translate-y-1">
                        <div class="text-yellow-400 font-bold text-xs uppercase tracking-wider mb-1"><i
                                class="fa-solid fa-scale-balanced mr-1"></i> Tug-of-War Meter</div>
                        Represents the percentage of the total Lore Velocity Index (LVI) currently controlled by each
                        player based <span class="text-white font-bold border-b border-gray-500">ONLY</span> on cards in
                        the field.
                    </div>

                    <div class="text-xs text-gray-400 font-bold uppercase tracking-wider mb-1 flex justify-between">
                        <span>Lore Velocity (LVI)</span>
                        <i class="fa-solid fa-gem text-yellow-400 group-hover:text-white transition-colors"></i>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2 flex overflow-hidden">
                        <div id="lvi-p1" class="bg-orange-500 h-2 transition-all duration-500" style="width: 50%"></div>
                        <div id="lvi-p2" class="bg-purple-500 h-2 transition-all duration-500" style="width: 50%"></div>
                    </div>
                    <div class="flex justify-between text-xs mt-1">
                        <span id="lvi-val-p1" class="text-orange-400">0.0</span>
                        <span id="lvi-val-p2" class="text-purple-400">0.0</span>
                    </div>
                </div>
            </div>

            <!-- Card Preview Panel (Moved ABOVE Game Log) -->
            <div
                class="h-[200px] w-full border-t border-gray-800 bg-[#111] flex items-center justify-center relative overflow-hidden shrink-0">
                <span id="sidebar-preview-placeholder"
                    class="text-gray-600 text-xs font-bold uppercase tracking-widest text-center px-4 pointer-events-none">Hover
                    card for details</span>
                <div id="sidebar-preview"
                    class="absolute inset-0 bg-bottom bg-no-repeat opacity-0 transition-opacity duration-200 pointer-events-none"
                    style="background-size: 100% auto;"></div>

                <!-- Ink Symbol overlay -->
                <div id="preview-ink-container"
                    class="absolute bottom-4 right-4 flex items-center justify-center w-14 h-14 pointer-events-none transition-opacity duration-200 opacity-0">
                    <svg id="preview-ink-hex" class="absolute inset-0 w-full h-full drop-shadow-lg hidden"
                        viewBox="0 0 100 100">
                        <polygon points="50,5 95,25 95,75 50,95 5,75 5,25" fill="#222" stroke="#666" stroke-width="4" />
                    </svg>
                    <svg id="preview-ink-circle" class="absolute inset-0 w-full h-full drop-shadow-lg hidden"
                        viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="45" fill="#D4AF37" stroke="#FFF" stroke-width="4" />
                    </svg>
                    <span id="preview-ink-cost" class="z-10 font-bold text-2xl"></span>
                </div>
            </div>

            <!-- Card Metrics Bar -->
            <div id="preview-metrics-bar"
                class="w-full bg-[#0a0a0c] border-t border-gray-800 p-2 flex justify-between px-4 text-xs font-mono tracking-wider opacity-0 transition-opacity duration-200 shrink-0 shadow-inner">
                <div class="flex flex-col items-center"><span class="text-gray-500 text-[9px]">CTL</span><span
                        id="metric-ctl" class="text-white font-bold">0.00</span></div>
                <div class="flex flex-col items-center"><span class="text-gray-500 text-[9px]">BCR</span><span
                        id="metric-bcr" class="text-blue-400 font-bold">0.00</span></div>
                <div class="flex flex-col items-center"><span class="text-gray-500 text-[9px]">RDS</span><span
                        id="metric-rds" class="text-green-400 font-bold">0.00</span></div>
                <div class="flex flex-col items-center"><span class="text-gray-500 text-[9px]">LVI</span><span
                        id="metric-lvi" class="text-yellow-400 font-bold">0.00</span></div>
            </div>

            <div class="flex-1 overflow-y-auto p-4 flex flex-col gap-2 bg-[#1a1a1e]" id="game-log">
                <!-- Log entries injected here -->
            </div>

            <div class="p-4 border-t border-gray-800 bg-[#151518] flex flex-col gap-2 shrink-0 z-30 relative">
                <div class="flex gap-2">
                    <button onclick="App.questWithAll()"
                        class="flex-1 py-2 bg-gray-800 hover:bg-gray-700 text-sm font-semibold rounded text-gray-300 transition"
                        title="Quest with all available characters">
                        <i class="fa-solid fa-diamond text-yellow-500 mr-1"></i> Quest all (<span
                            id="quest-count">0</span>)
                    </button>
                    <button id="mulligan-btn" onclick="App.openMulligan()"
                        class="flex-1 py-2 bg-gray-800 hover:bg-gray-700 text-sm font-semibold rounded text-gray-300 transition"
                        title="Mulligan Active Hand">
                        <i class="fa-solid fa-rotate text-blue-500 mr-1"></i> Mulligan
                    </button>
                </div>
                <div class="flex gap-2">
                    <button onclick="App.toggleTimelines()"
                        class="px-3 py-2 bg-gray-800 hover:bg-gray-700 text-sm font-semibold rounded text-purple-400 transition"
                        title="Timelines & Bookmarks">
                        <i class="fa-solid fa-clock-rotate-left"></i>
                    </button>
                    <button onclick="App.undo()"
                        class="px-3 py-2 bg-gray-800 hover:bg-gray-700 text-sm font-semibold rounded text-gray-300 transition"
                        title="Undo Last Action">
                        <i class="fa-solid fa-rotate-left"></i>
                    </button>
                    <button onclick="App.endTurn()"
                        class="flex-1 py-2 bg-white hover:bg-gray-200 text-black text-sm font-bold rounded transition shadow-[0_0_15px_rgba(255,255,255,0.2)]">
                        End Turn &rarr;
                    </button>
                </div>
            </div>

            <!-- Timelines Drawer (Overlaying Sidebar) -->
            <div id="timeline-drawer"
                class="absolute inset-0 bg-black/95 backdrop-blur-md z-40 flex flex-col transform -translate-x-full transition-transform duration-300 shadow-2xl">
                <div class="p-4 border-b border-gray-800 flex justify-between items-center shrink-0">
                    <h2 class="font-bold text-lg text-white"><i
                            class="fa-solid fa-code-branch text-purple-500 mr-2"></i> Timelines</h2>
                    <button onclick="App.toggleTimelines()" class="text-gray-400 hover:text-white transition"><i
                            class="fa-solid fa-times text-lg"></i></button>
                </div>

                <!-- Import / Export Utility Row -->
                <div class="flex border-b border-gray-800 shrink-0 bg-[#0a0a0c]">
                    <input type="file" id="import-file" class="hidden" accept=".json"
                        onchange="App.importTimelines(event)">
                    <button onclick="document.getElementById('import-file').click()"
                        class="flex-1 py-2 text-xs font-bold text-gray-400 hover:text-white hover:bg-gray-800 transition border-r border-gray-800">
                        <i class="fa-solid fa-file-import mr-1"></i> Import Session
                    </button>
                    <button onclick="App.exportTimelines()"
                        class="flex-1 py-2 text-xs font-bold text-gray-400 hover:text-white hover:bg-gray-800 transition">
                        <i class="fa-solid fa-file-export mr-1"></i> Export Session
                    </button>
                </div>

                <!-- Create Bookmark -->
                <div class="p-4 bg-[#151518] border-b border-gray-800 shrink-0 flex flex-col gap-2">
                    <input type="text" id="bookmark-name"
                        class="w-full bg-black border border-gray-700 rounded p-2 text-xs text-white focus:border-purple-500 outline-none transition"
                        placeholder="Name this timeline (optional)...">
                    <textarea id="bookmark-comment"
                        class="w-full bg-black border border-gray-700 rounded p-2 text-xs text-white focus:border-purple-500 outline-none transition resize-none"
                        placeholder="Add a comment (optional)..." rows="2"></textarea>
                    <button onclick="App.saveTimeline()"
                        class="w-full py-2 bg-purple-600 hover:bg-purple-500 text-white text-xs font-bold rounded transition shadow-lg mt-1">
                        + Save Current State
                    </button>
                </div>

                <!-- Bookmarks List -->
                <div class="flex-1 overflow-y-auto p-3 flex flex-col gap-2" id="bookmark-list">
                    <!-- Bookmarks injected here -->
                </div>

                <!-- Auto-Saves (Safety Net) -->
                <div class="p-3 bg-gray-900 border-t border-gray-800 min-h-[140px] shrink-0">
                    <div
                        class="text-[10px] text-gray-500 font-bold uppercase tracking-wider mb-2 ml-1 flex justify-between">
                        <span>Auto-Saves (Time Jumps)</span>
                        <i class="fa-solid fa-life-ring text-gray-600"></i>
                    </div>
                    <div id="autosave-list" class="flex flex-col gap-1.5">
                        <!-- Auto-saves injected here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Play Area -->
        <div class="flex-1 flex flex-col relative bg-gray-900">
            <!-- Center dividing line -->
            <div id="board-divider"
                class="absolute top-1/2 left-0 right-0 h-1 z-30 opacity-0 transform -translate-y-1/2 transition-all duration-500 pointer-events-none">
            </div>

            <!-- Top Area (Opponent) -->
            <div id="top-board"
                class="flex-1 relative p-4 flex flex-col justify-between overflow-hidden transition-colors duration-500">
                <!-- Top Player Stats Overlay -->
                <div
                    class="absolute top-4 right-4 bg-black bg-opacity-60 border border-gray-600 rounded-lg p-3 flex flex-col items-center min-w-[60px] shadow-lg">
                    <span class="text-xs text-gray-400 font-bold">LORE</span>
                    <span id="top-lore" class="text-3xl font-black text-white">0</span>
                </div>

                <div class="absolute top-4 left-4 text-white/30 text-8xl font-black pointer-events-none"
                    id="top-player-bg-text">P2</div>

                <!-- Opponent Hand Toggle -->
                <div class="flex justify-center mb-1 relative z-20">
                    <button onclick="App.toggleRevealHand()"
                        class="text-xs text-gray-300 hover:text-white transition flex items-center gap-2 bg-black/40 hover:bg-black/60 px-3 py-1 rounded-full border border-gray-600">
                        <i id="reveal-icon" class="fa-solid fa-eye"></i> <span id="reveal-text">Reveal Hand</span>
                    </button>
                </div>

                <!-- Opponent Hand -->
                <div class="flex flex-col items-center mb-4 relative">
                    <div class="flex justify-center h-[120px] drop-zone p-2 w-full max-w-4xl mx-auto z-10"
                        ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                        ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'hand', 'top')">
                        <div id="top-hand" class="hand-container scale-[0.85] origin-top"></div>
                    </div>

                    <!-- Top Hand Potential Badge -->
                    <div class="flex gap-4 bg-black/60 px-4 py-1.5 rounded-full border border-gray-600/50 text-[10px] font-mono -mt-2 z-0 shadow-lg"
                        title="Total Potential Metrics of all cards currently in Hand">
                        <span class="text-gray-400 font-bold uppercase tracking-wider mr-2">Hand Potential</span>
                        <span class="text-white">CTL <span id="top-hand-ctl"
                                class="font-bold text-[11px]">0.0</span></span>
                        <span class="text-blue-400">BCR <span id="top-hand-bcr"
                                class="font-bold text-[11px]">0.0</span></span>
                        <span class="text-green-400">RDS <span id="top-hand-rds"
                                class="font-bold text-[11px]">0.0</span></span>
                        <span class="text-yellow-400">LVI <span id="top-hand-lvi"
                                class="font-bold text-[11px]">0.0</span></span>
                    </div>
                </div>

                <!-- Opponent Inkwell & Deck Row -->
                <div
                    class="flex justify-between items-center w-full max-w-5xl mx-auto px-4 mb-4 bg-black/20 rounded-xl p-3 border border-gray-700/50 shadow-inner">
                    <!-- Inkwell -->
                    <div class="flex items-center gap-4 w-1/2 drop-zone p-2 border border-transparent rounded hover:border-gray-500 transition"
                        ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                        ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'inkwell', 'top')">
                        <div
                            class="bg-black/80 px-4 py-2 rounded text-lg font-bold pointer-events-none z-10 shadow-lg border border-gray-600">
                            <i class="fa-solid fa-hexagon text-blue-300 mr-1"></i> <span id="top-ink">0/0</span>
                        </div>
                        <div id="top-inkwell-cards" class="relative h-[140px] flex-1"></div>
                    </div>
                    <!-- Discard & Deck -->
                    <div class="flex gap-6">
                        <div id="top-discard"
                            class="relative w-[100px] h-[140px] border-2 border-dashed border-gray-500 bg-black/40 rounded drop-zone transition hover:border-gray-300"
                            ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                            ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'discard', 'top')">
                            <span
                                class="absolute inset-0 flex items-center justify-center text-gray-400 text-xs font-bold pointer-events-none">DISCARD</span>
                        </div>
                        <div class="relative cursor-pointer w-[100px] h-[140px] drop-zone hover:scale-105 transition"
                            onclick="App.drawCard(App.state.inactivePlayer)" ondragover="App.allowDrop(event)"
                            ondragenter="App.dragEnter(event)" ondragleave="App.dragLeave(event)"
                            ondrop="App.drop(event, 'deck', 'top')"
                            oncontextmenu="App.showDeckContextMenu(event, App.state.inactivePlayer)">
                            <div class="card card-back absolute inset-0 shadow-lg" draggable="true"
                                ondragstart="App.dragStartTopCard(event, 'top')"></div>
                            <div class="absolute -bottom-2 -right-2 bg-black text-xs px-2 py-0.5 rounded border border-gray-600 pointer-events-none shadow"
                                id="top-deck-count">60</div>
                        </div>
                    </div>
                </div>

                <!-- Opponent Field -->
                <div class="flex-1 flex items-end justify-center pb-2 w-full">
                    <div id="top-field"
                        class="flex gap-4 flex-wrap justify-center w-full max-w-4xl min-h-[150px] drop-zone p-2 rounded"
                        ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                        ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'field', 'top')"></div>
                </div>
            </div>

            <!-- Bottom Area (Active Player) -->
            <div id="bottom-board"
                class="flex-1 relative p-4 flex flex-col justify-between overflow-hidden transition-colors duration-500">

                <!-- Bottom Player Stats Overlay -->
                <div
                    class="absolute bottom-4 right-4 bg-black bg-opacity-60 border border-gray-600 rounded-lg p-3 flex flex-col items-center min-w-[60px] shadow-lg">
                    <span class="text-xs text-gray-400 font-bold">LORE</span>
                    <span id="bottom-lore" class="text-3xl font-black text-white">0</span>
                </div>

                <div class="absolute bottom-4 left-4 text-black/20 text-8xl font-black pointer-events-none"
                    id="bottom-player-bg-text">P1</div>

                <!-- Active Field -->
                <div class="flex-1 flex items-start justify-center pt-2 w-full">
                    <div id="bottom-field"
                        class="flex gap-4 flex-wrap justify-center w-full max-w-4xl min-h-[150px] drop-zone p-2 rounded"
                        ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                        ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'field', 'bottom')"></div>
                </div>

                <!-- Active Inkwell & Deck Row -->
                <div
                    class="flex justify-between items-center w-full max-w-5xl mx-auto px-4 mt-4 bg-black/20 rounded-xl p-3 border border-gray-700/50 shadow-inner">
                    <!-- Inkwell -->
                    <div class="flex items-center gap-4 w-1/2 drop-zone p-2 border border-transparent rounded hover:border-gray-500 transition"
                        ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                        ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'inkwell', 'bottom')">
                        <div
                            class="bg-black/80 px-4 py-2 rounded text-lg font-bold pointer-events-none z-10 shadow-lg border border-gray-600">
                            <i class="fa-solid fa-hexagon text-blue-300 mr-1"></i> <span id="bottom-ink">0/0</span>
                        </div>
                        <div id="bottom-inkwell-cards" class="relative h-[140px] flex-1 cursor-pointer"
                            onclick="App.exertInk()"></div>
                    </div>
                    <!-- Discard & Deck -->
                    <div class="flex gap-6">
                        <div id="bottom-discard"
                            class="relative w-[100px] h-[140px] border-2 border-dashed border-gray-500 bg-black/40 rounded drop-zone transition hover:border-gray-300"
                            ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                            ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'discard', 'bottom')">
                            <span
                                class="absolute inset-0 flex items-center justify-center text-gray-400 text-xs font-bold pointer-events-none">DISCARD</span>
                        </div>
                        <div class="relative cursor-pointer w-[100px] h-[140px] drop-zone hover:scale-105 transition"
                            onclick="App.drawCard(App.state.activePlayer)" ondragover="App.allowDrop(event)"
                            ondragenter="App.dragEnter(event)" ondragleave="App.dragLeave(event)"
                            ondrop="App.drop(event, 'deck', 'bottom')"
                            oncontextmenu="App.showDeckContextMenu(event, App.state.activePlayer)">
                            <div class="card card-back absolute inset-0 shadow-lg" draggable="true"
                                ondragstart="App.dragStartTopCard(event, 'bottom')"></div>
                            <div class="absolute -bottom-2 -right-2 bg-black text-xs px-2 py-0.5 rounded border border-gray-600 pointer-events-none shadow"
                                id="bottom-deck-count">60</div>
                        </div>
                    </div>
                </div>

                <!-- Active Hand -->
                <div class="flex flex-col items-center mt-4 relative">
                    <!-- Bottom Hand Potential Badge -->
                    <div class="flex gap-4 bg-black/60 px-4 py-1.5 rounded-full border border-gray-600/50 text-[10px] font-mono -mb-2 z-0 shadow-lg"
                        title="Total Potential Metrics of all cards currently in Hand">
                        <span class="text-gray-400 font-bold uppercase tracking-wider mr-2">Hand Potential</span>
                        <span class="text-white">CTL <span id="bottom-hand-ctl"
                                class="font-bold text-[11px]">0.0</span></span>
                        <span class="text-blue-400">BCR <span id="bottom-hand-bcr"
                                class="font-bold text-[11px]">0.0</span></span>
                        <span class="text-green-400">RDS <span id="bottom-hand-rds"
                                class="font-bold text-[11px]">0.0</span></span>
                        <span class="text-yellow-400">LVI <span id="bottom-hand-lvi"
                                class="font-bold text-[11px]">0.0</span></span>
                    </div>

                    <div class="flex justify-center h-[150px] drop-zone p-2 w-full max-w-4xl mx-auto z-10"
                        ondragover="App.allowDrop(event)" ondragenter="App.dragEnter(event)"
                        ondragleave="App.dragLeave(event)" ondrop="App.drop(event, 'hand', 'bottom')">
                        <div id="bottom-hand" class="hand-container z-10"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu"></div>

    <script>
        // Supabase Client Setup
        const SUPABASE_URL = 'https://cjlhrfhximjldqrfblkj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNqbGhyZmh4aW1qbGRxcmZibGtqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA0MTcxNzQsImV4cCI6MjA2NTk5MzE3NH0.zLiQcPnKt2SnNfQIkUnOG7bOo6F7MPMh8MsasdFF6lw';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        let allDecks = [];
        let deckFuse = null;

        const App = {
            cardDB: {},
            allCards: [],
            abilitiesConfigLoaded: false,
            mulliganSelection: [],

            bookmarks: [],
            autoSaves: [],

            state: {
                turn: 1,
                activePlayer: 0,
                inactivePlayer: 1,
                opponentHandRevealed: false,
                players: [
                    { id: 0, name: "Player 1", deck: [], hand: [], field: [], inkwell: [], discard: [], lore: 0, inkTotal: 0, inkReady: 0, hasMulliganed: false },
                    { id: 1, name: "Player 2", deck: [], hand: [], field: [], inkwell: [], discard: [], lore: 0, inkTotal: 0, inkReady: 0, hasMulliganed: false }
                ],
                history: [],
                log: []
            },

            uuid() {
                return Math.random().toString(36).substr(2, 9);
            },

            async fetchDecksFromDatabase() {
                try {
                    const { data, error } = await supabaseClient.from('decks').select('*').order('created_at', { ascending: false });
                    if (error) {
                        console.error('Error fetching decks:', error);
                        allDecks = [];
                    } else {
                        allDecks = data;
                    }
                    deckFuse = new Fuse(allDecks, { keys: ['name'], includeScore: true, threshold: 0.4 });

                    this.populateDeckDropdowns();
                } catch (err) {
                    console.error("Failed to fetch decks from Supabase:", err);
                }
            },

            populateDeckDropdowns() {
                const s1 = document.getElementById('p1-deck-select');
                const s2 = document.getElementById('p2-deck-select');
                if (!s1 || !s2) return;

                let optionsHtml = '<option value="">-- Load from Database --</option>';
                allDecks.forEach((deck, index) => {
                    optionsHtml += `<option value="${index}">${deck.name || 'Unnamed Deck'}</option>`;
                });

                s1.innerHTML = optionsHtml;
                s2.innerHTML = optionsHtml;

                // Pre-select the first and second decks automatically
                if (allDecks.length > 0) {
                    s1.value = "0";
                    this.onDeckSelect(1, "0");
                }
                if (allDecks.length > 1) {
                    s2.value = "1";
                    this.onDeckSelect(2, "1");
                } else if (allDecks.length === 1) {
                    // Fallback to the first deck for Player 2 if only 1 deck exists total
                    s2.value = "0";
                    this.onDeckSelect(2, "0");
                }
            },

            onDeckSelect(playerNum, deckIndexStr) {
                if (deckIndexStr === "") return;
                const deck = allDecks[parseInt(deckIndexStr)];
                if (!deck) return;

                // Smartly extract the decklist from whatever column name is used
                let deckText = deck.decklist || deck.deck_list || deck.list || deck.cards || deck.export_string || deck.content || "";

                // Format array of objects if needed
                if (Array.isArray(deckText)) {
                    deckText = deckText.map(c => `${c.amount || c.qty || 1} ${c.name || c.card_name}`).join('\n');
                } else if (typeof deckText === 'object') {
                    deckText = JSON.stringify(deckText, null, 2);
                }

                const inputId = playerNum === 1 ? 'deck1-input' : 'deck2-input';
                document.getElementById(inputId).value = deckText;
            },

            async init() {
                try {
                    // Fetch Supabase Decks asynchronously in the background
                    this.fetchDecksFromDatabase();

                    // 1. Fetch Cards
                    const res = await fetch('https://cdn.jsdelivr.net/gh/heavenideas/similcana@main/database/allCards.json');
                    const data = await res.json();

                    // Filter out alternate/promo rarities to only use the default standard versions
                    this.allCards = data.cards.filter(c => {
                        if (!c.rarity) return true;
                        const r = c.rarity.toLowerCase();
                        return r !== 'enchanted' && r !== 'promo' && r !== 'special';
                    });

                    this.allCards.forEach(c => {
                        this.cardDB[c.id] = c;
                        // Only set if not already set, to prefer the first standard version encountered
                        if (c.fullName && !this.cardDB[c.fullName.toLowerCase()]) this.cardDB[c.fullName.toLowerCase()] = c;
                        if (c.name && !this.cardDB[c.name.toLowerCase()]) this.cardDB[c.name.toLowerCase()] = c;
                        if (c.simpleName && !this.cardDB[c.simpleName]) this.cardDB[c.simpleName] = c;
                    });

                    // 2. Fetch Abilities Config (for Win Probability Library)
                    try {
                        await UnifiedWinProbabiliyCalculation.loadAbilitiesConfig();
                        this.abilitiesConfigLoaded = true;
                    } catch (err) {
                        console.warn("Could not load win probability config:", err);
                    }

                    document.getElementById('loading-screen').classList.add('hidden');
                    this.showSetup();

                } catch (e) {
                    document.getElementById('loading-text').innerText = "Error loading database. Please refresh.";
                    console.error("Initialization error:", e);
                }
            },

            showSetup() {
                document.getElementById('setup-modal').classList.remove('hidden');
                document.getElementById('app').classList.add('hidden');
            },

            parseDeck(text) {
                if (!text || text.trim() === '') return this.generateDummyDeck();

                const lines = text.split('\n');
                let deck = [];
                const regex = /^(\d+)\s+(.+)$/;

                for (let line of lines) {
                    const match = line.trim().match(regex);
                    if (match) {
                        let qty = parseInt(match[1]);
                        let name = match[2].toLowerCase().trim();
                        let card = this.cardDB[name] || this.allCards.find(c => c.name.toLowerCase() === name || (c.fullName && c.fullName.toLowerCase() === name));

                        if (card) {
                            for (let i = 0; i < qty; i++) deck.push(card.id);
                        }
                    }
                }

                if (deck.length === 0) return this.generateDummyDeck();
                return deck;
            },

            generateDummyDeck() {
                // Return ~60 random cards just so something is playable
                let deck = [];
                for (let i = 0; i < 60; i++) {
                    const randomCard = this.allCards[Math.floor(Math.random() * this.allCards.length)];
                    deck.push(randomCard.id);
                }
                return deck;
            },

            saveState() {
                this.state.history.push(JSON.stringify({
                    players: this.state.players,
                    activePlayer: this.state.activePlayer,
                    inactivePlayer: this.state.inactivePlayer,
                    opponentHandRevealed: this.state.opponentHandRevealed,
                    turn: this.state.turn,
                    activeTimelineColor: this.state.activeTimelineColor,
                    log: this.state.log
                }));
                // Keep last 50 states
                if (this.state.history.length > 50) this.state.history.shift();
            },

            undo() {
                if (this.state.history.length === 0) return;
                const prev = JSON.parse(this.state.history.pop());
                this.state.players = prev.players;
                this.state.activePlayer = prev.activePlayer;
                this.state.inactivePlayer = prev.inactivePlayer;
                this.state.opponentHandRevealed = prev.opponentHandRevealed || false;
                this.state.turn = prev.turn;
                this.state.activeTimelineColor = prev.activeTimelineColor || null;
                this.state.log = prev.log;
                this.render();
            },

            logAction(msg, isSystem = false) {
                this.state.log.push({ text: msg, isSystem, player: this.state.activePlayer });
            },

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            },

            startGame() {
                const deck1Str = document.getElementById('deck1-input').value;
                const deck2Str = document.getElementById('deck2-input').value;

                const d1Ids = this.parseDeck(deck1Str);
                const d2Ids = this.parseDeck(deck2Str);

                // Reset state
                this.state = {
                    turn: 1, activePlayer: 0, inactivePlayer: 1, opponentHandRevealed: false, history: [], log: [],
                    activeTimelineColor: null,
                    players: [
                        { id: 0, name: "Player 1", deck: [], hand: [], field: [], inkwell: [], discard: [], lore: 0, inkTotal: 0, inkReady: 0, hasMulliganed: false },
                        { id: 1, name: "Player 2", deck: [], hand: [], field: [], inkwell: [], discard: [], lore: 0, inkTotal: 0, inkReady: 0, hasMulliganed: false }
                    ]
                };

                // Populate decks
                const mapCard = (id) => ({ instanceId: this.uuid(), cardId: id, exerted: false, damage: 0, faceUp: false, locationId: null, drying: false });
                this.state.players[0].deck = this.shuffle(d1Ids.map(mapCard));
                this.state.players[1].deck = this.shuffle(d2Ids.map(mapCard));

                this.bookmarks = [];
                this.autoSaves = [];
                this.renderTimelines();

                document.getElementById('setup-modal').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');

                // Initial Draw
                this.saveState();
                for (let i = 0; i < 7; i++) {
                    this._internalDraw(0);
                    this._internalDraw(1);
                }

                this.logAction(`--- Turn 1 Begins ---`, true);
                this.render();
            },

            _internalDraw(playerIndex) {
                const p = this.state.players[playerIndex];
                if (p.deck.length > 0) {
                    p.hand.push(p.deck.shift());
                }
            },

            drawCard(playerIndex) {
                this.saveState();
                this._internalDraw(playerIndex);
                if (playerIndex === this.state.activePlayer) {
                    this.logAction(`You drew a card.`);
                } else {
                    this.logAction(`Opponent drew a card.`);
                }
                this.render();
            },

            endTurn() {
                this.saveState();

                this.state.activePlayer = this.state.inactivePlayer;
                this.state.inactivePlayer = 1 - this.state.activePlayer;
                this.state.opponentHandRevealed = false; // Hide hand again when perspectives flip

                if (this.state.activePlayer === 0) {
                    this.state.turn++;
                }

                const p = this.state.players[this.state.activePlayer];

                this.logAction(`--- Turn ${this.state.turn} ---`, true);
                this.logAction(`Ready step: characters and items readied`, true);

                // Ready Characters and Items (Not Locations)
                p.field.forEach(c => {
                    const dbCard = this.cardDB[c.cardId];
                    if (dbCard && dbCard.type !== 'Location') {
                        c.exerted = false;
                    }
                    c.drying = false; // Remove drying state at the start of their turn
                });

                // Ready Inkwell and flip newly inked cards face down
                p.inkwell.forEach(c => {
                    c.exerted = false;
                    c.faceUp = false;
                });
                p.inkReady = p.inkTotal;

                this.logAction(`Draw step`, true);
                this._internalDraw(this.state.activePlayer);

                this.render();
            },

            exertInk() {
                const p = this.state.players[this.state.activePlayer];
                if (p.inkReady > 0) {
                    this.saveState();
                    p.inkReady--;
                    // Visually exert one available ink card
                    let unexertedInk = p.inkwell.find(c => !c.exerted);
                    if (unexertedInk) unexertedInk.exerted = true;
                    this.render();
                }
            },

            toggleRevealHand() {
                this.saveState();
                this.state.opponentHandRevealed = !this.state.opponentHandRevealed;
                this.logAction(`You ${this.state.opponentHandRevealed ? 'revealed' : 'hid'} the opponent's hand.`, true);
                this.render();
            },

            // --- Timelines & Bookmarks System ---

            toggleTimelines() {
                document.getElementById('timeline-drawer').classList.toggle('-translate-x-full');
                this.renderTimelines();
            },

            exportTimelines() {
                const exportData = {
                    version: 1,
                    currentState: this.state,
                    bookmarks: this.bookmarks,
                    autoSaves: this.autoSaves,
                    deck1: document.getElementById('deck1-input').value,
                    deck2: document.getElementById('deck2-input').value
                };

                const blob = new Blob([JSON.stringify(exportData)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lorcana-session-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.showToast("Session Exported!");
            },

            importTimelines(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (importedData.currentState && importedData.bookmarks) {
                            this.state = importedData.currentState;
                            this.bookmarks = importedData.bookmarks;
                            this.autoSaves = importedData.autoSaves || [];

                            if (importedData.deck1) document.getElementById('deck1-input').value = importedData.deck1;
                            if (importedData.deck2) document.getElementById('deck2-input').value = importedData.deck2;

                            // Ensure user is booted into the app if they imported from setup modal
                            document.getElementById('setup-modal').classList.add('hidden');
                            document.getElementById('app').classList.remove('hidden');

                            // Close Drawer if open, render new state
                            document.getElementById('timeline-drawer').classList.add('-translate-x-full');
                            this.renderTimelines();
                            this.render();
                            this.showToast("Session Imported Successfully!");
                        } else {
                            alert("Invalid session file format.");
                        }
                    } catch (err) {
                        console.error("Failed to parse timeline file", err);
                        alert("Failed to read the file. Ensure it is a valid JSON exported from the Dojo.");
                    }
                    // Reset file input so the same file can be imported again if needed
                    event.target.value = '';
                };
                reader.readAsText(file);
            },

            saveTimeline() {
                const nameInput = document.getElementById('bookmark-name').value.trim();
                const commentInput = document.getElementById('bookmark-comment').value.trim();
                const ap = this.state.players[this.state.activePlayer];
                const defaultName = `Turn ${this.state.turn} - ${ap.name} Active`;
                const finalName = nameInput || defaultName;

                const p1 = this.state.players[0];
                const p2 = this.state.players[1];
                const stats = `Turn ${this.state.turn} | P1: ${p1.lore} Lore - P2: ${p2.lore} Lore`;

                const timelineColors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef', '#f43f5e'];
                const bColor = timelineColors[this.bookmarks.length % timelineColors.length];

                this.bookmarks.unshift({
                    id: this.uuid(),
                    name: finalName,
                    stats: stats,
                    comment: commentInput,
                    color: bColor,
                    state: JSON.stringify(this.state),
                    timestamp: Date.now()
                });

                document.getElementById('bookmark-name').value = '';
                document.getElementById('bookmark-comment').value = '';
                this.renderTimelines();
            },

            autoSaveTimeline() {
                const p1 = this.state.players[0];
                const p2 = this.state.players[1];
                const now = new Date();
                const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const name = `Auto-Save: Left Turn ${this.state.turn} (${timeStr})`;
                const stats = `Turn ${this.state.turn} | P1: ${p1.lore} Lore - P2: ${p2.lore} Lore`;

                this.autoSaves.unshift({
                    id: this.uuid(),
                    name: name,
                    stats: stats,
                    state: JSON.stringify(this.state),
                    timestamp: now.getTime()
                });

                // Ensure newest is always strictly on top
                this.autoSaves.sort((a, b) => b.timestamp - a.timestamp);

                if (this.autoSaves.length > 5) {
                    this.autoSaves.length = 5;
                }
            },

            restoreTimeline(id, isAuto = false) {
                // Save safety net before jumping
                this.autoSaveTimeline();

                const list = isAuto ? this.autoSaves : this.bookmarks;
                const bookmark = list.find(b => b.id === id);
                if (!bookmark) return;

                // Restore State
                this.state = JSON.parse(bookmark.state);

                if (!isAuto && bookmark.color) {
                    this.state.activeTimelineColor = bookmark.color;
                } else if (!isAuto) {
                    this.state.activeTimelineColor = '#3b82f6';
                }

                // Close Drawer, Render, and Flash
                this.toggleTimelines();
                this.render();
                this.showToast(`Timeline Restored: ${bookmark.name}`);
                this.triggerTimeFlash();
            },

            deleteTimeline(id, isAuto = false) {
                if (isAuto) {
                    this.autoSaves = this.autoSaves.filter(b => b.id !== id);
                } else {
                    this.bookmarks = this.bookmarks.filter(b => b.id !== id);
                }
                this.renderTimelines();
            },

            renderTimelines() {
                const buildHtml = (list, isAuto) => {
                    if (list.length === 0) return `<div class="text-xs text-gray-600 text-center py-4 italic">No timelines saved.</div>`;
                    return list.map(b => `
                        <div class="bg-[#1a1a1e] rounded border border-gray-700 hover:border-purple-500 transition shadow-sm flex flex-col overflow-hidden mb-1" ${!isAuto && b.color ? `style="border-left: 4px solid ${b.color};"` : ''}>
                           <div class="group relative p-2 cursor-pointer">
                               <div class="text-[11px] font-bold text-white mb-0.5 truncate">${b.name}</div>
                               <div class="text-[9px] text-gray-400 font-mono tracking-wider">${b.stats}</div>
                               
                               <!-- Hover Overlay -->
                               <div class="absolute inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-10">
                                   <button onclick="App.restoreTimeline('${b.id}', ${isAuto})" class="px-4 py-1.5 bg-purple-600 hover:bg-purple-500 text-white text-[10px] font-bold rounded shadow-lg transition">Restore</button>
                                   <button onclick="App.deleteTimeline('${b.id}', ${isAuto})" class="px-3 py-1.5 bg-red-900/80 hover:bg-red-600 text-white text-[10px] font-bold rounded shadow-lg transition"><i class="fa-solid fa-trash"></i></button>
                               </div>
                           </div>
                           ${!isAuto ? `
                           <div class="border-t border-gray-800 bg-black/40">
                               <textarea 
                                   class="w-full bg-transparent text-gray-300 text-[10px] p-2 outline-none resize-none placeholder-gray-600 focus:bg-black/60 transition" 
                                   rows="2" 
                                   placeholder="Add a comment..." 
                                   onchange="App.updateTimelineComment('${b.id}', this.value)"
                                   onclick="event.stopPropagation()">${(b.comment || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                           </div>
                           ` : ''}
                        </div>
                    `).join('');
                };

                document.getElementById('bookmark-list').innerHTML = buildHtml(this.bookmarks, false);
                document.getElementById('autosave-list').innerHTML = buildHtml(this.autoSaves, true);
            },

            updateTimelineComment(id, newComment) {
                const bookmark = this.bookmarks.find(b => b.id === id);
                if (bookmark) {
                    bookmark.comment = newComment.trim();
                }
            },

            triggerTimeFlash() {
                const flash = document.getElementById('time-flash');
                flash.classList.remove('opacity-0');
                flash.classList.add('opacity-100');
                setTimeout(() => {
                    flash.classList.remove('opacity-100');
                    flash.classList.add('opacity-0');
                }, 300);
            },

            showToast(msg) {
                const container = document.getElementById('toast-container');
                const toast = document.createElement('div');
                toast.className = 'bg-purple-600/90 backdrop-blur-md border border-purple-400 text-white px-6 py-3 rounded-full shadow-[0_10px_30px_rgba(147,51,234,0.4)] font-bold text-sm transform transition-all duration-300 translate-y-[-20px] opacity-0 flex items-center gap-3';
                toast.innerHTML = `<i class="fa-solid fa-clock-rotate-left animate-spin-reverse" style="animation-duration: 3s;"></i> ${msg}`;
                container.appendChild(toast);

                // Animate in
                requestAnimationFrame(() => {
                    toast.classList.remove('translate-y-[-20px]', 'opacity-0');
                    toast.classList.add('translate-y-0', 'opacity-100');
                });

                // Animate out and remove
                setTimeout(() => {
                    toast.classList.remove('translate-y-0', 'opacity-100');
                    toast.classList.add('translate-y-[-20px]', 'opacity-0');
                    setTimeout(() => toast.remove(), 300);
                }, 2500);
            },

            // --- Mulligan Handlers ---

            openMulligan() {
                const p = this.state.players[this.state.activePlayer];
                document.getElementById('mulligan-title').innerText = `${p.name} Mulligan`;
                this.mulliganSelection = [];
                this.renderMulliganCards();
                document.getElementById('mulligan-modal').classList.remove('hidden');
            },

            closeMulligan() {
                document.getElementById('mulligan-modal').classList.add('hidden');
                this.mulliganSelection = [];
            },

            renderMulliganCards() {
                const container = document.getElementById('mulligan-hand');
                container.innerHTML = '';
                const p = this.state.players[this.state.activePlayer];

                p.hand.forEach(c => {
                    const dbCard = this.cardDB[c.cardId];
                    const el = document.createElement('div');
                    el.className = `relative rounded-md bg-cover bg-center cursor-pointer transition-all duration-200 shadow-md border border-white/10`;
                    el.style.width = '140px';
                    el.style.height = '196px';
                    el.style.backgroundImage = `url('${this.getCardImage(dbCard)}')`;

                    if (this.mulliganSelection.includes(c.instanceId)) {
                        el.classList.add('ring-4', 'ring-red-500', 'opacity-50', 'scale-95');
                        el.innerHTML = '<div class="absolute inset-0 flex items-center justify-center"><i class="fa-solid fa-xmark text-6xl text-red-500 drop-shadow-lg"></i></div>';
                    } else {
                        el.classList.add('hover:-translate-y-2', 'hover:shadow-xl', 'hover:z-10');
                    }

                    el.onclick = () => {
                        if (this.mulliganSelection.includes(c.instanceId)) {
                            this.mulliganSelection = this.mulliganSelection.filter(id => id !== c.instanceId);
                        } else {
                            if (this.mulliganSelection.length < 7) {
                                this.mulliganSelection.push(c.instanceId);
                            }
                        }
                        this.renderMulliganCards();
                    };

                    container.appendChild(el);
                });
            },

            confirmMulligan() {
                if (this.mulliganSelection.length === 0) {
                    this.closeMulligan();
                    return;
                }

                this.saveState();
                const p = this.state.players[this.state.activePlayer];
                const cardsToReplace = [];

                // Extract selected cards from hand
                this.mulliganSelection.forEach(instanceId => {
                    const idx = p.hand.findIndex(c => c.instanceId === instanceId);
                    if (idx !== -1) {
                        cardsToReplace.push(p.hand[idx]);
                        p.hand.splice(idx, 1);
                    }
                });

                // Draw new cards
                for (let i = 0; i < cardsToReplace.length; i++) {
                    this._internalDraw(this.state.activePlayer);
                }

                // Put replaced cards back into deck
                p.deck.push(...cardsToReplace);

                // Shuffle deck
                this.shuffle(p.deck);

                p.hasMulliganed = true; // Mark as mulliganed
                this.logAction(`You mulliganed ${cardsToReplace.length} cards.`);

                this.closeMulligan();
                this.render();
            },

            // --- Drag and Drop Handlers ---

            allowDrop(ev) {
                ev.preventDefault();
            },

            dragEnter(ev) {
                ev.preventDefault();
                const zone = ev.target.closest('.drop-zone');
                if (zone) zone.classList.add('drop-target-active');
            },

            dragLeave(ev) {
                const zone = ev.target.closest('.drop-zone');
                if (zone && !zone.contains(ev.relatedTarget)) {
                    zone.classList.remove('drop-target-active');
                }
            },

            drop(ev, targetZone, position) {
                ev.preventDefault();
                const zone = ev.target.closest('.drop-zone');
                if (zone) zone.classList.remove('drop-target-active');

                const instanceId = ev.dataTransfer.getData("text/plain");
                if (instanceId) {
                    this.moveCard(instanceId, targetZone, position, 'top');
                }
            },

            dragStart(ev, instanceId) {
                ev.dataTransfer.setData("text/plain", instanceId);
                ev.dataTransfer.effectAllowed = "move";
            },

            dragStartTopCard(ev, position) {
                const playerIndex = position === 'bottom' ? this.state.activePlayer : this.state.inactivePlayer;
                const p = this.state.players[playerIndex];
                if (p.deck.length > 0) {
                    const topCard = p.deck[0];
                    ev.dataTransfer.setData("text/plain", topCard.instanceId);
                    ev.dataTransfer.effectAllowed = "move";
                } else {
                    ev.preventDefault();
                }
            },

            moveCard(instanceId, targetZone, position, deckPlacement = 'top') {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;

                const targetPlayerIndex = position === 'bottom' ? this.state.activePlayer : this.state.inactivePlayer;
                const targetPlayer = this.state.players[targetPlayerIndex];

                // Deduct ink automatically if dropping from hand to field
                const dbCard = this.cardDB[found.card.cardId];
                if (found.loc === 'hand' && targetZone === 'field' && targetPlayerIndex === this.state.activePlayer) {
                    if (targetPlayer.inkReady >= dbCard.cost) {
                        targetPlayer.inkReady -= dbCard.cost;
                        // Exert inkwell cards visually
                        let inkToExert = dbCard.cost;
                        for (let i = 0; i < targetPlayer.inkwell.length && inkToExert > 0; i++) {
                            if (!targetPlayer.inkwell[i].exerted) {
                                targetPlayer.inkwell[i].exerted = true;
                                inkToExert--;
                            }
                        }
                    }
                }

                // Remove from old location
                found.player[found.loc].splice(found.idx, 1);

                // Reset card status when moving zones
                if (found.loc !== targetZone || found.player.id !== targetPlayer.id) {
                    found.card.exerted = false;
                    found.card.damage = 0;
                    found.card.locationId = null;
                    found.card.faceUp = false;

                    // Add drying state if playing a Character from hand to field
                    if (found.loc === 'hand' && targetZone === 'field' && dbCard.type === 'Character') {
                        found.card.drying = true;
                    } else {
                        found.card.drying = false;
                    }
                } else if (targetZone === 'field') {
                    found.card.locationId = null; // Moving within field (but not onto a location drop zone) un-locates it
                }

                // Adjust Ink Totals if involving inkwell
                if (found.loc === 'inkwell') {
                    found.player.inkTotal--;
                    if (found.player.inkReady > found.player.inkTotal) found.player.inkReady = found.player.inkTotal;
                }
                if (targetZone === 'inkwell') {
                    targetPlayer.inkTotal++;
                    targetPlayer.inkReady++;
                    found.card.faceUp = true; // Inked this turn (starts face up)
                }

                // Add to new location
                if (targetZone === 'deck') {
                    if (deckPlacement === 'bottom') {
                        targetPlayer.deck.push(found.card); // Bottom of deck
                    } else {
                        targetPlayer.deck.unshift(found.card); // Top of deck
                    }
                } else {
                    targetPlayer[targetZone].push(found.card);
                }

                this.logAction(`Moved ${dbCard.name} to ${targetZone}${targetZone === 'deck' ? ` (${deckPlacement})` : ''}.`);
                this.render();
            },

            findCard(instanceId) {
                for (let p of this.state.players) {
                    let locs = ['hand', 'field', 'inkwell', 'discard', 'deck'];
                    for (let loc of locs) {
                        let idx = p[loc].findIndex(c => c.instanceId === instanceId);
                        if (idx !== -1) return { player: p, loc: loc, idx: idx, card: p[loc][idx] };
                    }
                }
                return null;
            },

            playToInkwell(instanceId) {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;

                const dbCard = this.cardDB[found.card.cardId];
                if (!dbCard.inkwell) {
                    // Optional warning, but we allow it for practice Dojo freedom
                    console.log("Card is technically not inkable");
                }

                found.player[found.loc].splice(found.idx, 1);
                found.card.exerted = false; // comes in ready
                found.card.faceUp = true; // face up for the turn it is inked
                found.player.inkwell.push(found.card);
                found.player.inkTotal++;
                found.player.inkReady++;

                this.logAction(`You added ${dbCard.name} to ink.`);
                this.render();
            },

            playCard(instanceId) {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;

                const dbCard = this.cardDB[found.card.cardId];

                // Deduct ink if available (Dojo allows playing even if not enough, for testing)
                if (found.player.inkReady >= dbCard.cost) {
                    found.player.inkReady -= dbCard.cost;
                    // Exert inkwell cards visually
                    let inkToExert = dbCard.cost;
                    for (let i = 0; i < found.player.inkwell.length && inkToExert > 0; i++) {
                        if (!found.player.inkwell[i].exerted) {
                            found.player.inkwell[i].exerted = true;
                            inkToExert--;
                        }
                    }
                }

                found.player[found.loc].splice(found.idx, 1);

                // Locations enter play automatically exerted
                found.card.exerted = (dbCard.type === 'Location');
                found.card.locationId = null;
                found.card.drying = (dbCard.type === 'Character'); // Characters enter drying

                found.player.field.push(found.card);

                this.logAction(`You played ${dbCard.name} (cost ${dbCard.cost}).`);
                this.render();
            },

            toggleExert(instanceId) {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;
                found.card.exerted = !found.card.exerted;

                // Adjust inkReady if toggling an inkwell card manually
                if (found.loc === 'inkwell') {
                    if (found.card.exerted) {
                        found.player.inkReady = Math.max(0, found.player.inkReady - 1);
                    } else {
                        found.player.inkReady = Math.min(found.player.inkTotal, found.player.inkReady + 1);
                    }
                }
                this.render();
            },

            quest(instanceId) {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;
                const dbCard = this.cardDB[found.card.cardId];

                found.card.exerted = true;
                const loreVal = dbCard.lore || 0;
                found.player.lore += loreVal;

                this.logAction(`You quested with ${dbCard.name} for ${loreVal} lore.`);
                this.render();
            },

            questWithAll() {
                this.saveState();
                const p = this.state.players[this.state.activePlayer];
                let totalLore = 0;
                let count = 0;
                p.field.forEach(c => {
                    const dbCard = this.cardDB[c.cardId];
                    // Only quest if the character is NOT exerted, NOT drying, and has lore
                    if (!c.exerted && !c.drying && dbCard.lore > 0) {
                        c.exerted = true;
                        totalLore += dbCard.lore;
                        count++;
                    }
                });

                if (count > 0) {
                    p.lore += totalLore;
                    this.logAction(`You quested with ${count} characters for ${totalLore} lore.`);
                    this.render();
                }
            },

            addDamage(instanceId, amount) {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;
                found.card.damage = (found.card.damage || 0) + amount;
                if (found.card.damage < 0) found.card.damage = 0;
                this.render();
            },

            banish(instanceId) {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;

                const dbCard = this.cardDB[found.card.cardId];

                // Eject characters if this is a location being banished
                if (dbCard.type === 'Location') {
                    found.player.field.forEach(c => {
                        if (c.locationId === instanceId) c.locationId = null;
                    });
                }

                found.player[found.loc].splice(found.idx, 1);
                found.card.damage = 0;
                found.card.exerted = false;
                found.card.locationId = null;
                found.player.discard.push(found.card);

                this.logAction(`${dbCard.name} was banished.`);
                this.render();
            },

            returnToHand(instanceId) {
                this.saveState();
                let found = this.findCard(instanceId);
                if (!found) return;

                const dbCard = this.cardDB[found.card.cardId];

                // Eject characters if this is a location
                if (dbCard.type === 'Location') {
                    found.player.field.forEach(c => {
                        if (c.locationId === instanceId) c.locationId = null;
                    });
                }

                found.player[found.loc].splice(found.idx, 1);
                found.card.damage = 0;
                found.card.exerted = false;
                found.card.locationId = null;
                found.player.hand.push(found.card);
                this.render();
            },

            // --- Handlers for Location Moving ---

            dropToLocation(ev, locInstanceId) {
                ev.preventDefault();
                ev.stopPropagation(); // Stop normal field drop logic
                const instanceId = ev.dataTransfer.getData("text/plain");
                if (instanceId) {
                    this.moveToLocation(instanceId, locInstanceId);
                }
            },

            moveToLocation(charInstanceId, locInstanceId) {
                this.saveState();
                let charFound = this.findCard(charInstanceId);
                let locFound = this.findCard(locInstanceId);
                if (!charFound || !locFound) return;

                const dbCard = this.cardDB[charFound.card.cardId];
                const locDbCard = this.cardDB[locFound.card.cardId];

                // Support playing straight from hand to location
                if (charFound.loc === 'hand') {
                    const targetPlayer = locFound.player;
                    if (targetPlayer.inkReady >= dbCard.cost) {
                        targetPlayer.inkReady -= dbCard.cost;
                        // Exert inkwell cards visually
                        let inkToExert = dbCard.cost;
                        for (let i = 0; i < targetPlayer.inkwell.length && inkToExert > 0; i++) {
                            if (!targetPlayer.inkwell[i].exerted) {
                                targetPlayer.inkwell[i].exerted = true;
                                inkToExert--;
                            }
                        }
                    }
                    charFound.player[charFound.loc].splice(charFound.idx, 1);
                    charFound.card.exerted = false;
                    charFound.card.drying = (dbCard.type === 'Character'); // Apply drying state
                    targetPlayer.field.push(charFound.card);
                    charFound.loc = 'field';
                    charFound.player = targetPlayer;
                }

                if (charFound.loc === 'field') {
                    charFound.card.locationId = locInstanceId;
                    this.logAction(`Moved ${dbCard.name} to ${locDbCard.name}.`);
                    this.render();
                }
            },

            // --- UI Rendering ---

            getCardImage(dbCard) {
                if (dbCard.images && dbCard.images.thumbnail) return dbCard.images.thumbnail;
                if (dbCard.images && dbCard.images.full) return dbCard.images.full;
                return 'https://deckbuilder.lorcanajson.org/images/card-back.png';
            },

            createCardElement(c, isOpponentHand = false, isInkwell = false) {
                const dbCard = this.cardDB[c.cardId];
                const el = document.createElement('div');
                el.className = `card ${c.exerted ? 'exerted' : ''} ${c.drying ? 'drying' : ''}`;

                // Make draggable
                el.draggable = true;
                el.ondragstart = (e) => this.dragStart(e, c.instanceId);

                if (isOpponentHand || (isInkwell && !c.faceUp)) {
                    el.classList.add('card-back');
                } else {
                    el.style.backgroundImage = `url('${this.getCardImage(dbCard)}')`;

                    // Add Hover Preview Events
                    el.addEventListener('mouseenter', () => this.showPreview(dbCard));
                    // Mouseleave event removed so the last hovered card stays visible
                }

                // Add Drying Badge
                if (c.drying && !isOpponentHand && (!isInkwell || c.faceUp)) {
                    const badge = document.createElement('div');
                    badge.className = 'drying-badge';
                    badge.innerHTML = '<i class="fa-solid fa-droplet"></i> Drying';
                    el.appendChild(badge);
                }

                // Add Damage overlay
                if (c.damage > 0) {
                    const dmg = document.createElement('div');
                    dmg.className = 'damage-counter';
                    dmg.innerText = c.damage;
                    el.appendChild(dmg);
                }

                // Context menu trigger
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.showContextMenu(e, c.instanceId);
                });

                el.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.showContextMenu(e, c.instanceId);
                });

                return el;
            },

            showPreview(dbCard) {
                document.getElementById('sidebar-preview-placeholder').classList.add('hidden');
                const preview = document.getElementById('sidebar-preview');
                const imgUrl = (dbCard.images && dbCard.images.full) ? dbCard.images.full : this.getCardImage(dbCard);
                preview.style.backgroundImage = `url('${imgUrl}')`;
                preview.classList.remove('opacity-0');
                preview.classList.add('opacity-100');

                const badge = document.getElementById('preview-ink-container');
                const cost = document.getElementById('preview-ink-cost');
                const hex = document.getElementById('preview-ink-hex');
                const circle = document.getElementById('preview-ink-circle');

                if (dbCard.cost !== undefined && dbCard.cost !== null) {
                    badge.classList.remove('opacity-0');
                    badge.classList.add('opacity-100');
                    cost.innerText = dbCard.cost;

                    if (dbCard.inkwell) {
                        // Inkable: Golden Circle, Black text
                        hex.classList.add('hidden');
                        circle.classList.remove('hidden');
                        cost.classList.remove('text-white', 'drop-shadow-md');
                        cost.classList.add('text-black');
                    } else {
                        // Uninkable: Dark Hexagon, White text with shadow
                        hex.classList.remove('hidden');
                        circle.classList.add('hidden');
                        cost.classList.remove('text-black');
                        cost.classList.add('text-white', 'drop-shadow-md');
                    }
                } else {
                    badge.classList.remove('opacity-100');
                    badge.classList.add('opacity-0');
                }

                // Show Metrics
                const metricsBar = document.getElementById('preview-metrics-bar');
                if (this.abilitiesConfigLoaded) {
                    try {
                        const m = UnifiedWinProbabiliyCalculation.calculateCardMetrics(dbCard);
                        const bcr = m.bcr || 0;
                        const rds = m.rds || 0;
                        const lvi = m.lvi || 0;
                        const ctl = m.ctl !== undefined ? m.ctl : (bcr + rds + lvi);

                        document.getElementById('metric-ctl').innerText = ctl.toFixed(2);
                        document.getElementById('metric-bcr').innerText = bcr.toFixed(2);
                        document.getElementById('metric-rds').innerText = rds.toFixed(2);
                        document.getElementById('metric-lvi').innerText = lvi.toFixed(2);

                        metricsBar.classList.remove('opacity-0');
                        metricsBar.classList.add('opacity-100');
                    } catch (e) {
                        metricsBar.classList.remove('opacity-100');
                        metricsBar.classList.add('opacity-0');
                    }
                }
            },

            showContextMenu(e, instanceId) {
                const menu = document.getElementById('context-menu');
                menu.innerHTML = '';

                let found = this.findCard(instanceId);
                if (!found) return;

                const dbCard = this.cardDB[found.card.cardId];
                const isActivePlayerOwned = found.player.id === this.state.activePlayer;

                const addOption = (text, onClick) => {
                    const item = document.createElement('div');
                    item.className = 'context-item';
                    item.innerText = text;
                    item.onclick = (evt) => {
                        evt.stopPropagation();
                        menu.style.display = 'none';
                        onClick();
                    };
                    menu.appendChild(item);
                };

                const addDivider = () => {
                    const d = document.createElement('div');
                    d.className = 'context-divider';
                    menu.appendChild(d);
                };

                // Build menu based on location
                if (found.loc === 'hand') {
                    if (isActivePlayerOwned) {
                        addOption(`Play Card (-${dbCard.cost} Ink)`, () => this.playCard(instanceId));
                        if (dbCard.inkwell) addOption(`Add to Inkwell`, () => this.playToInkwell(instanceId));
                        addDivider();
                    }
                    addOption('Discard Card', () => this.banish(instanceId));
                    addOption('Put on Top of Deck', () => this.moveCard(instanceId, 'deck', isActivePlayerOwned ? 'bottom' : 'top', 'top'));
                    addOption('Put on Bottom of Deck', () => this.moveCard(instanceId, 'deck', isActivePlayerOwned ? 'bottom' : 'top', 'bottom'));
                } else if (found.loc === 'field') {
                    if (found.card.locationId) {
                        addOption('Leave Location', () => {
                            this.saveState();
                            found.card.locationId = null;
                            this.render();
                        });
                        addDivider();
                    }
                    addOption(found.card.exerted ? 'Ready' : 'Exert', () => this.toggleExert(instanceId));
                    // Prevent individual questing if the character is drying
                    if (isActivePlayerOwned && !found.card.exerted && !found.card.drying && dbCard.lore > 0) {
                        addOption(`Quest (+${dbCard.lore} Lore)`, () => this.quest(instanceId));
                    }
                    addDivider();
                    addOption('Add 1 Damage', () => this.addDamage(instanceId, 1));
                    if (found.card.damage > 0) addOption('Remove 1 Damage', () => this.addDamage(instanceId, -1));
                    addDivider();
                    addOption('Banish (To Discard)', () => this.banish(instanceId));
                    addOption('Return to Hand', () => this.returnToHand(instanceId));
                    addOption('Put on Top of Deck', () => this.moveCard(instanceId, 'deck', isActivePlayerOwned ? 'bottom' : 'top', 'top'));
                    addOption('Put on Bottom of Deck', () => this.moveCard(instanceId, 'deck', isActivePlayerOwned ? 'bottom' : 'top', 'bottom'));
                } else if (found.loc === 'inkwell') {
                    addOption(found.card.exerted ? 'Ready Ink' : 'Exert Ink', () => this.toggleExert(instanceId));
                    addDivider();
                    addOption('Return to Hand', () => this.returnToHand(instanceId));
                    addOption('Discard', () => this.banish(instanceId));
                } else if (found.loc === 'discard') {
                    addOption('Play Card to Field', () => this.playCard(instanceId));
                    addOption('Return to Hand', () => this.returnToHand(instanceId));
                    addOption('Move to Top of Deck', () => this.moveCard(instanceId, 'deck', isActivePlayerOwned ? 'bottom' : 'top', 'top'));
                    addOption('Move to Bottom of Deck', () => this.moveCard(instanceId, 'deck', isActivePlayerOwned ? 'bottom' : 'top', 'bottom'));
                }

                if (menu.children.length > 0) {
                    menu.style.display = 'block';
                    menu.style.left = e.clientX + 'px';
                    menu.style.top = e.clientY + 'px';
                }
            },

            showDeckContextMenu(e, playerIndex) {
                e.preventDefault();
                e.stopPropagation();

                const menu = document.getElementById('context-menu');
                menu.innerHTML = '';

                const p = this.state.players[playerIndex];

                const addOption = (text, onClick) => {
                    const item = document.createElement('div');
                    item.className = 'context-item flex items-center gap-2';
                    item.innerHTML = text;
                    item.onclick = (evt) => {
                        evt.stopPropagation();
                        menu.style.display = 'none';
                        onClick();
                    };
                    menu.appendChild(item);
                };

                addOption('<i class="fa-solid fa-magnifying-glass text-blue-400"></i> Inspect Deck', () => this.inspectDeck(playerIndex));
                addOption('<i class="fa-solid fa-shuffle text-purple-400"></i> Shuffle Deck', () => this.shuffleDeck(playerIndex));

                if (menu.children.length > 0) {
                    menu.style.display = 'block';
                    menu.style.left = e.clientX + 'px';
                    menu.style.top = e.clientY + 'px';
                }
            },

            inspectDeck(playerIndex) {
                const p = this.state.players[playerIndex];
                document.getElementById('inspect-deck-title').innerText = `Inspecting ${p.name}'s Deck (${p.deck.length} Cards)`;

                const container = document.getElementById('inspect-deck-grid');
                container.innerHTML = '';

                // Keep track of counts for grouping identical cards (optional but helpful)
                // For a raw view, we just render them straight from the deck array
                p.deck.forEach(c => {
                    const dbCard = this.cardDB[c.cardId];
                    if (!dbCard) return;

                    const el = document.createElement('div');
                    el.className = `relative rounded-md bg-cover bg-center shadow-md border border-white/10 hover:scale-110 hover:z-10 transition-transform cursor-pointer`;
                    el.style.width = '100%';
                    el.style.aspectRatio = '2.5 / 3.5';
                    el.style.backgroundImage = `url('${this.getCardImage(dbCard)}')`;

                    // Show sidebar preview when hovered
                    el.addEventListener('mouseenter', () => this.showPreview(dbCard));

                    container.appendChild(el);
                });

                document.getElementById('inspect-deck-modal').classList.remove('hidden');
            },

            closeInspectDeck() {
                document.getElementById('inspect-deck-modal').classList.add('hidden');
            },

            shuffleDeck(playerIndex) {
                this.saveState();
                const p = this.state.players[playerIndex];

                if (p.deck.length > 1) {
                    this.shuffle(p.deck);
                    this.logAction(`You shuffled ${p.id === this.state.activePlayer ? 'your' : "the opponent's"} deck.`);
                }

                this.render();
            },

            updateLog() {
                const logEl = document.getElementById('game-log');
                logEl.innerHTML = '';
                this.state.log.slice(-30).forEach(entry => {
                    const d = document.createElement('div');
                    d.className = `text-xs mb-1 ${entry.isSystem ? 'text-gray-500 font-bold' : (entry.player === 0 ? 'text-teal-400' : 'text-orange-400')}`;
                    d.innerText = entry.text;
                    logEl.appendChild(d);
                });
                logEl.scrollTop = logEl.scrollHeight;
            },

            updateMetrics() {
                if (!this.abilitiesConfigLoaded) return;

                let p1Bcr = 0, p1Lvi = 0;
                let p2Bcr = 0, p2Lvi = 0;

                // Calculate BCR and LVI for both players based on field
                this.state.players[0].field.forEach(c => {
                    const dbCard = this.cardDB[c.cardId];
                    if (dbCard && dbCard.fullTextSections) {
                        try {
                            const m = UnifiedWinProbabiliyCalculation.calculateCardMetrics(dbCard);
                            p1Bcr += m.bcr || 0;
                            p1Lvi += m.lvi || 0;
                        } catch (e) { }
                    }
                });

                this.state.players[1].field.forEach(c => {
                    const dbCard = this.cardDB[c.cardId];
                    if (dbCard && dbCard.fullTextSections) {
                        try {
                            const m = UnifiedWinProbabiliyCalculation.calculateCardMetrics(dbCard);
                            p2Bcr += m.bcr || 0;
                            p2Lvi += m.lvi || 0;
                        } catch (e) { }
                    }
                });

                document.getElementById('bcr-val-p1').innerText = p1Bcr.toFixed(1);
                document.getElementById('bcr-val-p2').innerText = p2Bcr.toFixed(1);
                document.getElementById('lvi-val-p1').innerText = p1Lvi.toFixed(1);
                document.getElementById('lvi-val-p2').innerText = p2Lvi.toFixed(1);

                const totalBcr = p1Bcr + p2Bcr;
                const p1BcrPct = totalBcr > 0 ? (p1Bcr / totalBcr) * 100 : 50;
                const p2BcrPct = 100 - p1BcrPct;

                const totalLvi = p1Lvi + p2Lvi;
                const p1LviPct = totalLvi > 0 ? (p1Lvi / totalLvi) * 100 : 50;
                const p2LviPct = 100 - p1LviPct;

                const bcrP0 = document.getElementById('bcr-p1'); // Technically maps to Player 1 (id=0)
                const bcrP1 = document.getElementById('bcr-p2'); // Technically maps to Player 2 (id=1)

                // If P2 is active (bottom), flip the order of the flex items so P2 is on the left
                const bcrContainer = bcrP0.parentElement;
                if (this.state.activePlayer === 1) {
                    bcrContainer.style.flexDirection = 'row-reverse';
                } else {
                    bcrContainer.style.flexDirection = 'row';
                }

                bcrP0.style.width = p1BcrPct + '%';
                bcrP1.style.width = p2BcrPct + '%';

                const lviP0 = document.getElementById('lvi-p1');
                const lviP1 = document.getElementById('lvi-p2');

                const lviContainer = lviP0.parentElement;
                if (this.state.activePlayer === 1) {
                    lviContainer.style.flexDirection = 'row-reverse';
                } else {
                    lviContainer.style.flexDirection = 'row';
                }

                lviP0.style.width = p1LviPct + '%';
                lviP1.style.width = p2LviPct + '%';

                // We also need to flip the text labels underneath
                const bcrValP1 = document.getElementById('bcr-val-p1');
                const bcrValP2 = document.getElementById('bcr-val-p2');
                const lviValP1 = document.getElementById('lvi-val-p1');
                const lviValP2 = document.getElementById('lvi-val-p2');

                if (this.state.activePlayer === 1) {
                    bcrValP1.parentElement.style.flexDirection = 'row-reverse';
                    lviValP1.parentElement.style.flexDirection = 'row-reverse';
                } else {
                    bcrValP1.parentElement.style.flexDirection = 'row';
                    lviValP1.parentElement.style.flexDirection = 'row';
                }

                // --- Calculate Hand Potential ---
                let p0Hand = { ctl: 0, bcr: 0, rds: 0, lvi: 0 };
                let p1Hand = { ctl: 0, bcr: 0, rds: 0, lvi: 0 };

                const calcHand = (hand, metricsObj) => {
                    hand.forEach(c => {
                        const dbCard = this.cardDB[c.cardId];
                        if (dbCard && dbCard.fullTextSections) {
                            try {
                                const m = UnifiedWinProbabiliyCalculation.calculateCardMetrics(dbCard);
                                metricsObj.bcr += m.bcr || 0;
                                metricsObj.rds += m.rds || 0;
                                metricsObj.lvi += m.lvi || 0;
                                metricsObj.ctl += m.ctl !== undefined ? m.ctl : ((m.bcr || 0) + (m.rds || 0) + (m.lvi || 0));
                            } catch (e) { }
                        }
                    });
                };

                calcHand(this.state.players[0].hand, p0Hand);
                calcHand(this.state.players[1].hand, p1Hand);

                // Assign to Active (Bottom) and Inactive (Top)
                const apHand = this.state.activePlayer === 0 ? p0Hand : p1Hand;
                const ipHand = this.state.activePlayer === 0 ? p1Hand : p0Hand;

                document.getElementById('bottom-hand-ctl').innerText = apHand.ctl.toFixed(1);
                document.getElementById('bottom-hand-bcr').innerText = apHand.bcr.toFixed(1);
                document.getElementById('bottom-hand-rds').innerText = apHand.rds.toFixed(1);
                document.getElementById('bottom-hand-lvi').innerText = apHand.lvi.toFixed(1);

                document.getElementById('top-hand-ctl').innerText = ipHand.ctl.toFixed(1);
                document.getElementById('top-hand-bcr').innerText = ipHand.bcr.toFixed(1);
                document.getElementById('top-hand-rds').innerText = ipHand.rds.toFixed(1);
                document.getElementById('top-hand-lvi').innerText = ipHand.lvi.toFixed(1);
            },

            buildField(player, container) {
                container.innerHTML = '';
                const locations = player.field.filter(c => this.cardDB[c.cardId].type === 'Location');
                const charactersAtLocations = player.field.filter(c => c.locationId);
                const independentCards = player.field.filter(c => !c.locationId && this.cardDB[c.cardId].type !== 'Location');

                // Render independent cards
                independentCards.forEach(c => container.appendChild(this.createCardElement(c)));

                // Render locations with their stacked characters
                locations.forEach(loc => {
                    const group = document.createElement('div');
                    group.className = 'relative flex flex-col items-center mx-2 group p-2 rounded border border-transparent transition-all';

                    // Drop target logic for adding characters to this location
                    group.ondragover = (e) => { e.preventDefault(); e.stopPropagation(); group.classList.add('bg-white/10', 'border-white/30'); };
                    group.ondragleave = (e) => { e.preventDefault(); e.stopPropagation(); group.classList.remove('bg-white/10', 'border-white/30'); };
                    group.ondrop = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        group.classList.remove('bg-white/10', 'border-white/30');
                        this.dropToLocation(e, loc.instanceId);
                    };

                    const charsHere = charactersAtLocations.filter(c => c.locationId === loc.instanceId);

                    if (charsHere.length > 0) {
                        const charContainer = document.createElement('div');
                        charContainer.className = 'flex flex-wrap justify-center gap-2 z-10 relative mb-[-40px] pointer-events-none';
                        charsHere.forEach(c => {
                            const el = this.createCardElement(c);
                            el.style.pointerEvents = 'auto'; // Re-enable hover and drag for the characters
                            el.classList.add('scale-90', 'hover:scale-95', 'shadow-[0_10px_15px_rgba(0,0,0,0.8)]');
                            charContainer.appendChild(el);
                        });
                        group.appendChild(charContainer);
                    }

                    const locEl = this.createCardElement(loc);
                    group.appendChild(locEl);

                    container.appendChild(group);
                });
            },

            render() {
                const ap = this.state.players[this.state.activePlayer];
                const ip = this.state.players[this.state.inactivePlayer];

                // Update Sidebar
                document.getElementById('p0-cards').innerText = `${this.state.players[0].deck.length} deck | ${this.state.players[0].hand.length} hand`;
                document.getElementById('p1-cards').innerText = `${this.state.players[1].deck.length} deck | ${this.state.players[1].hand.length} hand`;

                // Highlight active player badge
                document.getElementById('p0-badge').className = `py-1 px-2 rounded bg-gray-800 text-sm mb-1 border-l-2 border-orange-500 flex justify-between ${this.state.activePlayer === 0 ? 'text-white shadow-inner bg-gray-700' : 'text-gray-400'}`;
                document.getElementById('p1-badge').className = `py-1 px-2 rounded bg-gray-800 text-sm border-l-2 border-purple-500 flex justify-between ${this.state.activePlayer === 1 ? 'text-white shadow-inner bg-gray-700' : 'text-gray-400'}`;

                // Quest Count & Mulligan Visibility
                let readyLoreChars = 0;
                // Update quest counter to exclude drying characters
                ap.field.forEach(c => { if (!c.exerted && !c.drying && this.cardDB[c.cardId].lore > 0) readyLoreChars++; });
                document.getElementById('quest-count').innerText = readyLoreChars;

                const mulliganBtn = document.getElementById('mulligan-btn');
                if (this.state.turn === 1 && !ap.hasMulliganed) {
                    mulliganBtn.classList.remove('hidden');
                } else {
                    mulliganBtn.classList.add('hidden');
                }

                this.updateLog();
                this.updateMetrics();

                // Update Timeline Board Divider Color
                const divider = document.getElementById('board-divider');
                if (divider) {
                    if (this.state.activeTimelineColor) {
                        divider.style.backgroundColor = this.state.activeTimelineColor;
                        divider.style.boxShadow = `0 0 15px ${this.state.activeTimelineColor}`;
                        divider.classList.remove('opacity-0');
                        divider.classList.add('opacity-80');
                    } else {
                        divider.style.backgroundColor = 'transparent';
                        divider.style.boxShadow = 'none';
                        divider.classList.add('opacity-0');
                        divider.classList.remove('opacity-80');
                    }
                }

                // Apply Player Identity Colors dynamically to Top and Bottom Boards
                // P1 (id=0) is Orange (#a86b32), P2 (id=1) is Purple (#3f2e70)
                const topBoard = document.getElementById('top-board');
                const bottomBoard = document.getElementById('bottom-board');

                // Remove existing
                topBoard.classList.remove('bg-[#a86b32]', 'bg-[#3f2e70]');
                bottomBoard.classList.remove('bg-[#a86b32]', 'bg-[#3f2e70]');

                // Add based on who is playing
                topBoard.classList.add(ip.id === 0 ? 'bg-[#a86b32]' : 'bg-[#3f2e70]');
                bottomBoard.classList.add(ap.id === 0 ? 'bg-[#a86b32]' : 'bg-[#3f2e70]');

                // --- TOP BOARD (Inactive Player) ---
                document.getElementById('top-player-bg-text').innerText = `P${ip.id + 1}`;
                document.getElementById('top-lore').innerText = ip.lore;
                document.getElementById('top-ink').innerText = `${ip.inkReady}/${ip.inkTotal}`;
                document.getElementById('top-deck-count').innerText = ip.deck.length;

                // Update Reveal Button
                document.getElementById('reveal-icon').className = this.state.opponentHandRevealed ? 'fa-solid fa-eye-slash' : 'fa-solid fa-eye';
                document.getElementById('reveal-text').innerText = this.state.opponentHandRevealed ? 'Hide Hand' : 'Reveal Hand';

                // Top Hand (Hidden or Revealed based on state)
                const th = document.getElementById('top-hand');
                th.innerHTML = '';
                ip.hand.forEach(c => th.appendChild(this.createCardElement(c, !this.state.opponentHandRevealed)));

                // Top Field
                const tf = document.getElementById('top-field');
                this.buildField(ip, tf);

                // Top Inkwell
                const ti = document.getElementById('top-inkwell-cards');
                ti.innerHTML = '';
                ip.inkwell.forEach((c, i) => {
                    const el = this.createCardElement(c, false, true);
                    el.style.position = 'absolute';
                    el.style.left = (i * 20) + 'px';
                    el.style.top = '0px';
                    ti.appendChild(el);
                });

                // Top Discard
                const td = document.getElementById('top-discard');
                td.innerHTML = '<span class="absolute inset-0 flex items-center justify-center text-gray-400 text-xs font-bold pointer-events-none">DISCARD</span>';
                ip.discard.forEach((c, i) => {
                    const el = this.createCardElement(c);
                    el.style.position = 'absolute';
                    el.style.left = Math.min(i * 3, 30) + 'px';
                    el.style.top = Math.min(i * 3, 30) + 'px';
                    el.style.zIndex = i;
                    td.appendChild(el);
                });

                // --- BOTTOM BOARD (Active Player) ---
                document.getElementById('bottom-player-bg-text').innerText = `P${ap.id + 1}`;
                document.getElementById('bottom-lore').innerText = ap.lore;
                document.getElementById('bottom-ink').innerText = `${ap.inkReady}/${ap.inkTotal}`;
                document.getElementById('bottom-deck-count').innerText = ap.deck.length;

                // Bottom Hand (Visible)
                const bh = document.getElementById('bottom-hand');
                bh.innerHTML = '';
                ap.hand.forEach(c => bh.appendChild(this.createCardElement(c)));

                // Bottom Field
                const bf = document.getElementById('bottom-field');
                this.buildField(ap, bf);

                // Bottom Inkwell
                const bi = document.getElementById('bottom-inkwell-cards');
                bi.innerHTML = '';
                ap.inkwell.forEach((c, i) => {
                    const el = this.createCardElement(c, false, true);
                    el.style.position = 'absolute';
                    el.style.left = (i * 20) + 'px';
                    el.style.top = '0px';
                    bi.appendChild(el);
                });

                // Bottom Discard
                const bd = document.getElementById('bottom-discard');
                bd.innerHTML = '<span class="absolute inset-0 flex items-center justify-center text-gray-400 text-xs font-bold pointer-events-none">DISCARD</span>';
                ap.discard.forEach((c, i) => {
                    const el = this.createCardElement(c);
                    el.style.position = 'absolute';
                    el.style.left = Math.min(i * 3, 30) + 'px';
                    el.style.top = Math.min(i * 3, 30) + 'px';
                    el.style.zIndex = i;
                    bd.appendChild(el);
                });
            }
        };

        // Close context menu on external click
        document.addEventListener('click', () => {
            document.getElementById('context-menu').style.display = 'none';
        });

        // Init App on load
        window.onload = () => App.init();
    </script>
</body>

</html>