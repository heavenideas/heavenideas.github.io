<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorcana Deck Manager & Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            /* bg-gray-900 */
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1f2937;
        }

        /* bg-gray-800 */
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        /* bg-gray-600 */
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* bg-gray-500 */

        #confirmationModal,
        #loadingOverlay {
            transition: opacity 0.3s ease;
        }

        .visuals-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            min-height: 0;
        }

        @media (max-width: 1024px) {
            .visuals-grid {
                grid-template-columns: 1fr;
            }
        }

        .chart-container {
            position: relative;
            height: 250px;
            width: 100%;
            /* Default to full width on small screens */
            min-width: 300px;
            /* Minimum width for charts */
        }

        @media (min-width: 768px) {

            /* md breakpoint */
            .chart-container {
                width: calc(50% - 1rem);
                /* Two charts per row with gap */
            }
        }

        .card-stack {
            position: relative;
            width: 150px;
            height: 210px;
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
            border-radius: 9px;
            /* Slightly larger than image for border visibility */
            border: 3px solid transparent;
            transition: border-color 0.2s ease;
        }

        .card-stack.selected {
            border-color: #a855f7;
            /* purple-500 */
            box-shadow: 0 0 15px #a855f7;
        }

        .card-stack:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .card-stack img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            border: 1px solid #374151;
            /* gray-700 */
        }

        .card-count-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #9333ea;
            /* purple-600 */
            color: white;
            border-radius: 9999px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            border: 2px solid #111827;
            box-shadow: 0 0 0 3px #9333ea;
            z-index: 2;
        }

        .card-prob-overlay {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background-color: rgba(17, 24, 39, 0.8);
            /* bg-gray-900 with opacity */
            color: #d1d5db;
            /* gray-300 */
            font-size: 0.75rem;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 2;
            pointer-events: none;
            /* So it doesn't interfere with clicks */
        }

        .scenario-btn.active {
            background-color: #9333ea;
            color: white;
        }
    </style>
</head>

<body class="text-gray-200">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 z-50 flex items-center justify-center bg-gray-900 bg-opacity-80">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-purple-400 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <p class="mt-4 text-lg font-semibold">Loading Card Database...</p>
        </div>
    </div>

    <div class="container mx-auto p-4 md:p-8 max-w-screen-2xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-purple-400">Lorcana Deck Manager & Visualizer</h1>
            <p class="text-gray-400 mt-2">Create, manage, and visualize your Lorcana decks.</p>
        </header>

        <!-- Top Section: Management and Editor -->
        <div class="flex flex-col md:flex-row gap-8 mb-8">
            <!-- Deck List Panel -->
            <div class="w-full md:w-1/3 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col h-[60vh] md:h-[75vh]">
                <h2 class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2">My Decks</h2>
                <!-- Deck Search Input -->
                <div class="relative mb-4">
                    <input type="text" id="deckSearch" placeholder="Search by name or comments..."
                        class="w-full bg-gray-700 border border-gray-600 rounded-md pl-10 pr-4 py-2 focus:ring-2 focus:ring-purple-500 focus:outline-none">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                            fill="currentColor">
                            <path fill-rule="evenodd"
                                d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z"
                                clip-rule="evenodd" />
                        </svg>
                    </div>
                </div>
                <div id="deckListContainer" class="space-y-2 flex-grow overflow-y-auto">
                    <!-- Deck items will be injected here by JavaScript -->
                </div>
            </div>

            <!-- Deck Editor Panel -->
            <div class="w-full md:w-2/3 bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 id="editorTitle" class="text-2xl font-semibold mb-4">Create New Deck</h2>
                <form id="deckForm" class="space-y-6">
                    <input type="hidden" id="deckId">
                    <div>
                        <label for="deckName" class="block text-sm font-medium text-gray-300 mb-1">Deck Name</label>
                        <input type="text" id="deckName" required
                            class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                            placeholder="e.g., Amber/Steel Steelsong">
                    </div>
                    
                    <!-- Card Search Section -->
                    <div>
                        <label for="cardSearchInput" class="block text-sm font-medium text-gray-300 mb-1">Add Cards to Deck</label>
                        <div class="relative">
                            <input type="text" id="cardSearchInput"
                                class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                                placeholder="Search for a card name to add it..." autocomplete="off">
                            <div id="cardSearchResults" class="absolute z-20 w-full bg-gray-600 border border-gray-500 rounded-md mt-1 max-h-72 overflow-y-auto hidden">
                                <!-- Search results will appear here -->
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label for="decklist" class="block text-sm font-medium text-gray-300">Decklist</label>
                           <div class="flex gap-2">
                               <button type="button" id="generateLlmPromptBtn" class="px-3 py-1 bg-blue-600 hover:bg-blue-500 text-xs rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-purple-500">
                                   Generate Deck Guide Prompt
                               </button>
                               <button type="button" id="copyDecklistBtn" class="px-3 py-1 bg-gray-600 hover:bg-gray-500 text-xs rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-purple-500">
                                   Copy Decklist
                               </button>
                           </div>
                        </div>
                        <textarea id="decklist" rows="10" required
                            class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:outline-none font-mono text-sm"
                            placeholder="4 Captain Hook, Forceful Duelist..."></textarea>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">Ink Types</label>
                        <div id="inkTypes" class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                            <!-- Ink type checkboxes will be injected here -->
                        </div>
                    </div>
                    <div>
                        <label for="deckUrl" class="block text-sm font-medium text-gray-300 mb-1">URL (Optional)</label>
                        <input type="url" id="deckUrl"
                            class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                            placeholder="https://lorcania.com/decks/...">
                    </div>
                    <div>
                        <label for="comments" class="block text-sm font-medium text-gray-300 mb-1">Comments
                            (Optional)</label>
                        <textarea id="comments" rows="3"
                            class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                            placeholder="Mulligan strategy, card combos, testing notes..."></textarea>
                    </div>
                    <div class="flex items-center justify-between pt-4 border-t border-gray-700">
                        <div class="flex gap-2">
                            <button type="submit"
                                class="px-6 py-2 bg-purple-600 hover:bg-purple-700 rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-purple-500">Save
                                Deck</button>
                            <button type="button" id="newDeckBtn"
                                class="px-6 py-2 bg-gray-600 hover:bg-gray-500 rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-gray-400">New</button>
                        </div>
                        <button type="button" id="deleteDeckBtn"
                            class="px-6 py-2 bg-red-600 hover:bg-red-700 rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-red-500 hidden">Delete</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Bottom Section: Visualizer and Charts -->
        <div class="visuals-grid">
            <!-- Center: Visual Deck Display -->
            <main id="visualDeckContainer" class="bg-gray-800 p-4 rounded-lg shadow-lg overflow-y-auto h-[60vh]">
                <div class="text-center text-gray-500 italic mt-8">Enter a decklist to see the cards here.</div>
            </main>
            <!-- Right: Charts -->
            <aside id="chartsContainer"
                class="bg-gray-800 p-4 rounded-lg shadow-lg flex flex-row flex-wrap justify-center items-start gap-4 overflow-y-auto h-[60vh]">
                <div class="text-center text-gray-400 w-full">Total Cards: <span id="total-cards"
                        class="font-bold">0</span>
                </div>
                <!-- Mulligan Probability -->
                <div id="mulliganCalculator" class="bg-gray-700 p-4 rounded-lg shadow-inner w-full">
                    <h3 class="text-lg font-semibold text-center mb-2">Mulligan Helper</h3>
                    <div class="grid grid-cols-2 gap-2 mb-3">
                        <button id="onThePlayBtn"
                            class="scenario-btn w-full px-3 py-1.5 bg-gray-600 hover:bg-gray-500 rounded-md font-semibold text-sm transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-700 focus:ring-purple-500 active">On
                            the Play</button>
                        <button id="onTheDrawBtn"
                            class="scenario-btn w-full px-3 py-1.5 bg-gray-600 hover:bg-gray-500 rounded-md font-semibold text-sm transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-700 focus:ring-purple-500">On
                            the Draw</button>
                    </div>
                    <p id="mulliganInstructions" class="text-center text-sm text-gray-400 mb-3">Click cards in the deck
                        to calculate combined draw probability.</p>
                    <div id="mulliganResultContainer" class="mt-2 text-center hidden">
                        <p class="text-gray-300">Prob. to find all selected cards:</p>
                        <p id="mulliganResult" class="text-3xl font-bold text-purple-400 mt-1">0%</p>
                        <p id="mulliganDetails" class="text-xs text-gray-400"></p>
                    </div>
                </div>
                <div class="chart-container">
                    <h3 class="text-lg font-semibold text-center mb-2">Ink Curve</h3>
                    <canvas id="inkCurveChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="text-lg font-semibold text-center mb-2">Color Split</h3>
                    <canvas id="colorSplitChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="text-lg font-semibold text-center mb-2">Inkable vs. Uninkable</h3>
                    <canvas id="inkableChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="text-lg font-semibold text-center mb-2">Card Types</h3>
                    <canvas id="cardTypeChart"></canvas>
                </div>
            </aside>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal"
        class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 p-4 opacity-0 pointer-events-none">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 class="text-lg font-bold text-white mb-4">Confirm Deletion</h3>
            <p class="text-gray-300 mb-6">Are you sure you want to delete this deck? This action cannot be undone.</p>
            <div class="flex justify-end gap-4"><button id="cancelDeleteBtn"
                    class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-md font-semibold transition-colors">Cancel</button><button
                    id="confirmDeleteBtn"
                    class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md font-semibold transition-colors">Delete</button>
            </div>
        </div>
    </div>

   <!-- LLM Prompt Modal -->
   <div id="llmPromptModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 p-4 opacity-0 pointer-events-none">
       <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl h-[90vh] flex flex-col">
           <div class="flex justify-between items-center mb-4">
               <h3 class="text-lg font-bold text-white">Generated LLM Prompt</h3>
               <button id="closeLlmModalBtn" class="text-gray-400 hover:text-white">&times;</button>
           </div>
           <textarea id="llmPromptOutput" readonly class="w-full h-full bg-gray-900 border border-gray-700 rounded-md p-4 focus:ring-2 focus:ring-purple-500 focus:outline-none font-mono text-sm whitespace-pre-wrap"></textarea>
           <div class="flex justify-end gap-4 mt-4">
               <button id="copyLlmPromptBtn" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-md font-semibold transition-colors">Copy Prompt</button>
           </div>
       </div>
   </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- GLOBAL STATE & CONFIG ---
            const SUPABASE_URL = 'https://cjlhrfhximjldqrfblkj.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNqbGhyZmh4aW1qbGRxcmZibGtqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA0MTcxNzQsImV4cCI6MjA2NTk5MzE3NH0.zLiQcPnKt2SnNfQIkUnOG7bOo6F7MPMh8MsasdFF6lw';
            const CARD_DATA_URL = 'https://raw.githubusercontent.com/heavenideas/similcana/refs/heads/main/database/allCards.json';

            const INK_COLORS = {
                Amber: { hex: '#FCD34D', name: 'Amber' }, Amethyst: { hex: '#C084FC', name: 'Amethyst' },
                Emerald: { hex: '#34D399', name: 'Emerald' }, Ruby: { hex: '#F87171', name: 'Ruby' },
                Sapphire: { hex: '#60A5FA', name: 'Sapphire' }, Steel: { hex: '#9CA3AF', name: 'Steel' }
            };
            const TYPE_COLORS = { Character: '#2563eb', Item: '#db2777', Location: '#d97706', Action: '#16a34a', Song: '#8b5cf6' };

            let allCards = [];
            let cardFuse;
            let charts = {};
            let selectedForMulligan = [];
            let currentDeck = [];
            let allDecks = [];
            let deckFuse;
            let mulliganScenario = 'OnThePlay'; // 'OnThePlay' or 'OnTheDraw'


            // --- UI ELEMENTS ---
            const loadingOverlay = document.getElementById('loadingOverlay');
            const deckForm = document.getElementById('deckForm');
            const deckListContainer = document.getElementById('deckListContainer');
            const newDeckBtn = document.getElementById('newDeckBtn');
            const deleteDeckBtn = document.getElementById('deleteDeckBtn');
            const editorTitle = document.getElementById('editorTitle');
            const deckIdInput = document.getElementById('deckId');
            const decklistTextarea = document.getElementById('decklist');
            const inkTypesContainer = document.getElementById('inkTypes');
            const visualDeckContainer = document.getElementById('visualDeckContainer');
            const totalCardsSpan = document.getElementById('total-cards');
            const confirmationModal = document.getElementById('confirmationModal');
            const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
            const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
            const mulliganResultContainer = document.getElementById('mulliganResultContainer');
            const mulliganResultEl = document.getElementById('mulliganResult');
            const mulliganDetailsEl = document.getElementById('mulliganDetails');
            const mulliganInstructions = document.getElementById('mulliganInstructions');
            const deckSearchInput = document.getElementById('deckSearch');
            const onThePlayBtn = document.getElementById('onThePlayBtn');
            const onTheDrawBtn = document.getElementById('onTheDrawBtn');
            const cardSearchInput = document.getElementById('cardSearchInput');
            const cardSearchResults = document.getElementById('cardSearchResults');
            const copyDecklistBtn = document.getElementById('copyDecklistBtn');
           const llmPromptModal = document.getElementById('llmPromptModal');
           const closeLlmModalBtn = document.getElementById('closeLlmModalBtn');
           const llmPromptOutput = document.getElementById('llmPromptOutput');
           const copyLlmPromptBtn = document.getElementById('copyLlmPromptBtn');
           const generateLlmPromptBtn = document.getElementById('generateLlmPromptBtn');


            // --- PROBABILITY FUNCTIONS ---
            function probMiss(N, K, n) {
                if (K > N || n > N || K < 0 || n < 0 || N <= 0) return 1.0;
                if (N - K < n) return 0.0;
                let prob = 1.0;
                for (let i = 0; i < n; i++) {
                    prob *= (N - K - i) / (N - i);
                }
                return prob;
            }

            function updateCombinedProbability() {
                mulliganInstructions.classList.toggle('hidden', selectedForMulligan.length > 0);
                mulliganResultContainer.classList.toggle('hidden', selectedForMulligan.length === 0);
                if (selectedForMulligan.length === 0) return;

                const N = currentDeck.reduce((sum, item) => sum + item.count, 0);
                const selection = selectedForMulligan;
                const numSelected = selection.length;

                const drawBonus = mulliganScenario === 'OnTheDraw' ? 1 : 0;
                const n = 7 + (7 - numSelected) + drawBonus;

                let probUnionOfMissing = 0;

                for (let i = 1; i < (1 << numSelected); i++) {
                    let K_sum = 0, subsetSize = 0;
                    for (let j = 0; j < numSelected; j++) {
                        if ((i >> j) & 1) {
                            K_sum += selection[j].count;
                            subsetSize++;
                        }
                    }
                    const termProb = probMiss(N, K_sum, n);
                    if (subsetSize % 2 === 1) probUnionOfMissing += termProb;
                    else probUnionOfMissing -= termProb;
                }

                const finalProb = 1 - probUnionOfMissing;
                mulliganResultEl.textContent = `${(finalProb * 100).toFixed(2)}%`;
                mulliganDetailsEl.textContent = `(Hand of 7 + Mulligan of ${7 - numSelected} + ${drawBonus} draw = ${n} cards seen)`;
            }

            function handleCardSelection(cardName, cardCount) {
                const existingIndex = selectedForMulligan.findIndex(item => item.name === cardName);
                if (existingIndex > -1) {
                    selectedForMulligan.splice(existingIndex, 1);
                    document.querySelector(`.card-stack[data-card-name="${CSS.escape(cardName)}"]`).classList.remove('selected');
                } else {
                    if (selectedForMulligan.length < 7) {
                        selectedForMulligan.push({ name: cardName, count: cardCount });
                        document.querySelector(`.card-stack[data-card-name="${CSS.escape(cardName)}"]`).classList.add('selected');
                    } else {
                        console.log("Maximum of 7 cards for mulligan calculation reached.");
                        return;
                    }
                }
                updateCombinedProbability();
            }

            // --- SUPABASE & DATA ---
            const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

            // --- CHART & VISUALIZATION ---
            function initializeCharts() {
                Chart.defaults.color = '#9ca3af';
                Chart.defaults.borderColor = '#374151';
                const commonOptions = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } };
                const pieOptions = { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { boxWidth: 12 } } } };
                charts.inkCurve = new Chart(document.getElementById('inkCurveChart'), { type: 'bar', data: { labels: ['0', '1', '2', '3', '4', '5', '6', '7+'], datasets: [{ data: [], backgroundColor: '#a855f7' }] }, options: { ...commonOptions, scales: { y: { beginAtZero: true, grid: { color: '#374151' } } } } });
                charts.colorSplit = new Chart(document.getElementById('colorSplitChart'), { type: 'pie', data: { labels: [], datasets: [{ data: [] }] }, options: pieOptions });
                charts.inkable = new Chart(document.getElementById('inkableChart'), { type: 'pie', data: { labels: ['Inkable', 'Uninkable'], datasets: [{ data: [], backgroundColor: ['#10b981', '#ef4444'] }] }, options: pieOptions });
                charts.cardType = new Chart(document.getElementById('cardTypeChart'), { type: 'pie', data: { labels: [], datasets: [{ data: [] }] }, options: pieOptions });
            }

            function parseAndRenderDeck() {
                const text = decklistTextarea.value;
                const lines = text.split('\n').filter(line => line.trim() !== '');
                const deck = [];
                const lineRegex = /^(?:(\d+)x?\s)?(.*)/;
                for (const line of lines) {
                    const match = line.trim().match(lineRegex);
                    if (match) {
                        const count = parseInt(match[1] || '1', 10);
                        const cardName = match[2].trim();
                        if (cardName) {
                            const results = cardFuse.search(cardName);
                            if (results.length > 0) {
                                deck.push({ count, card: results[0].item });
                            }
                        }
                    }
                }
                currentDeck = deck;
                renderVisualDeck(deck);
                updateCharts(deck);
                updateTotalCards(deck);
                selectedForMulligan = [];
                updateCombinedProbability();
            }

            function renderVisualDeck(deck) {
                visualDeckContainer.innerHTML = '';
                if (deck.length === 0) {
                    visualDeckContainer.innerHTML = `<div class="text-center text-gray-500 italic mt-8">Enter a decklist to see the cards here.</div>`;
                    return;
                }
                const totalDeckSize = deck.reduce((sum, item) => sum + item.count, 0);
                const drawBonus = mulliganScenario === 'OnTheDraw' ? 1 : 0;
                // Probability to see at least one copy in opening hand + mulligan
                const cardsSeenForMulligan = 7 + (7) + drawBonus;

                const grouped = deck.reduce((acc, { count, card }) => {
                    const type = card.type || 'Unknown';
                    if (!acc[type]) acc[type] = [];
                    acc[type].push({ count, card });
                    return acc;
                }, {});
                const typeOrder = ['Character', 'Action', 'Item', 'Location', 'Song'];
                for (const type of typeOrder) {
                    if (grouped[type]) {
                        const section = document.createElement('div');
                        section.className = 'mb-6';
                        section.innerHTML = `<h2 class="text-xl font-bold text-purple-300 mb-3 border-b-2 border-gray-700 pb-1">${type}s</h2>`;
                        const grid = document.createElement('div');
                        grid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4';
                        grouped[type].sort((a, b) => a.card.cost - b.card.cost || a.card.name.localeCompare(b.card.name)).forEach(({ count, card }) => {
                            const stackDiv = document.createElement('div');
                            stackDiv.className = 'card-stack';
                            stackDiv.dataset.cardName = card.fullName;
                            const probOfFinding = 1 - probMiss(totalDeckSize, count, cardsSeenForMulligan);
                            const probText = (probOfFinding * 100).toFixed(1) + '%';
                            stackDiv.innerHTML = `<div class="card-count-badge">${count}</div><img src="${card.images.full}" alt="${card.fullName}" loading="lazy" onerror="this.onerror=null;this.src='https://placehold.co/150x210/1f2937/9ca3af?text=${encodeURIComponent(card.name)}';"><div class="card-prob-overlay" title="Prob. in open hand + mulligan">${probText}</div>`;
                            stackDiv.addEventListener('click', () => handleCardSelection(card.fullName, count));
                            grid.appendChild(stackDiv);
                        });
                        section.appendChild(grid);
                        visualDeckContainer.appendChild(section);
                    }
                }
                // Re-apply selection visuals
                selectedForMulligan.forEach(sel => {
                    const el = document.querySelector(`.card-stack[data-card-name="${CSS.escape(sel.name)}"]`);
                    if (el) el.classList.add('selected');
                });
            }

            function updateTotalCards(deck) {
                const total = deck.reduce((sum, item) => sum + item.count, 0);
                totalCardsSpan.textContent = total;
            }

            function updateCharts(deck) {
                const inkCurveData = Array(8).fill(0), colorSplitData = {}, inkableData = { inkable: 0, uninkable: 0 }, cardTypeData = {};
                deck.forEach(({ count, card }) => {
                    inkCurveData[Math.min(card.cost, 7)] += count;
                    (card.colors || [card.color]).forEach(color => { if (color) colorSplitData[color] = (colorSplitData[color] || 0) + count; });
                    if (card.inkwell) inkableData.inkable += count; else inkableData.uninkable += count;
                    let mainType = card.type === 'Action' && (card.subtypes || []).includes('Song') ? 'Song' : card.type;
                    cardTypeData[mainType] = (cardTypeData[mainType] || 0) + count;
                });
                charts.inkCurve.data.datasets[0].data = inkCurveData;
                charts.colorSplit.data.labels = Object.keys(colorSplitData);
                charts.colorSplit.data.datasets[0].data = Object.values(colorSplitData);
                charts.colorSplit.data.datasets[0].backgroundColor = Object.keys(colorSplitData).map(c => INK_COLORS[c]?.hex || '#fff');
                charts.inkable.data.datasets[0].data = [inkableData.inkable, inkableData.uninkable];
                charts.cardType.data.labels = Object.keys(cardTypeData);
                charts.cardType.data.datasets[0].data = Object.values(cardTypeData);
                charts.cardType.data.datasets[0].backgroundColor = Object.keys(cardTypeData).map(t => TYPE_COLORS[t] || '#fff');
                Object.values(charts).forEach(chart => chart.update());
            }

            // --- DECK BUILDING & SEARCH ---
            function renderSearchResults(results) {
                cardSearchResults.innerHTML = '';
                if (results.length === 0) {
                    cardSearchResults.classList.add('hidden');
                    return;
                }

                results.forEach(result => {
                    const card = result.item;
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'p-2 hover:bg-purple-800 border-b border-gray-500 flex items-center gap-3 cursor-pointer';
                    
                    // Card thumbnail image
                    const thumbnailImg = document.createElement('img');
                    thumbnailImg.src = card.images.full;
                    thumbnailImg.alt = card.fullName;
                    thumbnailImg.className = 'w-10 h-14 object-contain rounded-sm flex-shrink-0';
                    thumbnailImg.loading = 'lazy';
                    
                    // Text container for name
                    const textContainer = document.createElement('div');
                    textContainer.className = 'flex-grow min-w-0'; // flex-grow to take space, min-w-0 to allow shrinking
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'font-semibold block truncate'; // truncate long names
                    const cardColor = card.colors && card.colors.length > 0 ? card.colors[0] : 'Steel';
                    nameSpan.textContent = card.fullName; // Use the full name
                    nameSpan.style.color = INK_COLORS[cardColor]?.hex || '#9CA3AF';
                    nameSpan.title = card.fullName; // Show full name on hover if truncated
                    textContainer.appendChild(nameSpan);

                    // Container for add buttons
                    const addControlsDiv = document.createElement('div');
                    addControlsDiv.className = 'flex items-center gap-1 flex-shrink-0';

                    [1, 2, 3, 4].forEach(count => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.textContent = `+${count}`;
                        btn.className = 'px-2 py-1 bg-gray-500 hover:bg-purple-600 text-white text-xs font-bold rounded transition-colors';
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            addCardToDecklist(card, count);
                        });
                        addControlsDiv.appendChild(btn);
                    });
                    
                    resultDiv.addEventListener('click', () => {
                        addCardToDecklist(card, 1);
                    });
                    
                    resultDiv.appendChild(thumbnailImg);
                    resultDiv.appendChild(textContainer);
                    resultDiv.appendChild(addControlsDiv);
                    cardSearchResults.appendChild(resultDiv);
                });

                cardSearchResults.classList.remove('hidden');
            }


            function addCardToDecklist(card, count) {
                const cardFullName = card.fullName;
                const lines = decklistTextarea.value.split('\n').filter(l => l.trim() !== '');
                let cardFound = false;
                const lineRegex = /^(?:(\d+)x?\s)?(.*)/;

                for (let i = 0; i < lines.length; i++) {
                    const match = lines[i].trim().match(lineRegex);
                    if (match) {
                        const nameFromLine = match[2].trim();
                        // Use a more direct comparison first, then fallback to Fuse for robustness
                        if (nameFromLine.toLowerCase() === cardFullName.toLowerCase()) {
                             const newCount = count; // Set to the specific count clicked
                             lines[i] = `${newCount} ${cardFullName}`;
                             cardFound = true;
                             break;
                        }
                    }
                }

                if (!cardFound) {
                     for (let i = 0; i < lines.length; i++) {
                        const match = lines[i].trim().match(lineRegex);
                        if(match) {
                            const nameFromLine = match[2].trim();
                            const searchResult = cardFuse.search(nameFromLine);
                            if (searchResult.length > 0 && searchResult[0].item.fullName === cardFullName) {
                                const newCount = count; // Set to the specific count clicked
                                lines[i] = `${newCount} ${cardFullName}`;
                                cardFound = true;
                                break;
                            }
                        }
                    }
                }


                if (!cardFound) {
                    lines.push(`${count} ${cardFullName}`);
                }

                decklistTextarea.value = lines.join('\n');
                decklistTextarea.dispatchEvent(new Event('input', { bubbles: true }));

                cardSearchInput.value = '';
                cardSearchResults.classList.add('hidden');
                cardSearchInput.focus();
            }

            // --- DATABASE & DECK LIST LOGIC ---
            const saveDeck = async (deckData) => {
                const { data, error } = await supabaseClient.from('decks').upsert(deckData).select();
                if (error) { console.error('Error saving deck:', error); return null; }
                return data ? data[0] : null;
            };

            const deleteDeck = async (deckId) => {
                const { error } = await supabaseClient.from('decks').delete().eq('id', deckId);
                if (error) console.error('Error deleting deck:', error);
            };

            const renderInkTypes = () => {
                inkTypesContainer.innerHTML = '';
                for (const [name, { hex }] of Object.entries(INK_COLORS)) {
                    const div = document.createElement('div');
                    div.className = 'flex items-center';
                    div.innerHTML = `<input type="checkbox" id="ink-${name.toLowerCase()}" name="ink" value="${name}" class="h-4 w-4 rounded border-gray-500 bg-gray-700 focus:ring-purple-500" style="accent-color: ${hex};"><label for="ink-${name.toLowerCase()}" class="ml-2 block text-sm text-gray-300" style="color: ${hex};">${name}</label>`;
                    inkTypesContainer.appendChild(div);
                }
            };

            const renderDeckList = (decksToRender) => {
                deckListContainer.innerHTML = !decksToRender.length ? `<p class="text-gray-500 italic p-4 text-center">No decks found.</p>` : '';
                decksToRender.forEach(deck => {
                    const button = document.createElement('button');
                    button.className = 'w-full text-left p-3 rounded-md hover:bg-gray-700 focus:bg-purple-900/50 focus:outline-none transition-colors';
                    button.dataset.deckId = deck.id;
                    const inkBadges = (deck.inks || []).map(ink => `<span class="inline-block w-3 h-3 rounded-full" style="background-color: ${INK_COLORS[ink]?.hex || '#fff'}" title="${INK_COLORS[ink]?.name || 'Unknown'}"></span>`).join('');
                    button.innerHTML = `<h3 class="font-semibold text-gray-100">${deck.name}</h3><div class="flex items-center gap-2 mt-1">${inkBadges}</div>`;
                    button.addEventListener('click', () => {
                        populateForm(deck.id);
                        document.querySelectorAll('#deckListContainer button').forEach(btn => btn.classList.remove('bg-purple-900/50'));
                        button.classList.add('bg-purple-900/50');
                    });
                    deckListContainer.appendChild(button);
                });
            };

            const loadAndRenderDecks = async () => {
                const { data, error } = await supabaseClient.from('decks').select('*').order('created_at', { ascending: true });
                if (error) {
                    console.error('Error fetching decks:', error);
                    allDecks = [];
                } else {
                    allDecks = data;
                }
                deckFuse = new Fuse(allDecks, { keys: ['name', 'comments'], includeScore: true, threshold: 0.4 });
                deckSearchInput.value = ''; // Clear search on reload
                renderDeckList(allDecks);
            };

            const populateForm = async (deckId) => {
                const { data: deck, error } = await supabaseClient.from('decks').select('*').eq('id', deckId).single();
                if (error) { console.error('Error fetching single deck:', error); return; }
                if (deck) {
                    editorTitle.textContent = `Editing: ${deck.name}`;
                    deckIdInput.value = deck.id;
                    document.getElementById('deckName').value = deck.name;
                    decklistTextarea.value = deck.decklist || '';
                    document.getElementById('deckUrl').value = deck.url || '';
                    document.getElementById('comments').value = deck.comments || '';
                    document.querySelectorAll('#inkTypes input[type="checkbox"]').forEach(cb => { cb.checked = (deck.inks || []).includes(cb.value); });
                    deleteDeckBtn.classList.remove('hidden');
                    parseAndRenderDeck();
                }
            };

            const resetForm = () => {
                editorTitle.textContent = 'Create New Deck';
                deckForm.reset();
                deckIdInput.value = '';
                deleteDeckBtn.classList.add('hidden');
                document.querySelectorAll('#deckListContainer button').forEach(btn => btn.classList.remove('bg-purple-900/50'));
                parseAndRenderDeck();
            };

            // --- EVENT LISTENERS ---
            deckForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const deckData = {
                    id: deckIdInput.value || undefined,
                    name: document.getElementById('deckName').value,
                    decklist: decklistTextarea.value,
                    inks: Array.from(document.querySelectorAll('#inkTypes input:checked')).map(cb => cb.value),
                    url: document.getElementById('deckUrl').value,
                    comments: document.getElementById('comments').value
                };
                const savedDeck = await saveDeck(deckData);
                if (savedDeck) {
                    await loadAndRenderDecks();
                    const savedDeckButton = document.querySelector(`button[data-deck-id="${savedDeck.id}"]`);
                    if (savedDeckButton) { savedDeckButton.click(); savedDeckButton.focus(); }
                }
            });

            newDeckBtn.addEventListener('click', resetForm);

            decklistTextarea.addEventListener('input', () => {
                clearTimeout(window.deckRenderTimeout);
                window.deckRenderTimeout = setTimeout(parseAndRenderDeck, 250);
            });

            deckSearchInput.addEventListener('input', () => {
                const searchTerm = deckSearchInput.value.trim();
                if (searchTerm === '') {
                    renderDeckList(allDecks);
                    return;
                }
                const results = deckFuse.search(searchTerm);
                const filteredDecks = results.map(result => result.item);
                renderDeckList(filteredDecks);
            });
            
            // Card Search Listeners
            cardSearchInput.addEventListener('input', () => {
                const searchTerm = cardSearchInput.value.trim();
                if (searchTerm.length < 2) {
                    cardSearchResults.classList.add('hidden');
                    return;
                }
                const results = cardFuse.search(searchTerm);
                renderSearchResults(results.slice(0, 8)); // Show top 8
            });

            cardSearchInput.addEventListener('focus', () => {
                const searchTerm = cardSearchInput.value.trim();
                if (searchTerm.length >= 2) {
                    const results = cardFuse.search(searchTerm);
                    renderSearchResults(results.slice(0, 8));
                }
            });

            document.addEventListener('click', (e) => {
                const searchContainer = cardSearchInput.parentElement;
                if (!searchContainer.contains(e.target)) {
                    cardSearchResults.classList.add('hidden');
                }
            });

            onThePlayBtn.addEventListener('click', () => {
                mulliganScenario = 'OnThePlay';
                onThePlayBtn.classList.add('active');
                onTheDrawBtn.classList.remove('active');
                renderVisualDeck(currentDeck);
                updateCombinedProbability();
            });

            onTheDrawBtn.addEventListener('click', () => {
                mulliganScenario = 'OnTheDraw';
                onTheDrawBtn.classList.add('active');
                onThePlayBtn.classList.remove('active');
                renderVisualDeck(currentDeck);
                updateCombinedProbability();
            });

            const showConfirmationModal = () => confirmationModal.classList.remove('opacity-0', 'pointer-events-none');
            const hideConfirmationModal = () => confirmationModal.classList.add('opacity-0', 'pointer-events-none');
            deleteDeckBtn.addEventListener('click', () => { if (deckIdInput.value) showConfirmationModal(); });
            cancelDeleteBtn.addEventListener('click', hideConfirmationModal);
            confirmDeleteBtn.addEventListener('click', async () => {
                const deckId = deckIdInput.value;
                if (deckId) {
                    await deleteDeck(deckId);
                    await loadAndRenderDecks();
                    resetForm();
                    hideConfirmationModal();
                }
            });

           // LLM Prompt Modal Listeners
           generateLlmPromptBtn.addEventListener('click', generateLlmPrompt);
           closeLlmModalBtn.addEventListener('click', () => {
               llmPromptModal.classList.add('opacity-0', 'pointer-events-none');
           });
           llmPromptModal.addEventListener('click', (e) => {
               if (e.target === llmPromptModal) {
                   llmPromptModal.classList.add('opacity-0', 'pointer-events-none');
               }
           });
           copyLlmPromptBtn.addEventListener('click', () => {
               navigator.clipboard.writeText(llmPromptOutput.value).then(() => {
                   const originalText = copyLlmPromptBtn.textContent;
                   copyLlmPromptBtn.textContent = 'Copied!';
                   copyLlmPromptBtn.classList.add('bg-green-500');
                   copyLlmPromptBtn.classList.remove('bg-purple-600');
                   setTimeout(() => {
                       copyLlmPromptBtn.textContent = originalText;
                       copyLlmPromptBtn.classList.remove('bg-green-500');
                       copyLlmPromptBtn.classList.add('bg-purple-600');
                   }, 2000);
               }).catch(err => {
                   console.error('Failed to copy LLM prompt: ', err);
                   alert('Failed to copy prompt.');
               });
           });

            // Copy Decklist Button Functionality
            if (copyDecklistBtn && decklistTextarea) {
                copyDecklistBtn.addEventListener('click', () => {
                    const textToCopy = decklistTextarea.value;
                    if (navigator.clipboard && window.isSecureContext) { // Check for secure context
                        navigator.clipboard.writeText(textToCopy)
                            .then(() => {
                                const originalText = copyDecklistBtn.textContent;
                                copyDecklistBtn.textContent = 'Copied!';
                                copyDecklistBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                                copyDecklistBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                                setTimeout(() => {
                                    copyDecklistBtn.textContent = originalText;
                                    copyDecklistBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                                    copyDecklistBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
                                }, 2000);
                            })
                            .catch(err => {
                                console.error('Failed to copy decklist: ', err);
                                alert('Failed to copy decklist. See console for details.');
                            });
                    } else {
                        // Fallback for non-secure contexts or older browsers (less common for localhost/https)
                        try {
                            decklistTextarea.select(); // Select the text
                            document.execCommand('copy'); // Attempt to copy
                            decklistTextarea.blur(); // Deselect after copying

                            const originalText = copyDecklistBtn.textContent;
                            copyDecklistBtn.textContent = 'Copied! (fallback)';
                            copyDecklistBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                            copyDecklistBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                            setTimeout(() => {
                                copyDecklistBtn.textContent = originalText;
                                copyDecklistBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                                copyDecklistBtn.classList.add('bg-gray-600', 'hover:bg-gray-500');
                            }, 2000);
                        } catch (err) {
                            console.error('Fallback copy method failed: ', err);
                            alert('Failed to copy decklist using fallback method. Please copy manually.');
                        }
                    }
                });
            }


           // --- LLM PROMPT GENERATION ---
           function generateLlmPrompt() {
               if (currentDeck.length === 0) {
                   alert("Please build a deck first.");
                   return;
               }

               const totalCards = currentDeck.reduce((sum, item) => sum + item.count, 0);
               const colorDistribution = {};
               const cardTypes = {};
               const costCurve = {};

               currentDeck.forEach(({ count, card }) => {
                   // Color Distribution
                   (card.colors || [card.color]).forEach(color => {
                       if (color) colorDistribution[color] = (colorDistribution[color] || 0) + count;
                   });

                   // Card Types
                   const type = card.type || 'Unknown';
                   cardTypes[type] = (cardTypes[type] || 0) + count;

                   // Cost Curve
                   const cost = card.cost || 0;
                   costCurve[cost] = (costCurve[cost] || 0) + count;
               });

               const inkColors = Object.keys(colorDistribution).join(', ');
               const colorDistText = Object.entries(colorDistribution).map(([k, v]) => `${k.toLowerCase()}: ${v}`).join(', ');
               const cardTypesText = Object.entries(cardTypes).map(([k, v]) => `${k.toLowerCase()}: ${v}`).join(', ');
               const costCurveText = Object.entries(costCurve).sort((a, b) => a[0] - b[0]).map(([k, v]) => `${k}: ${v}`).join(', ');

               let decklistText = '';
               currentDeck.sort((a, b) => a.card.cost - b.card.cost || a.card.fullName.localeCompare(b.card.fullName)).forEach(({ count, card }) => {
                   const inkable = card.inkwell ? '(Inkable)' : '';
                   const stats = card.strength !== undefined ? `${card.strength}/${card.willpower} - ${card.lore}L` : '';
                   const cardText = (card.text || '').replace(/\n/g, '\n    ');
                   decklistText += `${count}x ${card.fullName} (${card.cost} ink, ${card.colors ? card.colors.join('/') : card.color}) - ${stats} ${inkable}\n`;
                   if (cardText) {
                       decklistText += `    Text: "${cardText}"\n\n`;
                   } else {
                       decklistText += `\n`;
                   }
               });


               const prompt = `You are an expert Disney Lorcana TCG coach focusing on optimizing gameplay and teaching strategic decision-making. I need a comprehensive strategy guide for playing my deck effectively.

DECK COMPOSITION:

Total cards: ${totalCards}

Ink colors: ${inkColors}

Color distribution: ${colorDistText}

Card types: ${cardTypesText}

Cost curve: ${costCurveText}

DECKLIST:

${decklistText.trim()}


FOCUS YOUR ANALYSIS ON:

1. DECK IDENTITY & CORE STRATEGY: What is my deck trying to accomplish? What's its primary win condition?

2. KEY SYNERGIES: Identify the 3-5 most important card combinations and explain how to set them up

3. MULLIGAN GUIDE: Which cards should I prioritize in my opening hand?

4. TURN-BY-TURN GAMEPLAY:

   - Early game (turns 1-2): What should be my priorities?

   - Mid game (turns 3-5): How should I develop my board?

   - Late game (turns 6+): How do I close out the game?

5. MATCHUP TACTICS: How should I adapt my strategy against aggressive, control, or midrange opponents?

6. COMMON PITFALLS: What mistakes should I avoid when playing this deck?

7. POWER PLAYS: What are the strongest sequences or plays this deck can make?

FORMAT YOUR RESPONSE as a structured, professional guide with clear headings. Include specific card references when explaining strategies.`;

               llmPromptOutput.value = prompt;
               llmPromptModal.classList.remove('opacity-0', 'pointer-events-none');
           }


            // --- INITIALIZATION ---
            const initializeApp = async () => {
                try {
                    initializeCharts();
                    renderInkTypes();
                    const response = await fetch(CARD_DATA_URL);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    allCards = (await response.json()).cards;
                    cardFuse = new Fuse(allCards, { keys: ['fullName', 'simpleName', 'name', 'title'], includeScore: true, threshold: 0.3 });
                    await loadAndRenderDecks();
                    resetForm();
                } catch (error) {
                    console.error("Failed to initialize app:", error);
                    loadingOverlay.innerHTML = `<p class="text-red-400">Failed to load card database. Please try refreshing.</p>`;
                } finally {
                    loadingOverlay.classList.add('opacity-0', 'pointer-events-none');
                }
            };

            initializeApp();
        });
    </script>

</body>

</html>
