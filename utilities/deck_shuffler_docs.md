# **Lorcana Draw & Deck Analyzer: Implementation Guide**

## **1\. Introduction**

This document provides a detailed technical breakdown for implementing the "Draw" tab functionality of the Lorcana Deck Analyzer. It assumes you are integrating these features into an existing application that already has access to:

1. **allCards.json:** The complete card database, as an array of card objects.  
2. **unified\_win\_probability\_utilities.js:** The utilities library, available as the global object UnifiedWinProbabiliyCalculation.  
3. **lorcana\_abilities\_redux.json:** The abilities configuration (loaded by the utility library).

This guide documents the logic from the lorcana\_analyzer.html file, breaking it down into reusable modules.

## **2\. Core Data Structures**

Understanding these data structures is essential, as they are the "API" that connects the different modules.

### **Card Object (from allCards.json)**

This is the raw card object from the database. The key fields used by this application are:

{  
  "id": 123,  
  "fullName": "Mickey Mouse \- Brave Little Tailor",  
  "name": "Mickey Mouse",  
  "simpleName": "mickey mouse brave little tailor",  
  "cost": 8,  
  "inkwell": true,  
  "color": "Amber", // Primary color, or dual-color string "Amber-Steel"  
  "colors": \["Amber", "Steel"\], // Only present on dual-color cards  
  "type": "Character", // "Action", "Item", "Location"  
  "images": {  
    "thumbnail": "https://.../thumb.webp",  
    "full": "https://.../full.webp"  
  }  
  // ... other fields like strength, willpower, fullTextSections  
}

### **Decklist Array**

This is the primary in-memory representation of the user's deck. It is a simple array containing the **full card object** for every card in the deck, expanded by quantity.

* **Type:** Array\<Card Object\>  
* **Example:** A 60-card deck is an array of 60 Card Objects. If the user has 4 copies of "Mickey Mouse", that object appears 4 times in the array.

### **DeckInfo Object**

This object is generated by the parsing module. It holds high-level statistical information about the *entire* deck.

{  
  "totalCards": 60,  
  "inkableCount": 42,  
  "colors": {  
    "Amber": 30,  
    "Steel": 30  
  },  
  "types": {  
    "Character": 40,  
    "Action": 16,  
    "Item": 4  
  },  
  "costs": {  
    "1": 8,  
    "2": 12,  
    "3": 10,  
    "5": 10,  
    "7": 6,  
    "8": 4  
  },  
  "byCopyCount": { // How many unique cards have X copies  
    "1": 0,  
    "2": 2, // e.g., 2 unique cards are 2-ofs  
    "3": 4, // e.g., 4 unique cards are 3-ofs  
    "4": 10 // e.g., 10 unique cards are 4-ofs  
  }  
}

### **ShuffleAnalysis Object**

This is the main result object generated by the analysis engine. It contains all data needed to render the UI for a single shuffle.

{  
  "hand": { /\* AnalysisGroup Object for cards 0-6 \*/ },  
  "earlyGame": { /\* AnalysisGroup Object for cards 0-14 \*/ },  
  "quality": { /\* ShuffleQuality Object \*/ }  
}

### **AnalysisGroup Object (Internal)**

A standardized object returned by analyzeCardGroup. It holds stats for a subset of the deck (e.g., hand or early game).

{  
  "cards": \[ /\* Array of Card Objects in this group \*/ \],  
  "count": 7,  
  "inkable": 4,  
  "avgCost": 3.8,  
  "costs": { "1-3": 2, "4-5": 3, "6+": 2 },  
  "types": { "Character": 5, "Action": 2 },  
  "colors": { "Amber": 3, "Steel": 4 },  
  "hasLowCost": true,  
  "hasHighCost": true  
}

## **3\. Module 1: Deck Parsing**

This module converts the user's text input into the Decklist Array and DeckInfo Object.

### **Logic Flow**

1. **Get Input:** Read the text from the \<textarea\>.  
2. **Sanitize:** Split the text by newlines (\\n) and filter out empty lines.  
3. **Regex Match:** For each line, apply a regex to extract quantity and card name.  
   * **Regex:** ^(\\d+)x?\\s+(.\*)$/i  
   * match\[1\] will be the quantity (e.g., "4").  
   * match\[2\] will be the card name (e.g., "Mickey Mouse \- Brave Little Tailor").  
4. **Find Card:** Use the extracted card name to find the corresponding Card Object in the allCardsData array.  
   * This lookup should be robust. The reference implementation uses a findCard(name) function that checks in this order:  
     1. Exact fullName match (case-insensitive).  
     2. Match against a "simple name" (lowercase, punctuation stripped) for robustness.  
5. **Build Deck:**  
   * If a card is not found, abort and return an error.  
   * If found, add the Card Object to the Decklist Array quantity times.  
6. **Build Stats:** While building the deck, simultaneously populate the DeckInfo Object by incrementing counts for totalCards, inkableCount, colors, types, and costs.  
7. **Calculate byCopyCount:** After the deck is built, create a temporary map of { card.fullName: count } for all cards. Iterate this map to populate the deckInfo.byCopyCount object.  
8. **Return:** Return both the Decklist Array and DeckInfo Object.

## **4\. Module 2: Shuffle Simulation**

This module handles the core "Shuffle Deck" logic and manages the state of recent shuffles.

### **State Management**

You will need a state variable, e.g., recentShuffles \= \[\], to hold the history of shuffles. Each item in this array should be an object:

{  
  "id": 1, // Shuffle number  
  "hand": \[ /\* Array of 7 Card Objects \*/ \],  
  "deck": \[ /\* Array of 60 Card Objects (shuffled) \*/ \],  
  "analysis": { /\* The ShuffleAnalysis Object \*/ }  
}

### **Logic Flow (handleShuffleDeck)**

1. **Get Deck:** Make a *copy* of the main Decklist Array. This is crucial to avoid mutating the original parsed deck.  
   * const deckToShuffle \= \[...decklist\];  
2. **Shuffle:** Pass the copy to a shuffling function (e.g., Fisher-Yates).  
   * **Fisher-Yates Algorithm:**  
     function fisherYatesShuffle(array) {  
       let currentIndex \= array.length, randomIndex;  
       while (currentIndex \!= 0\) {  
         randomIndex \= Math.floor(Math.random() \* currentIndex);  
         currentIndex--;  
         \[array\[currentIndex\], array\[randomIndex\]\] \= \[  
           array\[randomIndex\], array\[currentIndex\]  
         \];  
       }  
       return array;  
     }

3. **Analyze:** Pass the newly shuffled deck to the analysis engine (see Module 3).  
   * const analysis \= analyzeShuffle(shuffledDeck);  
4. **Create Entry:** Create a new "Shuffle Entry" object (as defined above) containing the shuffle ID, the 7-card hand (shuffledDeck.slice(0, 7)), the full shuffledDeck, and the analysis object.  
5. **Update State:** Add this new entry to the *beginning* of the recentShuffles array.  
   * recentShuffles.unshift(shuffleEntry);  
   * (Optional) Limit the history size: if (recentShuffles.length \> 10\) recentShuffles.pop();  
6. **Render:** Trigger a UI update using the data from this new shuffleEntry.

## **5\. Module 3: Core Analysis Engine**

This is the set of functions that generates the ShuffleAnalysis object from a shuffled deck.

### **analyzeShuffle(shuffledDeck)**

This is the main orchestration function.

1. Get the hand (first 7 cards) and earlyGame (first 15 cards).  
2. Call analyzeCardGroup for each:  
   * const handStats \= analyzeCardGroup(hand);  
   * const earlyGameStats \= analyzeCardGroup(earlyGame);  
3. Call calculateHandQuality to get the 0-10 score:  
   * handStats.quality \= calculateHandQuality(handStats);  
4. Call analyzeDeckRandomness to get shuffle quality stats:  
   * const qualityStats \= analyzeDeckRandomness(shuffledDeck);  
5. Return the final ShuffleAnalysis object:  
   return {  
     hand: handStats,  
     earlyGame: earlyGameStats,  
     quality: qualityStats  
   };

### **analyzeCardGroup(cards)**

This utility function analyzes any array of card objects.

1. Initialize an AnalysisGroup object (see Data Structures).  
2. Loop through each card in the cards array.  
3. Increment group.inkable if card.inkwell is true.  
4. Add card.cost to a totalCost accumulator.  
5. Increment group.costs\["1-3"\], group.costs\["4-5"\], or group.costs\["6+"\] based on card.cost.  
6. Set group.hasLowCost \= true if card.cost \<= 2\.  
7. Set group.hasHighCost \= true if card.cost \>= 5\.  
8. Increment group.types\[card.type\].  
9. Increment group.colors\[card.color\] (handle primary and secondary colors if card.colors exists).  
10. After the loop, calculate group.avgCost \= totalCost / group.count.  
11. Return the group object.

### **calculateHandQuality(handStats)**

This function implements the 0-10 "Hand Quality" heuristic.

1. Initialize score \= 0\.  
2. **Inkable Score (Max 4 pts):**  
   * If handStats.inkable is 3 or 4, score \+= 4\.  
   * If handStats.inkable is 2 or 5, score \+= 3\.  
   * If handStats.inkable is 1 or 6, score \+= 1\.  
3. **Early Curve Score (Max 6 pts):**  
   * Let earlyPlays \= handStats.costs\["1-3"\].  
   * If earlyPlays \>= 3, score \+= 6\.  
   * If earlyPlays \=== 2, score \+= 4\.  
   * If earlyPlays \=== 1, score \+= 2\.  
4. **Determine Rating:**  
   * if (score \>= 9\) return { score, rating: "Excellent" };  
   * if (score \>= 7\) return { score, rating: "Good" };  
   * if (score \>= 5\) return { score, rating: "Average" };  
   * if (score \>= 3\) return { score, rating: "Poor" };  
   * return { score, rating: "Bad" };

### **analyzeDeckRandomness(deck)**

This function analyzes the full shuffled deck for "un-random" patterns.

1. **Analyze Consecutive Cards:**  
   * Initialize quality.consecutive \= { 2: 0, 3: 0, 4: 0 }.  
   * Loop through the deck from i \= 1\.  
   * Keep a consecutiveCount tracking runs of identical card.id.  
   * When a run breaks (or at the end of the loop), increment the appropriate key in quality.consecutive.  
2. **Analyze Clustering:**  
   * This requires a helper function: findClusters(deck, getProperty).  
   * findClusters loops through the deck, tracking currentCluster length for a given property (e.g., c \=\> c.color). It returns { max: maxClusterLength, count: totalClusters }.  
   * Call this helper for each property:  
     quality.clusters \= {  
       color: findClusters(deck, c \=\> c.color),  
       cost: findClusters(deck, c \=\> c.cost),  
       type: findClusters(deck, c \=\> c.type),  
       inkless: findClusters(deck, c \=\> \!c.inkwell),  
     };

3. **Generate Issues & Rating:**  
   * Create an issues \= \[\] array.  
   * Push warning strings based on thresholds (e.g., if (quality.consecutive\[3\] \> 0\) issues.push("â€¢ 3 same cards in a row.")).  
   * If issues.length \=== 0, set rating \= "Excellent".  
   * Otherwise, set rating to "Good" or "Poor" based on issues.length.  
   * Return the quality object.

## **6\. Module 4: Probability Calculations**

This module implements the math for both probability tables. It is based entirely on the Hypergeometric Distribution.

### **Core Math Functions**

You must implement these two functions. A cache for combinations is highly recommended for performance.

let combinationsCache \= {};  
function combinations(n, k) {  
  if (k \< 0 || k \> n) return 0;  
  if (k \=== 0 || k \=== n) return 1;  
  if (k \> n / 2\) k \= n \- k;  
    
  const cacheKey \= \`${n},${k}\`;  
  if (combinationsCache\[cacheKey\]) return combinationsCache\[cacheKey\];

  let res \= 1;  
  for (let i \= 1; i \<= k; i++) {  
    res \= res \* (n \- i \+ 1\) / i;  
  }  
    
  combinationsCache\[cacheKey\] \= res;  
  return res;  
}

/\*\*  
 \* @param {number} N Total population size (e.g., 60 cards in deck)  
 \* @param {number} k Number of successes in population (e.g., 4 copies of a card)  
 \* @param {number} n Sample size (e.g., 7 cards in hand)  
 \* @param {number} x Number of successes in sample (e.g., 1 copy in hand)  
 \* @returns {number} The probability of exactly x successes  
 \*/  
function hypergeometricProbability(N, k, n, x) {  
  const C\_kx \= combinations(k, x);  
  const C\_Nknx \= combinations(N \- k, n \- x);  
  const C\_Nn \= combinations(N, n);  
  if (C\_Nn \=== 0\) return 0; // Avoid division by zero  
  return (C\_kx \* C\_Nknx) / C\_Nn;  
}

### **Feature 1: "Hand Draw Probabilities" Table**

This table is populated once, when the deck is loaded.

1. Set N \= deckInfo.totalCards and n \= 7\.  
2. Define the categories to display (Colors, Inkable/Inkless, Types, By Copy Count) using the DeckInfo object.  
3. For each category (e.g., "Amber"):  
   * Set k \= deckInfo.colors\['Amber'\].  
   * Create a probability array p \= \[0, 0, 0, 0, 0\] (for 0, 1, 2, 3, 4+ cards).  
   * Loop from x \= 0 to Math.min(n, k):  
     * const prob \= hypergeometricProbability(N, k, n, x);  
     * If x \<= 3, p\[x\] \= prob.  
     * If x \>= 4, p\[4\] \+= prob.  
   * Render a table row displaying the percentages (prob \* 100).

### **Feature 2: "Hypergeometric Calculator"**

This feature re-runs the calculation on every user input change.

1. Add event listeners to the input fields (Deck, Copies, Hand, Desired).  
2. On input change:  
   * Read the integer values: N, k, n, x.  
   * Calculate "At Least X" (\>=):  
     * let p\_gte \= 0;  
     * Loop from i \= x to Math.min(n, k):  
     * p\_gte \+= hypergeometricProbability(N, k, n, i);  
   * Calculate "Exactly X" (=):  
     * let p\_eq \= hypergeometricProbability(N, k, n, x);  
   * Calculate "Less Than X" (\<):  
     * let p\_lt \= 1 \- p\_gte;  
   * Update the UI with the formatted percentages.

## **7\. Note on UnifiedWinProbabiliyCalculation**

The lorcana\_analyzer.html file **loads** this library but **does not use it** for any of the "Draw" tab features. The "Hand Quality" score is a simple heuristic (see Module 3).

### **Optional Enhancement**

To leverage this library, you could replace the calculateHandQuality heuristic with a more powerful, data-driven calculation:

1. Inside calculateHandQuality, loop through the handStats.cards array.  
2. For each card, call UnifiedWinProbabiliyCalculation.calculateCardMetrics(card).  
3. Sum the rds, lvi, and bcr scores for all cards in the hand.  
4. Normalize these sums into a 0-10 score.

This would provide a "Hand Quality" score based on the *actual power* of the cards (Resource Dominance, Lore Velocity, Board Control) rather than just their inkability and cost.