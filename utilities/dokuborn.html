<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dokuborn - Lorcana Puzzle</title>
    <style>
        :root {
            --wood-dark: #3a2a1a;
            --wood-medium: #6f4f28;
            --wood-light: #8b6e4b;
            --parchment: #f5eeda;
            --text-gold: #e6c88a;
            --border-gold: #b48c4a;
            --grid-line: #a58c6d;
            --correct-bg: rgba(56, 118, 73, 0.75);
            --incorrect-bg: rgba(186, 30, 30, 0.75);
            --font-main: 'Georgia', 'Times New Roman', serif;
            --star-color: #ffd700;
        }

        body {
            background-color: var(--wood-dark);
            color: var(--text-gold);
            font-family: var(--font-main);
            margin: 0;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            width: 100%;
            max-width: 600px;
            background-color: var(--wood-medium);
            border: 8px solid var(--wood-light);
            box-shadow: 0 0 20px rgba(0,0,0,0.7), inset 0 0 15px rgba(0,0,0,0.5);
            padding: clamp(1rem, 5vw, 2rem);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .credits {
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            margin-bottom: 1rem;
            color: var(--text-gold);
        }
        .credits p {
            margin: 0;
        }
        .credits a {
            color: var(--text-gold);
            text-decoration: underline;
        }

        header {
            text-align: center;
            width: 100%;
        }

        footer {

            background: var(--wood-medium);
            padding: 1rem;
            font-size: 0.9rem;
            line-height: 1.4;
            word-wrap: break-word; /* to handle long text */
        }

        h1 {
            font-size: clamp(2.5rem, 8vw, 4rem);
            color: var(--text-gold);
            margin: 0;
            text-shadow: 2px 2px 4px var(--wood-dark);
            border-bottom: 2px solid var(--border-gold);
            border-top: 2px solid var(--border-gold);
            padding: 0.5rem 0;
            background-color: rgba(0,0,0,0.2);
        }

        /* Mode Selection Styles */
        .mode-selector {
            display: flex;
            justify-content: center;
            margin: 1rem 0;
            gap: 1rem;
        }

        .mode-button {
            background-color: var(--wood-light);
            color: var(--parchment);
            border: 2px solid var(--border-gold);
            padding: 8px 16px;
            font-family: var(--font-main);
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s ease;
        }

        .mode-button.active {
            background-color: var(--border-gold);
            color: var(--wood-dark);
            font-weight: bold;
        }

        .mode-button:hover:not(.active) {
            background-color: var(--border-gold);
            transform: translateY(-1px);
        }

        .mode-indicator {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 5px;
        }

        .daily-mode-indicator {
            background-color: rgba(255, 215, 0, 0.2);
            color: var(--star-color);
            border: 2px solid var(--star-color);
        }

        .explore-mode-indicator {
            background-color: rgba(38, 138, 29, 0.185);
            color:  rgb(100, 173, 93);
            border: 2px solid var(--correct-bg);
        }

        .puzzle-meta {
            text-align: center;
            margin: 0.5rem 0;
        }

        #puzzle-code-display {
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        #copy-code-button {
            background: none;
            border: 1px solid var(--text-gold);
            color: var(--text-gold);
            cursor: pointer;
            margin-left: 8px;
            padding: 3px 6px;
            border-radius: 3px;
        }


        .puzzle-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px;
            margin: 1rem auto;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-gold);
            border-top: 1px solid var(--border-gold);
        }

        #puzzle-level-display {
            font-size: 1.5rem;
            color: var(--star-color);
            letter-spacing: 2px;
        }


        .puzzle-grid-area {
            display: grid;
            grid-template-columns: auto 1fr;
            grid-template-rows: auto 1fr;
            gap: 10px;
            width: 100%;
        }

        .grid-labels-top {
            grid-column: 2 / 3;
            display: grid;
            text-align: center;
        }

        .grid-labels-left {
            grid-row: 2 / 3;
            display: grid;
            align-items: center;
            justify-items: center;
        }

        .grid-labels-left .label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        .label {
            padding: 5px;
            font-weight: bold;
            font-size: clamp(0.75rem, 3vw, 1rem);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-height: 40px;
        }
        
        .puzzle-grid {
            grid-column: 2;
            grid-row: 2;
            display: grid;
            gap: 5px;
            background-color: var(--grid-line);
            border: 3px solid var(--grid-line);
            padding: 5px;
            aspect-ratio: 367 / 512;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .grid-cell {
            background-color: var(--parchment);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            cursor: pointer;
            border-radius: 5px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .grid-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--text-gold);
        }

        .grid-cell .feedback-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; transition: opacity 0.3s ease;
        }

        .grid-cell.correct .feedback-overlay {
            background-color: var(--correct-bg);
            opacity: 1;
        }

        .grid-cell.incorrect .feedback-overlay {
            background-color: var(--incorrect-bg);
            opacity: 1;
        }

        .controls {
            margin-top: 1.5rem;
            display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem;
        }

        .controls button {
            background-color: var(--wood-light); color: var(--parchment);
            border: 2px solid var(--border-gold); padding: 10px 20px;
            font-family: var(--font-main); font-size: 1rem; cursor: pointer;
            border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            transition: all 0.2s ease;
        }

        .controls button:hover:not(:disabled) {
            background-color: var(--border-gold); transform: translateY(-2px);
        }
        
        .controls button:disabled {
            background-color: #555; color: #999; cursor: not-allowed; border-color: #444;
        }

        .instructions {
            margin-top: 0.5rem;
            line-height: 1.2;
            text-align: center; margin-top: 1rem;
            font-style: italic; font-size: 0.5rem;
        }

        /* Modal Styles */
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.7);
            align-items: center; justify-content: center;
        }
        
        .modal-content {
            background-color: var(--parchment); color: var(--wood-dark);
            margin: auto; padding: 20px; border: 5px solid var(--border-gold);
            border-radius: 10px; width: 90%; max-width: 500px;
            max-height: 90vh; display: flex; flex-direction: column;
        }
        
        #confirmation-modal .modal-content, #import-modal .modal-content, #difficulty-modal .modal-content, #grid-size-modal .modal-content {
            text-align: center;
        }

        #import-input {
             width: calc(100% - 20px); padding: 10px; margin-bottom: 1rem;
        }

        #difficulty-buttons, #grid-size-buttons {
            display: flex; flex-direction: column; gap: 1rem;
        }

        #confirmation-buttons, #import-buttons, #difficulty-buttons button, #grid-size-buttons button {
            display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem;
        }

        #confirmation-buttons button, #import-buttons button, #difficulty-buttons button, #grid-size-buttons button {
             background-color: var(--wood-light); color: var(--parchment);
            border: 2px solid var(--border-gold); padding: 10px 20px;
            font-family: var(--font-main); font-size: 1rem; cursor: pointer;
            border-radius: 5px;
        }

        #difficulty-buttons button, #grid-size-buttons button {
            margin-top: 0; font-size: 1.2rem; width: 100%;
        }
        
        #difficulty-buttons button .stars { color: var(--star-color); }

        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid var(--border-gold); padding-bottom: 10px; margin-bottom: 15px;
        }
        
        #search-input {
            width: 100%; padding: 10px; font-size: 1rem;
            border: 2px solid var(--wood-medium); border-radius: 5px; background-color: #fff;
        }
        
        #search-results {
            list-style: none; padding: 0; margin: 0; overflow-y: auto;
        }

        #search-results li {
            padding: 10px; cursor: pointer; border-bottom: 1px solid var(--grid-line);
            display: flex; align-items: center; gap: 10px;
        }

        #search-results li:hover { background-color: #e8dcc4; }
        #search-results li img { width: 40px; border-radius: 3px; }

        .loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: var(--text-gold);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 2000; font-size: 1.5rem;
        }
        .loader {
            border: 8px solid #f3f3f3; border-radius: 50%; border-top: 8px solid var(--wood-medium);
            width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 1rem;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Tutorial Styles */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            background-color: rgba(0,0,0,0.7);
            display: none;
        }

        .tutorial-highlight {
            position: relative;
            z-index: 10001;
            box-shadow: 0 0 15px 5px var(--star-color);
            border-radius: 5px;
        }

        #tutorial-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--parchment);
            color: var(--wood-dark);
            padding: 20px;
            border: 3px solid var(--border-gold);
            border-radius: 10px;
            width: 90%;
            max-width: 350px;
            z-index: 10002;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: none; /* Initially hidden */
        }


        #tutorial-box p {
            margin: 0 0 15px 0;
            line-height: 1.5;
        }

        #tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

         #tutorial-nav button {
            background-color: var(--wood-light); color: var(--parchment);
            border: 2px solid var(--border-gold); padding: 8px 15px;
            font-family: var(--font-main); font-size: 0.9rem; cursor: pointer;
            border-radius: 5px;
        }

        /* ===== MOBILE OPTIMIZATIONS ===== */

        /* Mobile-first responsive breakpoints */
        @media (max-width: 768px) {
            /* Container and Layout Optimizations */
            body {
                padding: 0.5rem;
            }

            .game-container {
                max-width: 100%;
                padding: 0.75rem;
                border-width: 4px;
            }

            /* Grid Optimizations for Mobile */
            .puzzle-grid-area {
                gap: 5px;
            }

            .puzzle-grid {
                aspect-ratio: 367 / 512; /* Keep card aspect ratio */
                gap: 3px;
                padding: 3px;
                border-width: 2px;
            }

            .grid-cell {
                border-radius: 3px;
            }

            /* Label Optimizations */
            .label {
                padding: 2px;
                font-size: clamp(0.65rem, 2.5vw, 0.85rem);
                min-height: 32px;
            }

            /* Typography Reductions */
            h1 {
                font-size: clamp(1.8rem, 6vw, 2.2rem);
                padding: 0.3rem 0;
            }

            .mode-button {
                padding: 6px 12px;
                font-size: 0.8rem;
            }

            .mode-indicator {
                font-size: 1rem;
                padding: 0.3rem;
                margin: 0.3rem 0;
            }

            .puzzle-info {
                font-size: clamp(0.8rem, 2vw, 0.9rem);
                padding: 0.3rem;
                margin: 0.75rem auto;
            }

            #puzzle-level-display {
                font-size: 1.2rem;
                letter-spacing: 1px;
            }

            .instructions {
                font-size: 0.7rem;
                margin-top: 0.5rem;
                line-height: 1.2;
            }

            /* Make instructions collapsible on mobile */
            .instructions h3 {
                margin: 0 0 0.25rem 0;
                font-size: 0.8rem;
                cursor: pointer;
            }

            .instructions p {
                margin: 0.25rem 0;
                display: inline;
            }

            .instructions p:not(:last-child)::after {
                content: " â€¢ ";
                color: var(--text-gold);
            }

            .controls {
                margin-top: 1rem;
                gap: 0.5rem;
            }

            .controls button {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .credits {
                font-size: 0.7rem;
                margin-bottom: 0.5rem;
            }

            footer {
                padding: 0.75rem;
                font-size: 0.8rem;
                line-height: 1.3;
            }

            /* Puzzle meta optimizations */
            #puzzle-code-display {
                font-size: 0.8rem;
                padding: 3px 6px;
            }

            #copy-code-button {
                padding: 2px 4px;
                margin-left: 4px;
                font-size: 0.75rem;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .game-container {
                padding: 0.5rem;
                border-width: 3px;
            }

            .puzzle-grid {
                aspect-ratio: 367 / 512; /* Keep card aspect ratio */
                gap: 2px;
                padding: 2px;
            }

            .puzzle-grid-area {
                gap: 3px;
            }

            .label {
                padding: 1px;
                font-size: clamp(0.6rem, 2vw, 0.75rem);
                min-height: 28px;
            }

            h1 {
                font-size: clamp(1.5rem, 5vw, 1.8rem);
                padding: 0.2rem 0;
            }

            .mode-button {
                padding: 5px 10px;
                font-size: 0.75rem;
            }

            .mode-indicator {
                font-size: 0.9rem;
                padding: 0.25rem;
            }

            .controls button {
                padding: 6px 10px;
                font-size: 0.8rem;
            }

            .instructions {
                font-size: 0.65rem;
                margin-top: 0.4rem;
                line-height: 1.1;
            }

            /* Make instructions collapsible on mobile */
            .instructions h3 {
                margin: 0 0 0.2rem 0;
                font-size: 0.75rem;
                cursor: pointer;
            }

            .instructions p {
                margin: 0.2rem 0;
                display: inline;
            }

            .instructions p:not(:last-child)::after {
                content: " â€¢ ";
                color: var(--text-gold);
            }

            .puzzle-info {
                font-size: clamp(0.75rem, 1.8vw, 0.85rem);
                margin: 0.5rem auto;
            }

            #puzzle-level-display {
                font-size: 1rem;
                letter-spacing: 0.5px;
            }
        }

        /* Touch-friendly enhancements */
        @media (hover: none) and (pointer: coarse) {
            .grid-cell {
                min-height: 48px; /* Minimum touch target */
                min-width: 48px;
            }

            .controls button {
                min-height: 44px; /* Touch target guidelines */
                min-width: 60px;
            }

            .mode-button {
                min-height: 40px;
                min-width: 80px;
            }

            /* Reduce hover effects on touch devices */
            .grid-cell:hover {
                transform: scale(1.02); /* Subtle scale for touch */
            }

            .controls button:hover:not(:disabled) {
                transform: translateY(-1px); /* Reduced hover effect */
            }

            .mode-button:hover:not(.active) {
                transform: translateY(-0.5px); /* Minimal hover effect */
            }
        }

    </style>
</head>
<body>

    <div id="loader" class="loader-overlay"><div class="loader"></div><p>Loading Lorcana Database...</p></div>
    <div id="search-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h2>Find a Card</h2></div>
            <input type="text" id="search-input" placeholder="Type a card name...">
            <ul id="search-results"></ul>
        </div>
    </div>
    <div id="confirmation-modal" class="modal">
        <div class="modal-content">
            <p id="confirmation-message"></p>
            <div id="confirmation-buttons">
                <button id="confirm-yes">Yes</button><button id="confirm-no">No</button>
            </div>
        </div>
    </div>
    <div id="import-modal" class="modal">
        <div class="modal-content">
            <h3>Import Puzzle Code</h3>
            <input type="text" id="import-input" placeholder="Paste puzzle code here">
            <div id="import-buttons">
                <button id="import-submit">Load</button><button id="import-cancel">Cancel</button>
            </div>
        </div>
    </div>
    <div id="difficulty-modal" class="modal">
        <div class="modal-content">
            <h3>Select Difficulty</h3>
            <div id="difficulty-buttons"></div>
        </div>
    </div>
    <div id="grid-size-modal" class="modal">
        <div class="modal-content">
            <h3>Select Game Mode</h3>
            <div id="grid-size-buttons"></div>
        </div>
    </div>
    <div id="tutorial-overlay"></div>
    <div id="tutorial-box">
        <p id="tutorial-text"></p>
        <div id="tutorial-nav">
            <button id="tutorial-skip">Skip</button>
            <div>
                <button id="tutorial-prev" style="margin-right: 10px;">Prev</button>
                <button id="tutorial-next">Next</button>
            </div>
        </div>
    </div>


    <main class="game-container">
        <header>
            <h1>Dokuborn
            <small class="credits">
                <p>Based on game created by <a href="https://linktr.ee/the_artopath" target="_blank" rel="noopener noreferrer">The Artopath</a></p>
            </small>
            </h1>

            <div class="mode-selector">
                <button id="daily-mode-btn" class="mode-button active">DAILY PUZZLE</button>
                <button id="explore-mode-btn" class="mode-button">EXPLORE MODE</button>
            </div>

            <div id="mode-indicator" class="mode-indicator daily-mode-indicator">
                DAILY PUZZLE MODE<br>
                <small>One 3x3 puzzle per day â€¢ Check your answers and share results!</small>
            </div>
        </header>

        <div class="instructions">
            <h3>Instructions:</h3>
            <p>Find the card that fits both requirements!</p>
            <p>Multiple answers possible<p>
            <p>No duplicate card names</p>
        </div>

        <div class="controls">
            <button id="new-puzzle-button">New Puzzle</button>
            <button id="import-puzzle-button">Import Puzzle</button>
            <button id="check-button">Check Answers</button>
            <button id="copy-button">Copy Results</button>
            <button id="solve-button">Solve Puzzle</button>
            <button id="help-button">Help</button>
        </div>

        <div class="puzzle-info">
            <span id="puzzle-number-display">Puzzle: 1</span>
            <span id="puzzle-level-display"></span>
        </div>

        <div class="puzzle-grid-area">
            <div class="grid-labels-top"></div>
            <div class="grid-labels-left"></div>
            <div class="puzzle-grid"></div>
        </div>

        <div class="puzzle-meta">
            <span id="puzzle-code-display"></span>
            <button id="copy-code-button">Copy</button>
        </div>

        <footer>
            <small>This project is a non-commercial, fan-made game that is not affiliated with, endorsed by, or authorized by Disney, Ravensburger, or any official Disney Lorcana entities. All characters, images, and intellectual property rights are the property of their respective owners. This project is created solely for entertainment purposes and for fans of the Disney Lorcana game. No copyright infringement is intended. </small>
        </footer>
    </main>
    
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // UI Elements
            const UIElements = {
                grid: document.querySelector('.puzzle-grid'),
                gridLabelsTop: document.querySelector('.grid-labels-top'),
                gridLabelsLeft: document.querySelector('.grid-labels-left'),
                searchModal: document.getElementById('search-modal'),
                searchInput: document.getElementById('search-input'),
                searchResults: document.getElementById('search-results'),
                checkButton: document.getElementById('check-button'),
                copyButton: document.getElementById('copy-button'),
                solveButton: document.getElementById('solve-button'),
                newPuzzleButton: document.getElementById('new-puzzle-button'),
                importPuzzleButton: document.getElementById('import-puzzle-button'),
                copyCodeButton: document.getElementById('copy-code-button'),
                puzzleCodeDisplay: document.getElementById('puzzle-code-display'),
                puzzleLevelDisplay: document.getElementById('puzzle-level-display'),
                loader: document.getElementById('loader'),
                helpButton: document.getElementById('help-button'),
            };

            // Game State
            let allCards = [];
            let fuse;
            let activeCell = null;
            let gridSize = 3;
            let gridState = [];
            let currentConditions = { rows: [], cols: [] };
            let puzzleCount = 1;
            let allConditions = [];
            let currentMode = 'daily'; // 'daily' or 'explore'
            let dailyPuzzleDate = null;

            // --- URL Parameter Parsing ---
            function parseUrlParameters() {
                const urlParams = new URLSearchParams(window.location.search);
                const hashParams = new URLSearchParams(window.location.hash.substring(1));

                // Check for 'v' parameter first (e.g., ?v=3:YzAscjEscjUsczMsbzEw)
                let puzzleCode = urlParams.get('v') || hashParams.get('v');

                // If no 'v' parameter, check for direct puzzle code (e.g., #3:YzAscjEscjUsczMsbzEw)
                if (!puzzleCode) {
                    puzzleCode = urlParams.get('puzzle') || hashParams.get('puzzle');
                }

                // If still no code, check if the entire hash/query is a puzzle code (e.g., #3:YzAscjEscjUsczMsbzEw)
                if (!puzzleCode) {
                    const fullHash = window.location.hash.substring(1);
                    const fullQuery = window.location.search.substring(1);

                    // Check if it looks like a puzzle code (format: number:base64string)
                    if (/^\d+:[A-Za-z0-9+/=]+$/.test(fullHash)) {
                        puzzleCode = fullHash;
                    } else if (/^\d+:[A-Za-z0-9+/=]+$/.test(fullQuery)) {
                        puzzleCode = fullQuery;
                    }
                }

                return puzzleCode;
            }

            // --- Condition Definitions ---
            function setupConditions() {
                const colors = [ { name: 'Amber', emoji: 'ðŸŸ¡' }, { name: 'Amethyst', emoji: 'ðŸŸ£' }, { name: 'Emerald', emoji: 'ðŸŸ¢' }, { name: 'Ruby', emoji: 'ðŸ”´' }, { name: 'Sapphire', emoji: 'ðŸ”µ' }, { name: 'Steel', emoji: 'âš«' } ];
                colors.forEach((c, i) => allConditions.push({ id: `c${i}`, display: `${c.emoji} ${c.name}`, filter: card => card.color && card.color.includes(c.name) }));
                for (let i = 0; i <= 10; i++) allConditions.push({ id: `o${i}`, display: `Cost ${i}`, filter: card => card.cost === i });
                allConditions.push({ id: 'p0', display: 'Uninkable', filter: card => !card.inkwell });
                allConditions.push({ id: 'p1', display: 'Inkable', filter: card => card.inkwell });
                const rarities = ['Common', 'Uncommon', 'Rare', 'Super Rare', 'Legendary', 'Enchanted'];
                rarities.forEach((r, i) => allConditions.push({ id: `r${i}`, display: r, filter: card => card.rarity === r }));
                const types = ['Action', 'Character', 'Item', 'Location'];
                types.forEach((t, i) => allConditions.push({ id: `t${i}`, display: t, filter: card => card.type === t }));
                const subtypes = ['Song', 'Hero', 'Villain', 'Floodborn', 'Princess', 'Queen', 'Ally'];
                subtypes.forEach((s, i) => allConditions.push({ id: `s${i}`, display: s, filter: c => c.subtypes?.includes(s) }));
                const keywords = ['Bodyguard', 'Challenger', 'Evasive', 'Reckless', 'Resist', 'Rush', 'Shift', 'Singer', 'Support', 'Ward'];
                keywords.forEach((k, i) => allConditions.push({ id: `k${i}`, display: k, filter: c => c.keywordAbilities?.includes(k) }));
            }

            async function initializeGame() {
                try {
                    UIElements.loader.style.display = 'flex';
                    const response = await fetch('https://cdn.jsdelivr.net/gh/heavenideas/similcana@main/database/allCards.json');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    
                    allCards = data.cards.filter(card => card.setCode && !card.setCode.startsWith('Q'));

                    fuse = new Fuse(allCards, { includeScore: true, keys: ['fullName'], threshold: 0.4 });
                    setupConditions();
                    setupModals();
                    setupTutorial();

                    // Check for URL parameters and auto-load puzzle if present
                    const puzzleCode = parseUrlParameters();
                    if (puzzleCode) {
                        UIElements.loader.innerHTML = `<div class="loader"></div><p>Loading puzzle from URL...</p>`;
                        try {
                            loadPuzzleFromCode(puzzleCode);
                            // Update puzzle count for URL-loaded puzzles
                            document.getElementById('puzzle-number-display').textContent = 'URL Puzzle';
                            // Switch to explore mode when loading from URL
                            switchToExploreMode();
                        } catch (error) {
                            console.error("Failed to load puzzle from URL:", error);
                            showCustomAlert("Invalid puzzle code in URL. Loading daily puzzle instead.");
                            switchToDailyMode();
                        }
                    } else {
                        // Default to daily mode
                        switchToDailyMode();
                    }
                    
                    if (!localStorage.getItem('dokubornTutorialSeen')) {
                        startTutorial();
                    }
                } catch (error) {
                    UIElements.loader.innerHTML = `<p>Failed to load card database. Please try again later.</p>`;
                    console.error("Error loading card data:", error);
                } finally {
                    UIElements.loader.style.display = 'none';
                }
            }

            function setupModals() {
                const difficultyContainer = document.getElementById('difficulty-buttons');
                difficultyContainer.innerHTML = '';
                for (let i = 1; i <= 3; i++) {
                    const button = document.createElement('button');
                    button.dataset.level = i;
                    button.innerHTML = `<span class="stars">${'â˜…'.repeat(i)}${'â˜†'.repeat(3 - i)}</span>`;
                    button.addEventListener('click', () => {
                        document.getElementById('difficulty-modal').style.display = 'none';
                        generateNewPuzzle(gridSize, i);
                    });
                    difficultyContainer.appendChild(button);
                }

                const gridSizeContainer = document.getElementById('grid-size-buttons');
                gridSizeContainer.innerHTML = '';
                [{size: 2, text: '2x2 (Easy)'}, {size: 3, text: '3x3 (Normal)'}, {size: 4, text: '4x4 (Insane)'}].forEach(mode => {
                    const button = document.createElement('button');
                    button.textContent = mode.text;
                    button.addEventListener('click', () => {
                        gridSize = mode.size;
                        document.getElementById('grid-size-modal').style.display = 'none';
                        document.getElementById('difficulty-modal').style.display = 'flex';
                    });
                    gridSizeContainer.appendChild(button);
                });
            }

            function updateGridUI() {
                UIElements.grid.innerHTML = '';
                UIElements.gridLabelsTop.innerHTML = '';
                UIElements.gridLabelsLeft.innerHTML = '';
                UIElements.grid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                UIElements.grid.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
                UIElements.gridLabelsTop.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                UIElements.gridLabelsLeft.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
                for(let i=0; i<gridSize; i++) {
                    UIElements.gridLabelsTop.appendChild(document.createElement('div')).classList.add('label');
                    UIElements.gridLabelsLeft.appendChild(document.createElement('div')).classList.add('label');
                }
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.index = i;
                    cell.appendChild(document.createElement('div')).classList.add('feedback-overlay');
                    cell.addEventListener('click', () => { activeCell = cell; openSearchModal(); });
                    UIElements.grid.appendChild(cell);
                }
            }
            
            function updateGridLabels() {
                for(let i=0; i<gridSize; i++) {
                    UIElements.gridLabelsTop.children[i].innerHTML = currentConditions.cols[i].display;
                    UIElements.gridLabelsLeft.children[i].innerHTML = currentConditions.rows[i].display;
                }
            }

            function calculatePuzzleDifficulty(rows, cols, size) {
                let difficultyScore = 0;
                for (let i = 0; i < size * size; i++) {
                    const pool = allCards.filter(card => rows[Math.floor(i / size)].filter(card) && cols[i % size].filter(card)).length;
                    difficultyScore += 1 / (pool || 0.1);
                }
                const normalizedScore = difficultyScore / (size * size);
                if (normalizedScore < 0.1) return 1; if (normalizedScore < 0.45) return 2;
                return 3;
            }

            function displayLevel(level) {
                UIElements.puzzleLevelDisplay.textContent = 'â˜…'.repeat(level) + 'â˜†'.repeat(3 - level);
            }

            // --- Mode Management Functions ---
            async function switchToDailyMode() {
                currentMode = 'daily';
                updateModeUI();
                updateButtonVisibility();
                await restoreDailyMode();
            }

            async function restoreDailyMode() {
                const today = getDateString();

                // Check if we already have today's puzzle cached
                const cachedPuzzle = localStorage.getItem(`dailyPuzzle_${today}`);
                if (cachedPuzzle) {
                    try {
                        const puzzleData = JSON.parse(cachedPuzzle);
                        // Reconstruct conditions with filter functions
                        currentConditions = {
                            rows: puzzleData.conditions.rows.map(c => allConditions.find(cond => cond.id === c.id)),
                            cols: puzzleData.conditions.cols.map(c => allConditions.find(cond => cond.id === c.id))
                        };
                        gridSize = 3; // Always 3x3 for daily
                        resetBoard();
                        updateGridLabels();
                        displayLevel(puzzleData.level);
                        UIElements.puzzleCodeDisplay.textContent = puzzleData.code;
                        document.getElementById('puzzle-number-display').textContent = `Daily Puzzle - ${today}`;

                        // Restore saved progress
                        restoreDailyProgress(today);
                        return;
                    } catch (e) {
                        console.error('Failed to load cached daily puzzle:', e);
                    }
                }

                // If no cached puzzle exists, generate a new one
                await generateDailyPuzzle();
            }

            function switchToExploreMode() {
                currentMode = 'explore';
                updateModeUI();
                updateButtonVisibility();
                // Generate a new explore puzzle
                generateNewPuzzle(3, 2);
            }

            function updateModeUI() {
                const dailyBtn = document.getElementById('daily-mode-btn');
                const exploreBtn = document.getElementById('explore-mode-btn');
                const modeIndicator = document.getElementById('mode-indicator');

                if (currentMode === 'daily') {
                    dailyBtn.classList.add('active');
                    exploreBtn.classList.remove('active');
                    modeIndicator.className = 'mode-indicator daily-mode-indicator';
                    modeIndicator.innerHTML = `
                        DAILY PUZZLE MODE<br>
                        <small>One 3x3 puzzle per day â€¢ Check your answers and share results!</small>
                    `;
                } else {
                    dailyBtn.classList.remove('active');
                    exploreBtn.classList.add('active');
                    modeIndicator.className = 'mode-indicator explore-mode-indicator';
                    modeIndicator.innerHTML = `
                        EXPLORE MODE<br>
                        <small>Import puzzles, create new games, and play freely!</small>
                    `;
                }
            }

            function updateButtonVisibility() {
                const newPuzzleBtn = UIElements.newPuzzleButton;
                const importPuzzleBtn = UIElements.importPuzzleButton;

                if (currentMode === 'daily') {
                    // Hide/disable buttons not available in daily mode
                    newPuzzleBtn.style.display = 'none';
                    importPuzzleBtn.style.display = 'none';
                } else {
                    // Show all buttons in explore mode
                    newPuzzleBtn.style.display = 'inline-block';
                    importPuzzleBtn.style.display = 'inline-block';
                }
            }

            function getDateString() {
                const now = new Date();
                return now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate();
            }

            function generateDailyPuzzleSeed() {
                const dateStr = getDateString();
                let hash = 0;
                for (let i = 0; i < dateStr.length; i++) {
                    const char = dateStr.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }

            async function generateDailyPuzzle() {
                const today = getDateString();
                const seed = generateDailyPuzzleSeed();

                // Check if we already have today's puzzle cached
                const cachedPuzzle = localStorage.getItem(`dailyPuzzle_${today}`);
                if (cachedPuzzle) {
                    try {
                        const puzzleData = JSON.parse(cachedPuzzle);
                        // Reconstruct conditions with filter functions
                        currentConditions = {
                            rows: puzzleData.conditions.rows.map(c => allConditions.find(cond => cond.id === c.id)),
                            cols: puzzleData.conditions.cols.map(c => allConditions.find(cond => cond.id === c.id))
                        };
                        gridSize = 3; // Always 3x3 for daily
                        resetBoard();
                        updateGridLabels();
                        displayLevel(puzzleData.level);
                        UIElements.puzzleCodeDisplay.textContent = puzzleData.code;
                        document.getElementById('puzzle-number-display').textContent = `Daily Puzzle - ${today}`;

                        // Restore saved progress
                        restoreDailyProgress(today);
                        return;
                    } catch (e) {
                        console.error('Failed to load cached daily puzzle:', e);
                    }
                }

                // Generate new daily puzzle
                UIElements.loader.innerHTML = `<div class="loader"></div><p>Generating today's daily puzzle...</p>`;
                UIElements.loader.style.display = 'flex';

                // Use seed for reproducible randomization
                const seededRandom = seedRandom(seed);
                let foundPuzzle = false;
                let attempts = 0;

                while (!foundPuzzle && attempts < 50000) {
                    // Create seeded shuffle of conditions
                    const shuffled = [...allConditions].sort(() => seededRandom() - 0.5);
                    const selectedRows = shuffled.slice(0, 3);
                    const selectedCols = shuffled.slice(3, 6);

                    if (isPuzzleSolvable(selectedRows, selectedCols, 3)) {
                        const level = calculatePuzzleDifficulty(selectedRows, selectedCols, 3);
                        currentConditions = { rows: selectedRows, cols: selectedCols };
                        const code = generatePuzzleCode(selectedRows, selectedCols, 3);

                        // Cache the puzzle
                        const puzzleData = {
                            conditions: {
                                rows: currentConditions.rows.map(c => ({ id: c.id, display: c.display })),
                                cols: currentConditions.cols.map(c => ({ id: c.id, display: c.display }))
                            },
                            level: level,
                            code: code,
                            date: today
                        };
                        localStorage.setItem(`dailyPuzzle_${today}`, JSON.stringify(puzzleData));

                        resetBoard();
                        updateGridLabels();
                        displayLevel(level);
                        UIElements.puzzleCodeDisplay.textContent = code;
                        document.getElementById('puzzle-number-display').textContent = `Daily Puzzle - ${today}`;
                        foundPuzzle = true;
                    }
                    attempts++;
                }

                if (!foundPuzzle) {
                    showCustomAlert('Could not generate today\'s puzzle. Please try again later.');
                }

                UIElements.loader.style.display = 'none';
            }

            // Simple seeded random number generator
            function seedRandom(seed) {
                let m = 2 ** 35 - 31;
                let a = 185852;
                let s = seed % m;
                return function () {
                    return (s = (s * a) % m) / m;
                };
            }

            function saveDailyProgress(date) {
                if (currentMode !== 'daily') return;

                const progressData = {
                    gridState: gridState.map(card => card ? {
                        fullName: card.fullName,
                        thumbnail: card.images.thumbnail
                    } : null),
                    date: date
                };

                localStorage.setItem(`dailyProgress_${date}`, JSON.stringify(progressData));
            }

            function restoreDailyProgress(date) {
                if (currentMode !== 'daily') return;

                try {
                    const savedProgress = localStorage.getItem(`dailyProgress_${date}`);
                    if (savedProgress) {
                        const progressData = JSON.parse(savedProgress);

                        // Restore the grid state
                        progressData.gridState.forEach((cardData, index) => {
                            if (cardData && allCards.length > 0) {
                                // Find the card by name
                                const card = allCards.find(c => c.fullName === cardData.fullName);
                                if (card) {
                                    gridState[index] = card;
                                    UIElements.grid.childNodes[index].style.backgroundImage = `url(${cardData.thumbnail})`;
                                }
                            }
                        });
                    }
                } catch (e) {
                    console.error('Failed to restore daily progress:', e);
                }
            }

            function clearDailyProgress(date) {
                localStorage.removeItem(`dailyProgress_${date}`);
            }
            
            function isPuzzleSolvable(rowConditions, colConditions, size) {
                const usedCards = new Set();
                for (let i = 0; i < size * size; i++) {
                    const solution = allCards.find(c => !usedCards.has(c.fullName) && rowConditions[Math.floor(i/size)].filter(c) && colConditions[i%size].filter(c));
                    if (!solution) return false;
                    usedCards.add(solution.fullName);
                }
                return true;
            }

            async function generateNewPuzzle(targetGridSize, targetLevel) {
                gridSize = targetGridSize;
                UIElements.loader.innerHTML = `<div class="loader"></div><p>Searching for a ${gridSize}x${gridSize} level ${targetLevel} puzzle...</p>`;
                UIElements.loader.style.display = 'flex';
                await new Promise(resolve => setTimeout(resolve, 0));
                let foundPuzzle = false, attempts = 0;
                while (!foundPuzzle && attempts < 10000) {
                    const shuffled = [...allConditions].sort(() => 0.5 - Math.random());
                    const selectedRows = shuffled.slice(0, gridSize);
                    const selectedCols = shuffled.slice(gridSize, gridSize * 2);
                    if (isPuzzleSolvable(selectedRows, selectedCols, gridSize)) {
                        const level = calculatePuzzleDifficulty(selectedRows, selectedCols, gridSize);
                        if (level === targetLevel) {
                            currentConditions = { rows: selectedRows, cols: selectedCols };
                            const code = generatePuzzleCode(selectedRows, selectedCols, gridSize);
                            resetBoard(); updateGridLabels(); displayLevel(level);
                            UIElements.puzzleCodeDisplay.textContent = code;
                            document.getElementById('puzzle-number-display').textContent = `Puzzle: ${puzzleCount++}`;
                            foundPuzzle = true;
                        }
                    }
                    attempts++;
                }
                if (!foundPuzzle) showCustomAlert(`Could not find a level ${targetLevel} puzzle. Please try another difficulty.`);
                UIElements.loader.style.display = 'none';
            }
            
            function resetBoard() {
                updateGridUI();
                gridState = Array(gridSize * gridSize).fill(null);
                UIElements.copyButton.disabled = false;
                UIElements.solveButton.disabled = false;
            }
            
            function generatePuzzleCode(rows, cols, size) {
                const idString = [...rows, ...cols].map(c => c.id).join(',');
                return `${size}:${btoa(idString)}`;
            }

            function loadPuzzleFromCode(code) {
                try {
                    const [sizeStr, base64] = code.split(':');
                    const size = parseInt(sizeStr, 10);
                    if (![2, 3, 4].includes(size)) throw new Error("Invalid grid size in code");
                    gridSize = size;
                    const ids = atob(base64).split(',');
                    if (ids.length !== size * 2) throw new Error("Invalid code format");
                    const newRows = ids.slice(0, size).map(id => allConditions.find(c => c.id === id));
                    const newCols = ids.slice(size).map(id => allConditions.find(c => c.id === id));
                    if (newRows.some(c => !c) || newCols.some(c => !c)) throw new Error("Unknown condition in code");
                    if (!isPuzzleSolvable(newRows, newCols, size)) { showCustomAlert("This puzzle is not solvable."); return; }
                    currentConditions = { rows: newRows, cols: newCols };
                    const level = calculatePuzzleDifficulty(newRows, newCols, size);
                    resetBoard(); updateGridLabels(); displayLevel(level);
                    UIElements.puzzleCodeDisplay.textContent = code;
                    document.getElementById('puzzle-number-display').textContent = 'Imported Puzzle';
                } catch (e) {
                    showCustomAlert("Invalid or corrupted puzzle code.");
                    console.error("Failed to load puzzle from code:", e);
                    throw e; // Re-throw to allow caller to handle the error
                }
            }
            
            function checkAnswers() {
                const cardNames = gridState.map(c => c ? c.fullName : null).filter(Boolean);
                const hasDuplicates = new Set(cardNames).size !== cardNames.length;
                UIElements.grid.childNodes.forEach((cell, index) => {
                    clearCellFeedback(cell);
                    const card = gridState[index];
                    if (!card) return;
                    const isDuplicate = cardNames.indexOf(card.fullName) !== cardNames.lastIndexOf(card.fullName);
                    if (currentConditions.rows[Math.floor(index/gridSize)].filter(card) && currentConditions.cols[index%gridSize].filter(card) && !isDuplicate) {
                        cell.classList.add('correct');
                    } else { cell.classList.add('incorrect'); }
                });
                if (hasDuplicates) { showCustomAlert('Duplicates found! Each card must be unique.'); }
            }
            
            async function handleSolveClick() {
                const confirmed = await showConfirmation("Are you sure? This will solve the puzzle and disable copy results.");
                if (confirmed) { solvePuzzle(); UIElements.copyButton.disabled = true; UIElements.solveButton.disabled = true; }
            }

            function solvePuzzle() {
                const correctness = Array(gridSize * gridSize).fill(false);
                const cardNames = gridState.map(c => c ? c.fullName : null);
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const card = gridState[i];
                    if (!card) continue;
                    const isDuplicate = cardNames.indexOf(card.fullName) !== cardNames.lastIndexOf(card.fullName);
                    if (currentConditions.rows[Math.floor(i/gridSize)].filter(card) && currentConditions.cols[i%gridSize].filter(card) && !isDuplicate) correctness[i] = true;
                }
                const cardsToKeep = new Set();
                const indicesToSolve = [];
                correctness.forEach((isCorrect, index) => {
                    if (isCorrect) cardsToKeep.add(gridState[index].fullName);
                    else indicesToSolve.push(index);
                });
                indicesToSolve.forEach(index => {
                    gridState[index] = null;
                    UIElements.grid.childNodes[index].style.backgroundImage = 'none';
                    clearCellFeedback(UIElements.grid.childNodes[index]);
                });
                indicesToSolve.forEach(index => {
                    const solution = allCards.find(c => !cardsToKeep.has(c.fullName) && currentConditions.rows[Math.floor(index/gridSize)].filter(c) && currentConditions.cols[index%gridSize].filter(c));
                    if (solution) {
                        gridState[index] = solution;
                        UIElements.grid.childNodes[index].style.backgroundImage = `url(${solution.images.thumbnail})`;
                        cardsToKeep.add(solution.fullName);
                    }
                });

                // Save progress if in daily mode
                if (currentMode === 'daily') {
                    const today = getDateString();
                    saveDailyProgress(today);
                }
            }

            // --- Tutorial System ---
            let currentTutorialStep = 0;
            let tutorialSteps = [];
            const tutorialOverlay = document.getElementById('tutorial-overlay');
            const tutorialBox = document.getElementById('tutorial-box');

            function setupTutorial() {
                tutorialSteps = [
                    { element: 'h1', text: 'Welcome to Dokuborn! This quick tutorial will show you how to play.' },
                    { element: '.mode-selector', text: 'Choose between DAILY PUZZLE mode (one puzzle per day) or EXPLORE mode (create and import custom puzzles).' },
                    { element: '.puzzle-grid', text: 'This is the puzzle grid. Your goal is to place a unique Lorcana card in each cell.' },
                    { element: '.puzzle-grid-area', text: 'Each card must satisfy BOTH the condition for its row and its column.' },
                    { element: '.grid-cell[data-index="0"]', text: 'Click on any cell to open a search window and find the perfect card.' },
                    { element: '#check-button', text: 'Use the "Check Answers" button to see how you\'re doing. Correct cells turn green, incorrect ones turn red.' },
                    { element: '#new-puzzle-button', text: 'In EXPLORE mode, click here to select a grid size and difficulty for a new challenge.' },
                    { element: '.puzzle-meta', text: 'You can share puzzles with friends using this unique code, or import a code from them.'},
                    { element: '#solve-button', text: 'Stuck? The "Solve Puzzle" button will fill in the missing correct answers for you.' }
                ];
                document.getElementById('tutorial-next').addEventListener('click', nextTutorialStep);
                document.getElementById('tutorial-prev').addEventListener('click', prevTutorialStep);
                document.getElementById('tutorial-skip').addEventListener('click', endTutorial);
                UIElements.helpButton.addEventListener('click', startTutorial);
            }

            function startTutorial() {
                currentTutorialStep = 0;
                tutorialOverlay.style.display = 'block';
                tutorialBox.style.display = 'block';
                showTutorialStep(currentTutorialStep);
            }

            function endTutorial() {
                tutorialOverlay.style.display = 'none';
                tutorialBox.style.display = 'none';
                const highlighted = document.querySelector('.tutorial-highlight');
                if (highlighted) highlighted.classList.remove('tutorial-highlight');
                localStorage.setItem('dokubornTutorialSeen', 'true');
            }
            
            function nextTutorialStep() {
                if (currentTutorialStep < tutorialSteps.length - 1) {
                    currentTutorialStep++;
                    showTutorialStep(currentTutorialStep);
                } else {
                    endTutorial();
                }
            }

            function prevTutorialStep() {
                if (currentTutorialStep > 0) {
                    currentTutorialStep--;
                    showTutorialStep(currentTutorialStep);
                }
            }

            function showTutorialStep(index) {
                document.getElementById('tutorial-prev').style.visibility = (index === 0) ? 'hidden' : 'visible';
                document.getElementById('tutorial-next').textContent = (index === tutorialSteps.length - 1) ? 'Finish' : 'Next';
                
                const step = tutorialSteps[index];
                document.getElementById('tutorial-text').textContent = step.text;
                
                const highlighted = document.querySelector('.tutorial-highlight');
                if (highlighted) highlighted.classList.remove('tutorial-highlight');

                const elementToHighlight = document.querySelector(step.element);
                if (elementToHighlight) {
                    elementToHighlight.classList.add('tutorial-highlight');
                }
            }


            // --- Event Listeners and Initializers ---
            // Mode switching buttons
            document.getElementById('daily-mode-btn').addEventListener('click', switchToDailyMode);
            document.getElementById('explore-mode-btn').addEventListener('click', switchToExploreMode);

            UIElements.newPuzzleButton.addEventListener('click', () => { document.getElementById('grid-size-modal').style.display = 'flex'; });
            UIElements.importPuzzleButton.addEventListener('click', () => { document.getElementById('import-modal').style.display = 'flex'; document.getElementById('import-input').focus(); });
            document.getElementById('import-cancel').addEventListener('click', () => { document.getElementById('import-modal').style.display = 'none'; });
            document.getElementById('import-submit').addEventListener('click', () => {
                const code = document.getElementById('import-input').value.trim();
                if (code) loadPuzzleFromCode(code);
                document.getElementById('import-modal').style.display = 'none';
            });
            UIElements.copyCodeButton.addEventListener('click', () => copyTextToClipboard(UIElements.puzzleCodeDisplay.textContent, UIElements.copyCodeButton));
            UIElements.checkButton.addEventListener('click', checkAnswers);
            UIElements.solveButton.addEventListener('click', handleSolveClick);

            // Add logging to copy button event listener
            UIElements.copyButton.addEventListener('click', () => {
                console.log('Copy Results button clicked');
                console.log('Copy button disabled state:', UIElements.copyButton.disabled);
                copyResults();
            });

            initializeGame();
            
            // --- Unchanged/Helper Functions ---
            function openSearchModal() { UIElements.searchModal.style.display = 'flex'; UIElements.searchInput.value = ''; UIElements.searchResults.innerHTML = ''; UIElements.searchInput.focus(); }
            function closeSearchModal() { UIElements.searchModal.style.display = 'none'; activeCell = null; }
            UIElements.searchModal.addEventListener('click', (e) => { if (e.target === UIElements.searchModal) closeSearchModal(); });
            UIElements.searchInput.addEventListener('input', () => {
                const results = fuse.search(UIElements.searchInput.value, { limit: 20 });
                displayResults(results);
            });
            function displayResults(results) {
                UIElements.searchResults.innerHTML = '';
                results.forEach(result => {
                    const li = document.createElement('li'), img = document.createElement('img'), name = document.createElement('span');
                    img.src = result.item.images.thumbnail; name.textContent = result.item.fullName;
                    li.append(img, name);
                    li.addEventListener('click', () => selectCard(result.item));
                    UIElements.searchResults.appendChild(li);
                });
            }
            function selectCard(card) {
                if (!activeCell) return;
                const index = activeCell.dataset.index;
                gridState[index] = card;
                activeCell.style.backgroundImage = `url(${card.images.thumbnail})`;
                clearCellFeedback(activeCell);
                closeSearchModal();

                // Save progress if in daily mode
                if (currentMode === 'daily') {
                    const today = getDateString();
                    saveDailyProgress(today);
                }
            }
            function clearCellFeedback(cell) { cell.classList.remove('correct', 'incorrect'); }
            function copyResults() {
                console.log('Copy Results function called');

                // First, check answers to ensure we have the latest feedback
                console.log('Running checkAnswers() first to get current status');
                checkAnswers();

                let resultString = `Dokuborn Puzzle\nPlay @ https://heavenideas.github.io/utilities/dokuborn.html?v=${UIElements.puzzleCodeDisplay.textContent}\nMy Results:\n\n`;
                let correctCount = 0;
                let filledCount = 0;
                console.log('Grid size:', gridSize);
                console.log('Grid state length:', gridState.length);
                console.log('Puzzle code:', UIElements.puzzleCodeDisplay.textContent);

                // Build emoji grid
                let gridRows = [];
                for (let row = 0; row < gridSize; row++) {
                    let rowEmojis = [];
                    for (let col = 0; col < gridSize; col++) {
                        const index = row * gridSize + col;
                        let emoji = 'â¬œ'; // Default empty

                        if (gridState[index]) {
                            filledCount++;
                            if (UIElements.grid.childNodes[index].classList.contains('correct')) {
                                emoji = 'ðŸŸ©'; // Green square for correct
                                correctCount++;
                            } else if (UIElements.grid.childNodes[index].classList.contains('incorrect')) {
                                emoji = 'ðŸŸ¥'; // Red square for incorrect
                            }
                        }

                        rowEmojis.push(emoji);
                    }
                    gridRows.push(rowEmojis.join(''));
                }

                resultString += gridRows.join('\n');
                resultString += `\n\nProgress: ${filledCount}/${gridSize*gridSize} cells filled`;
                resultString += `\nCorrect: ${correctCount}/${gridSize*gridSize} cells correct`;
                console.log('Result string to copy:', resultString);
                copyTextToClipboard(resultString, UIElements.copyButton);
            }
            async function copyTextToClipboard(text, button) {
                console.log('copyTextToClipboard called with text:', text);
                console.log('Button element:', button);

                try {
                    // Use modern Clipboard API first
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(text);
                        console.log('Modern clipboard API succeeded');
                    } else {
                        // Fallback to deprecated method for older browsers
                        console.log('Using fallback method');
                        const textArea = document.createElement("textarea");
                        textArea.value = text;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-9999px';
                        textArea.style.top = '-9999px';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();

                        const copySuccess = document.execCommand('copy');
                        console.log('document.execCommand result:', copySuccess);
                        document.body.removeChild(textArea);

                        if (!copySuccess) {
                            throw new Error('Fallback copy method failed');
                        }
                    }

                    const originalText = button.textContent;
                    button.textContent = 'Copied!';
                    setTimeout(() => { button.textContent = originalText; }, 1500);
                } catch (err) {
                    console.error('Copy operation failed:', err);
                    showCustomAlert('Failed to copy text. Please try again or copy manually.');
                }
            }
            function showCustomAlert(message) {
                const alertBox = document.createElement('div');
                alertBox.style.cssText = `position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 15px 25px; background-color: var(--wood-light); color: var(--parchment); border: 2px solid var(--border-gold); border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 10003;`;
                alertBox.textContent = message;
                document.body.appendChild(alertBox);
                setTimeout(() => alertBox.remove(), 3000);
            }
            function showConfirmation(message) {
                return new Promise((resolve) => {
                    const modal = document.getElementById('confirmation-modal');
                    modal.querySelector('p').textContent = message;
                    modal.style.display = 'flex';
                    const yes = modal.querySelector('#confirm-yes');
                    const no = modal.querySelector('#confirm-no');
                    const listener = (e) => {
                        modal.style.display = 'none';
                        yes.removeEventListener('click', yesListener);
                        no.removeEventListener('click', noListener);
                        resolve(e.target === yes);
                    };
                    const yesListener = (e) => listener(e);
                    const noListener = (e) => listener(e);
                    yes.addEventListener('click', yesListener);
                    no.addEventListener('click', noListener);
                });
            }
        });
    </script>
</body>
</html>
