<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disney Lorcana AI Match Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
    <style>
        /* Custom dark theme and layout styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        .dark-theme {
            background-color: #111827; /* gray-900 */
            color: #f3f4f6; /* gray-100 */
        }
        .card-container {
            aspect-ratio: 2.5 / 3.5;
            transition: transform 0.3s ease-in-out, filter 0.3s ease-in-out;
            background-size: cover;
            background-position: center;
        }
        .card-container.exhausted {
            transform: rotate(90deg) scale(0.9);
            filter: grayscale(50%);
        }
        /* Custom scrollbar for a better dark mode aesthetic */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        .selected-log {
            background-color: rgba(59, 130, 246, 0.3);
            border-left: 4px solid #3b82f6;
        }

        /* Player area backgrounds */
        .player1-board-bg {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.08) 0%, rgba(6, 182, 212, 0.03) 50%, rgba(0, 0, 0, 0.25) 100%);
            border: 2px solid rgba(6, 182, 212, 0.3);
            box-shadow: inset 0 1px 3px rgba(6, 182, 212, 0.1);
        }
        .player1-hand-bg {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.04) 0%, rgba(6, 182, 212, 0.02) 50%, rgba(0, 0, 0, 0.2) 100%);
            border: 2px solid rgba(6, 182, 212, 0.2);
            box-shadow: inset 0 1px 2px rgba(6, 182, 212, 0.05);
        }
        .player2-board-bg {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.08) 0%, rgba(245, 158, 11, 0.03) 50%, rgba(0, 0, 0, 0.25) 100%);
            border: 2px solid rgba(245, 158, 11, 0.3);
            box-shadow: inset 0 1px 3px rgba(245, 158, 11, 0.1);
        }
        .player2-hand-bg {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.04) 0%, rgba(245, 158, 11, 0.02) 50%, rgba(0, 0, 0, 0.2) 100%);
            border: 2px solid rgba(245, 158, 11, 0.2);
            box-shadow: inset 0 1px 2px rgba(245, 158, 11, 0.05);
        }

        /* Area labels */
        .area-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.8;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .player1 .area-label { color: rgba(6, 182, 212, 0.9); }
        .player2 .area-label { color: rgba(245, 158, 11, 0.9); }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="dark-theme">

    <div id="app" class="h-screen w-screen flex flex-col items-center justify-center p-4">

        <!-- Pre-Simulation Setup View -->
        <div id="setup-view" class="w-full max-w-6xl mx-auto">
            <!-- Header Section -->
            <div class="text-center mb-8">
                <h1 class="text-5xl font-bold mb-2 text-cyan-300">Disney Lorcana</h1>
                <h2 class="text-4xl font-bold mb-2 text-amber-300">AI Match Simulator</h2>
                <p class="text-gray-400 text-lg">Simulate AI vs AI matches with detailed game state tracking</p>
            </div>

            <!-- Loading Indicator -->
            <div id="loading-indicator" class="mb-8 text-center">
                <p class="text-xl animate-pulse text-gray-300">Fetching card database...</p>
            </div>

            <!-- Main Content Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">
                <!-- Deck Configuration -->
                <div class="lg:col-span-2">
                    <h3 class="text-2xl font-bold mb-6 text-center text-white">Deck Configuration</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Player 1 Deck -->
                        <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl p-6 border border-cyan-500/30">
                            <div class="flex justify-between items-center mb-4">
                                <h4 class="text-xl font-semibold text-cyan-300">Player 1 Deck</h4>
                                <button id="loadDeck1Btn" class="bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg text-sm hover:bg-cyan-700 transition">
                                    Load from DB
                                </button>
                            </div>
                            <textarea id="decklist1" class="w-full h-48 bg-gray-900 border border-gray-600 rounded-lg p-4 text-sm focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none transition resize-none" placeholder="Paste your decklist here..."></textarea>
                        </div>

                        <!-- Player 2 Deck -->
                        <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl p-6 border border-amber-500/30">
                            <div class="flex justify-between items-center mb-4">
                                <h4 class="text-xl font-semibold text-amber-300">Player 2 Deck</h4>
                                <button id="loadDeck2Btn" class="bg-amber-600 text-white font-bold py-2 px-4 rounded-lg text-sm hover:bg-amber-700 transition">
                                    Load from DB
                                </button>
                            </div>
                            <textarea id="decklist2" class="w-full h-48 bg-gray-900 border border-gray-600 rounded-lg p-4 text-sm focus:ring-2 focus:ring-amber-400 focus:border-amber-400 outline-none transition resize-none" placeholder="Paste your decklist here..."></textarea>
                        </div>
                    </div>
                </div>

                <!-- Options Panel -->
                <div class="space-y-6">
                    <!-- Load Simulation -->
                    <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl p-6 border border-green-500/30">
                        <h4 class="text-lg font-semibold mb-4 text-green-300">Load Saved Simulation</h4>
                        <div class="space-y-3">
                            <input type="file" id="simulation-file-input" accept=".json" class="hidden">
                            <button id="load-simulation-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition disabled:bg-gray-700 disabled:cursor-not-allowed">
                                Choose JSON File
                            </button>
                            <div id="loaded-file-name" class="text-sm text-center text-gray-400 min-h-[1.25rem]"></div>
                        </div>
                    </div>

                    <!-- Simulation Mode -->
                    <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl p-6 border border-purple-500/30">
                        <h4 class="text-lg font-semibold mb-4 text-purple-300">Simulation Mode</h4>
                        <label class="flex items-start space-x-3 cursor-pointer group">
                            <input type="checkbox" id="hyper-fast-mode" class="w-5 h-5 mt-0.5 text-purple-600 bg-gray-700 border-gray-600 rounded focus:ring-purple-500 focus:ring-2">
                            <div class="flex-1">
                                <span class="text-lg font-semibold text-purple-300 group-hover:text-purple-200 transition">Hyper-Fast Mode</span>
                                <p class="text-sm text-gray-400 mt-1">Run simulation instantly and auto-export JSON (no animations)</p>
                            </div>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="text-center space-y-4">
                <button id="start-button" class="bg-indigo-600 text-white font-bold py-4 px-12 rounded-xl text-xl hover:bg-indigo-700 transition-all hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100 shadow-lg shadow-indigo-500/25" disabled>
                    Start Simulation
                </button>

                <!-- Error Display -->
                <div id="error-display" class="hidden bg-red-800/50 border border-red-500 text-red-300 px-6 py-4 rounded-xl text-left max-w-2xl mx-auto">
                    <p class="font-bold text-lg mb-2">⚠️ Error</p>
                    <p id="error-message" class="text-sm"></p>
                </div>
            </div>
        </div>

        <!-- Simulation View -->
        <div id="simulation-view" class="hidden w-full h-full grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Player 1 Panel -->
            <div id="player1-panel" class="bg-gray-800/50 backdrop-blur-sm rounded-lg p-4 flex flex-col border border-cyan-500/30">
                <h2 class="text-2xl font-bold mb-4 border-b-2 border-cyan-400 pb-2 text-cyan-300">Player 1</h2>
                <div id="player1-stats" class="grid grid-cols-2 gap-2 mb-4 text-center"></div>
                <div class="mb-2">
                    <div class="area-label">Battlefield</div>
                    <div id="player1-board" class="flex-grow overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-2 p-2 player1-board-bg rounded-md min-h-[200px]"></div>
                </div>
                <div class="mt-2">
                    <div class="area-label">Hand</div>
                    <div id="player1-hand" class="flex-grow overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-2 p-2 player1-hand-bg rounded-md min-h-[100px]"></div>
                </div>
            </div>

            <!-- Central Game Log -->
            <div id="game-log-panel" class="bg-gray-800/50 backdrop-blur-sm rounded-lg p-4 flex flex-col border border-gray-500/30 overflow-y-auto">
                <div class="flex justify-between items-center mb-4 border-b-2 border-gray-400 pb-2">
                    <button id="back-to-main-btn" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-700 transition text-sm">
                        ← Back to Main
                    </button>
                    <h2 id="turn-marker" class="text-2xl font-bold text-center">Game Log</h2>
                    <button id="export-simulation-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition text-sm" style="display: none;">
                        Export Simulation
                    </button>
                </div>
                <div id="log-entries" class="flex-grow overflow-y-auto flex flex-col-reverse"></div>
            </div>

            <!-- Player 2 Panel -->
            <div id="player2-panel" class="bg-gray-800/50 backdrop-blur-sm rounded-lg p-4 flex flex-col border border-amber-500/30">
                <h2 class="text-2xl font-bold mb-4 border-b-2 border-amber-400 pb-2 text-amber-300">Player 2</h2>
                <div id="player2-stats" class="grid grid-cols-2 gap-2 mb-4 text-center"></div>
                <div class="mb-2">
                    <div class="area-label">Battlefield</div>
                    <div id="player2-board" class="flex-grow overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-2 p-2 player2-board-bg rounded-md min-h-[200px]"></div>
                </div>
                <div class="mt-2">
                    <div class="area-label">Hand</div>
                    <div id="player2-hand" class="flex-grow overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-2 p-2 player2-hand-bg rounded-md min-h-[100px]"></div>
                </div>
            </div>
        </div>


        <!-- Deck Load Modal -->
        <div id="deckLoadModal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-md p-4">
            <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-600">
                <h3 class="text-lg font-bold text-white mb-4">Select a Deck</h3>
                <input type="text" id="deckSearchInput" placeholder="Search decks by name..." class="w-full mb-4 px-3 py-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-2 focus:ring-cyan-400 focus:outline-none">
                <div id="deckListContainer" class="max-h-64 overflow-y-auto space-y-2">
                </div>
                <div class="flex justify-end mt-6">
                    <button id="closeDeckModalBtn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded font-semibold">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Hyper-Fast Mode Progress Modal -->
        <div id="hyperFastProgressModal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-md">
            <div class="bg-gray-800 rounded-xl shadow-2xl p-8 w-full max-w-md border border-purple-500/30">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-purple-300 mb-2">⚡ Hyper-Fast Simulation</h2>
                    <p class="text-gray-400">Running simulation at maximum speed...</p>
                </div>

                <div class="mb-4">
                    <div class="flex justify-between text-sm text-gray-400 mb-2">
                        <span>Progress</span>
                        <span id="progress-text">0%</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3">
                        <div id="progress-bar" class="bg-gradient-to-r from-purple-500 to-pink-500 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                </div>

                <div class="text-center">
                    <div class="text-sm text-gray-500 mb-2">Turn</div>
                    <div id="current-turn" class="text-2xl font-bold text-purple-300">0</div>
                </div>

                <div class="mt-6 text-center">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500 mx-auto"></div>
                    <p class="text-xs text-gray-500 mt-2">This may take a few seconds...</p>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // --- EMBEDDED inktable_game_library_v2.js (with modifications) ---
        let REAL_CARDS = [];

        function setCardDatabase(cards) {
            REAL_CARDS = cards;
            console.log(`Loaded ${REAL_CARDS.length} cards into library.`);
        }
        
        class InkTableGame {
            constructor() {
                this.players = [];
                this.currentPlayer = 0;
                this.turnNumber = 1;
                this.gameState = 'setup'; // setup, playing, ended
                this.winner = null;
                this.gameLog = [];
                this.boardStates = [];
            }

            initGame(player1DeckIds, player2DeckIds) {
                if (REAL_CARDS.length === 0) {
                    throw new Error("Card database not loaded into the library. Call setCardDatabase() first.");
                }

                const player1Deck = this.createDeckFromIds(player1DeckIds);
                const player2Deck = this.createDeckFromIds(player2DeckIds);
                
                if (player1Deck.length < 1 || player2Deck.length < 1) {
                    throw new Error("Decks must not be empty.");
                }

                this.players = [
                    new Player(1, player1Deck, false),
                    new Player(2, player2Deck, false) 
                ];
                
                this.players.forEach(player => {
                    player.shuffleDeck();
                    player.drawInitialHand();
                });
                
                this.gameState = 'playing';
                this.currentPlayer = 0;
                this.log({ message: 'Game started!' });
                // ** FIX: REMOVED FLAWED START-OF-TURN LOGIC FROM HERE **
            }

            createDeckFromIds(cardIds) {
                const deck = [];
                cardIds.forEach(id => {
                    const cardData = REAL_CARDS.find(card => card.id === id);
                    if (cardData) {
                        deck.push(new Card(JSON.parse(JSON.stringify(cardData))));
                    }
                });
                return deck;
            }

            getCurrentPlayer() { return this.players[this.currentPlayer]; }
            getOpponentPlayer() { return this.players[1 - this.currentPlayer]; }

            endTurn() {
                const player = this.getCurrentPlayer();
                this.log({ message: `Player ${player.playerNumber} ends their turn.` });
                
                this.currentPlayer = 1 - this.currentPlayer;
                const newPlayer = this.getCurrentPlayer();
                
                if (this.currentPlayer === 0) {
                    this.turnNumber++;
                }
                
                newPlayer.readyAllCards();
                newPlayer.draw(1);
                
                this.log({ message: `Turn ${this.turnNumber} - Player ${newPlayer.playerNumber}'s turn`});
                this.checkWinCondition();
            }

            checkWinCondition() {
                for (let player of this.players) {
                    if (player.lore >= 20) {
                        this.gameState = 'ended';
                        this.winner = player.playerNumber;
                        this.log({ message: `Player ${player.playerNumber} wins with ${player.lore} lore!`});
                        return true;
                    }
                }
                return false;
            }

            playCard(cardIndex) {
                const player = this.getCurrentPlayer();
                const card = player.hand[cardIndex];
                if (!card || !player.canAffordCard(card)) return false;

                player.payInkCost(card.cost);
                player.hand.splice(cardIndex, 1);
                
                switch (card.type) {
                    case 'Character':
                        player.characters.push(card);
                        card.summoningSickness = true;
                        break;
                    case 'Item': player.items.push(card); break;
                    default: player.discard.push(card); break;
                }
                this.log({ message: `Player ${player.playerNumber} plays`, card: card });
                return true;
            }

            questWithCharacter(characterIndex) {
                const player = this.getCurrentPlayer();
                const character = player.characters[characterIndex];
                if (!character || character.exhausted || character.summoningSickness) return false;
 
                character.exhausted = true;
                const loreGained = character.lore || 0;
                player.lore += loreGained;
                this.log({ message: `Player ${player.playerNumber} quests for ${loreGained} lore with`, card: character});
                this.checkWinCondition();
                return true;
            }

            challengeCharacter(attackerIndex, targetIndex) {
                const player = this.getCurrentPlayer();
                const opponent = this.getOpponentPlayer();
                const attacker = player.characters[attackerIndex];
                const target = opponent.characters[targetIndex];
                if (!attacker || !target || attacker.exhausted || attacker.summoningSickness) return false;
 
                attacker.exhausted = true;
                attacker.damage += target.strength || 0;
                target.damage += attacker.strength || 0;
                this.log({ message: `Player ${player.playerNumber} challenges`, card: attacker, targetCard: target });
                this.checkBanishedCharacters();
                return true;
            }

            checkBanishedCharacters() {
                this.players.forEach(player => {
                    for (let i = player.characters.length - 1; i >= 0; i--) {
                        const character = player.characters[i];
                        if (character.damage >= character.willpower) {
                            player.characters.splice(i, 1);
                            player.discard.push(character);
                            this.log({ message: `Player ${player.playerNumber}'s ${character.fullName} is banished` });
                        }
                    }
                });
            }

            inkCard(cardIndex) {
                const player = this.getCurrentPlayer();
                const card = player.hand[cardIndex];
                if (!card || !card.inkable) return false;

                player.hand.splice(cardIndex, 1);
                player.inkwell.push(card);
                this.log({ message: `Player ${player.playerNumber} inks`, card: card});
                return true;
            }

            generatePossibleMoves(player, opponent) {
                const moves = [];
                // Ink a card (high priority early game)
                if (player.turnInked === false) {
                    for (let i = 0; i < player.hand.length; i++) {
                        if (player.hand[i].inkable) {
                             moves.push({ type: 'ink', cardIndex: i, priority: 1000 - (player.inkwell.length * 100) });
                        }
                    }
                }

                // Play cards
                player.hand.forEach((card, i) => {
                    if (player.canAffordCard(card)) {
                        moves.push({ type: 'play', cardIndex: i, priority: 60 + (card.cost * 5) });
                    }
                });

                // Challenge
                player.characters.forEach((attacker, attIdx) => {
                    if (!attacker.exhausted && !attacker.summoningSickness && attacker.strength > 0) {
                        opponent.characters.forEach((target, tarIdx) => {
                            if (target.exhausted) {
                                moves.push({ type: 'challenge', attackerIndex: attIdx, targetIndex: tarIdx, priority: 80 + (target.lore * 20) });
                            }
                        });
                    }
                });

                // Quest
                player.characters.forEach((char, i) => {
                    if (!char.exhausted && !char.summoningSickness && char.lore > 0) {
                        moves.push({ type: 'quest', characterIndex: i, priority: 70 + (char.lore * 10) });
                    }
                });
                
                moves.push({ type: 'endTurn', priority: 1 });
                return moves.sort((a, b) => b.priority - a.priority);
            }

            makeAIMove() {
                if (this.gameState !== 'playing') return;
                const player = this.getCurrentPlayer();
                const opponent = this.getOpponentPlayer();
                const moves = this.generatePossibleMoves(player, opponent);

                if (moves.length > 0) {
                    this.executeMove(moves[0]);
                } else {
                    this.endTurn();
                }
            }

            executeMove(move) {
                switch (move.type) {
                    case 'play': this.playCard(move.cardIndex); break;
                    case 'quest': this.questWithCharacter(move.characterIndex); break;
                    case 'challenge': this.challengeCharacter(move.attackerIndex, move.targetIndex); break;
                    case 'ink': 
                        this.inkCard(move.cardIndex);
                        this.getCurrentPlayer().turnInked = true;
                        break;
                    case 'endTurn': this.endTurn(); break;
                }
            }

            log(logObject) {
                this.gameLog.push(logObject);
                this.boardStates.push(this.getGameStateWithoutLog());
            }
            getGameStateWithoutLog() {
                return {
                    players: this.players.map(p => p.getPublicState()),
                    currentPlayer: this.currentPlayer,
                    turnNumber: this.turnNumber,
                    gameState: this.gameState,
                    winner: this.winner
                };
            }
            getGameState() {
                return {
                    players: this.players.map(p => p.getPublicState()),
                    currentPlayer: this.currentPlayer,
                    turnNumber: this.turnNumber,
                    gameState: this.gameState,
                    winner: this.winner,
                    gameLog: [...this.gameLog]
                };
            }
        }

        class Player {
            constructor(playerNumber, deck, isHuman = false) {
                this.playerNumber = playerNumber;
                this.deck = [...deck];
                this.hand = [];
                this.discard = [];
                this.characters = [];
                this.items = [];
                this.locations = [];
                this.inkwell = [];
                this.lore = 0;
                this.turnInked = false;
            }
            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }
            drawInitialHand() { this.draw(7); }
            draw(count) {
                for (let i = 0; i < count && this.deck.length > 0; i++) {
                    this.hand.push(this.deck.pop());
                }
            }
            canAffordCard(card) { return this.getAvailableInk() >= card.cost; }
            getAvailableInk() { return this.inkwell.filter(card => !card.exhausted).length; }
            payInkCost(cost) {
                let remaining = cost;
                for (let card of this.inkwell) {
                    if (!card.exhausted && remaining > 0) {
                        card.exhausted = true;
                        remaining--;
                    }
                }
            }
            readyAllCards() {
                this.turnInked = false;
                [...this.characters, ...this.items, ...this.inkwell].forEach(card => {
                    card.exhausted = false;
                    if (card.summoningSickness !== undefined) card.summoningSickness = false;
                });
            }
            getPublicState() {
                return {
                    playerNumber: this.playerNumber,
                    handSize: this.hand.length,
                    deckSize: this.deck.length,
                    inkwellSize: this.inkwell.length,
                    lore: this.lore,
                    characters: this.characters.map(c => ({...c})),
                    hand: this.hand.map(c => ({...c})),
                };
            }
        }

        class Card {
            constructor(data) {
                this.id = data.id;
                this.fullName = data.fullName;
                this.cost = data.cost || 0;
                this.type = data.type;
                this.strength = data.strength;
                this.willpower = data.willpower;
                this.lore = data.lore;
                this.inkable = data.inkwell || false;
                this.image = (data.images && data.images.thumbnail) ? data.images.thumbnail : `https://placehold.co/100x140/2d3748/e2e8f0?text=${data.type}`;
                this.exhausted = false;
                this.summoningSickness = false;
                this.damage = 0;
            }
        }
        // --- END OF EMBEDDED LIBRARY ---

        // --- UI CONTROLLER SCRIPT ---
        const setupView = document.getElementById('setup-view');
        const simulationView = document.getElementById('simulation-view');
        const loadingIndicator = document.getElementById('loading-indicator');
        const startButton = document.getElementById('start-button');
        const decklist1El = document.getElementById('decklist1');
        const decklist2El = document.getElementById('decklist2');
        const logEntriesContainer = document.getElementById('log-entries');
        const errorDisplay = document.getElementById('error-display');
        const errorMessage = document.getElementById('error-message');

        const deckLoadModal = document.getElementById('deckLoadModal');
        const deckListContainer = document.getElementById('deckListContainer');
        const deckSearchInput = document.getElementById('deckSearchInput');
        const closeDeckModalBtn = document.getElementById('closeDeckModalBtn');
        const loadDeck1Btn = document.getElementById('loadDeck1Btn');
        const loadDeck2Btn = document.getElementById('loadDeck2Btn');

        let cardData = [];
        let cardNameMap = new Map();
        let game = null;
        let loadedSimulationData = null;
        let isLoadedSimulation = false;
        let isHyperFastMode = false;
        let hyperFastProgressModal = null;

        const SUPABASE_URL = 'https://cjlhrfhximjldqrfblkj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNqbGhyZmh4aW1qbGRxcmZibGtqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA0MTcxNzQsImV4cCI6MjA2NTk5MzE3NH0.zLiQcPnKt2SnNfQIkUnOG7bOo6F7MPMh8MsasdFF6lw';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let allDecks = [];
        let deckFuse;
        let deckLoadTarget = null;

        const exampleDeck1 = `4 Jasmine - Resourceful Infiltrator
4 Captain Hook - Forceful Duelist
4 Tipo - Growing Son
4 Doc - Bold Knight
4 Pleakley - Scientific Expert
4 Lawrence - Jealous Manservant
3 Lilo - Best Explorer Ever
4 Jasmine - Steady Strategist
4 Tinker Bell - Giant Fairy
4 Pluto - Guard Dog
2 Bagheera - Guardian Jaguar
4 Vincenzo Santorini - The Explosives Expert
1 Hades - Infernal Schemer
4 Dumptruck - Karnage's Second Mate
4 Strength of a Raging Fire
2 Mr. Smee - Steadfast Mate
4 Sail the Azurite Sea`;
        
        const exampleDeck2 = `4 Lady - Family Dog
4 Rhino - One-Sixteenth Wolf
4 Rhino - Power Hamster
4 Penny - Bolt's Person
4 Tiana - Restaurant Owner
4 Daisy Duck - Donald's Date
4 Pluto - Guard Dog
4 Doc - Bold Knight
4 Strength of a Raging Fire
4 Be Our Guest
4 Mr. Arrow - Legacy's First Mate
4 Pete - Games Referee
4 Calhoun - Marine Sergeant
4 Captain Hook - Forceful Duelist
4 Lilo - Best Explorer Ever`;

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }

        function parseDecklist(decklistText) {
            const lines = decklistText.trim().split('\n');
            const ids = [];
            const errors = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;

                const match = trimmedLine.match(/^(?:(\d+)\s*x?\s+)?(.+)/i);
                if (!match) continue;

                const count = match[1] ? parseInt(match[1], 10) : 1;
                const cardName = match[2].trim();

                if (cardNameMap.has(cardName)) {
                    const cardId = cardNameMap.get(cardName);
                    for (let i = 0; i < count; i++) {
                        ids.push(cardId);
                    }
                } else {
                    errors.push(cardName);
                }
            }
            if (errors.length > 0) {
                showError(`Could not find the following cards:\n- ${errors.join('\n- ')}`);
                return null;
            }
            return ids;
        }

        async function fetchDecksFromDatabase() {
            const { data, error } = await supabaseClient.from('decks').select('*').order('created_at', { ascending: true });
            if (error) {
                console.error('Error fetching decks:', error);
                allDecks = [];
            } else {
                allDecks = data;
            }
            deckFuse = new Fuse(allDecks, { keys: ['name'], includeScore: true, threshold: 0.4 });
        }

        function renderDeckList(decksToRender) {
            deckListContainer.innerHTML = !decksToRender.length ? '<p class="text-gray-400 italic text-center">No decks found.</p>' : '';
            decksToRender.forEach(deck => {
                const btn = document.createElement('button');
                btn.className = 'w-full text-left p-3 rounded-md hover:bg-cyan-600/20 focus:bg-cyan-600/30 focus:outline-none transition-colors font-semibold text-white';
                btn.textContent = deck.name;
                btn.addEventListener('click', () => {
                    decklist1El.value = deckLoadTarget === 'deck1' ? (deck.decklist || '') : decklist1El.value;
                    decklist2El.value = deckLoadTarget === 'deck2' ? (deck.decklist || '') : decklist2El.value;
                    hideDeckModal();
                });
                deckListContainer.appendChild(btn);
            });
        }

        function showDeckModal(target) {
            deckLoadTarget = target;
            deckLoadModal.classList.remove('hidden');
            deckSearchInput.value = '';
            renderDeckList(allDecks);
            deckSearchInput.focus();
        }

        function hideDeckModal() {
            deckLoadModal.classList.add('hidden');
            deckLoadTarget = null;
        }

        function loadSimulationFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const simulationData = JSON.parse(e.target.result);
                        resolve(simulationData);
                    } catch (error) {
                        reject(new Error('Invalid JSON file format'));
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        function exportSimulationToFile() {
            if (!game) return;

            const simulationData = {
                gameState: game.getGameState(),
                boardStates: game.boardStates,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };

            const dataStr = JSON.stringify(simulationData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            // Create full timestamp filename (YYYY-MM-DD_HH-MM-SS)
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const timeStr = now.toISOString().split('T')[1].split('.')[0].replace(/:/g, '-');
            const filename = `lorcana_simulation_${dateStr}_${timeStr}.json`;

            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function backToMainPage() {
            // Reset simulation state
            game = null;
            isLoadedSimulation = false;
            isHyperFastMode = false;
            lastLogCount = 0;
            currentSelectedLog = -1;

            // Hide simulation view and show setup view
            simulationView.classList.add('hidden');
            setupView.classList.remove('hidden');

            // Reset hyper-fast mode checkbox
            document.getElementById('hyper-fast-mode').checked = false;

            // Clear any loaded simulation data
            loadedSimulationData = null;
            document.getElementById('loaded-file-name').textContent = '';
            document.getElementById('load-simulation-btn').textContent = 'Choose JSON File';
            document.getElementById('load-simulation-btn').classList.remove('bg-green-700');
        }

        function loadSimulationIntoGame(simulationData) {
            // Create a new game instance and populate it with loaded data
            game = new InkTableGame();
            game.players = simulationData.gameState.players.map(p => {
                const player = new Player(p.playerNumber, [], false);
                player.lore = p.lore;
                player.characters = p.characters.map(c => new Card(c));
                player.hand = p.hand.map(c => new Card(c));
                player.deck = []; // Empty deck for loaded games
                player.discard = [];
                player.inkwell = [];
                player.turnInked = false;
                return player;
            });
            game.currentPlayer = simulationData.gameState.currentPlayer;
            game.turnNumber = simulationData.gameState.turnNumber;
            game.gameState = simulationData.gameState.gameState;
            game.winner = simulationData.gameState.winner;
            game.gameLog = simulationData.gameState.gameLog;
            game.boardStates = simulationData.boardStates;
        }

        function showHyperFastProgress() {
            hyperFastProgressModal = document.getElementById('hyperFastProgressModal');
            hyperFastProgressModal.classList.remove('hidden');
            updateHyperFastProgress(0, 0);
        }

        function hideHyperFastProgress() {
            if (hyperFastProgressModal) {
                hyperFastProgressModal.classList.add('hidden');
                hyperFastProgressModal = null;
            }
        }

        function updateHyperFastProgress(turnNumber, progressPercent) {
            if (!hyperFastProgressModal) return;

            document.getElementById('current-turn').textContent = turnNumber;
            document.getElementById('progress-text').textContent = Math.round(progressPercent) + '%';

            const progressBar = document.getElementById('progress-bar');
            progressBar.style.width = progressPercent + '%';
        }

        async function runHyperFastSimulation() {
            showHyperFastProgress();

            // Estimate maximum turns (games rarely go beyond 30 turns)
            const maxEstimatedTurns = 30;
            let turnCount = 0;

            // ** FIX: PROPERLY START THE FIRST TURN FOR PLAYER 1 **
            const firstPlayer = game.getCurrentPlayer();
            firstPlayer.readyAllCards();
            firstPlayer.draw(1);

            // Run simulation without UI updates for maximum speed
            while(game.gameState === 'playing' && turnCount < maxEstimatedTurns) {
                game.makeAIMove();
                turnCount = game.turnNumber;

                // Update progress (estimate based on turn number)
                const progressPercent = Math.min((turnCount / maxEstimatedTurns) * 100, 95);
                updateHyperFastProgress(turnCount, progressPercent);

                // Small yield to prevent browser freezing
                if (turnCount % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            // Complete progress
            updateHyperFastProgress(game.turnNumber, 100);

            // Small delay to show completion
            await new Promise(resolve => setTimeout(resolve, 500));

            hideHyperFastProgress();

            // Auto-export the simulation
            exportSimulationToFile();

            // Show completion message in console
            if (game.gameState === 'ended') {
                console.log(`Simulation complete! Player ${game.winner} wins after ${game.turnNumber} turns.`);
            } else {
                console.log(`Simulation complete! Game ended after ${game.turnNumber} turns.`);
            }
        }

        async function initialize() {
            try {
                const [cardsResponse, _] = await Promise.all([
                    fetch('https://cdn.jsdelivr.net/gh/heavenideas/similcana@main/database/allCards.json'),
                    fetchDecksFromDatabase()
                ]);
                if (!cardsResponse.ok) throw new Error(`HTTP error! status: ${cardsResponse.status}`);
                const data = await cardsResponse.json();
                cardData = data.cards;
                cardData.forEach(card => cardNameMap.set(card.fullName, card.id));
                setCardDatabase(cardData); // Set data for the game library

                loadingIndicator.textContent = "Card database loaded!";
                loadingIndicator.classList.remove('animate-pulse');
                startButton.disabled = false;
                decklist1El.value = exampleDeck1;
                decklist2El.value = exampleDeck2;

            } catch (error) {
                loadingIndicator.textContent = "Error loading card data. Please refresh.";
                console.error("Failed to initialize:", error);
            }
        }

        function renderPlayerState(player, panelId) {
            const statsEl = document.getElementById(`${panelId}-stats`);
            const boardEl = document.getElementById(`${panelId}-board`);
            const handEl = document.getElementById(`${panelId}-hand`);

            statsEl.innerHTML = `
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.lore}</div><div class="text-xs uppercase opacity-70">Lore</div></div>
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.inkwellSize}</div><div class="text-xs uppercase opacity-70">Inkwell</div></div>
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.handSize}</div><div class="text-xs uppercase opacity-70">Hand</div></div>
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.deckSize}</div><div class="text-xs uppercase opacity-70">Deck</div></div>
            `;

            boardEl.innerHTML = '';
            player.characters.forEach(char => {
                const cardDiv = document.createElement('div');
                cardDiv.className = `relative card-container rounded-lg shadow-lg border-2 border-transparent ${char.exhausted ? 'exhausted' : ''}`;
                cardDiv.style.backgroundImage = `url('${char.image}')`;

                if (char.damage > 0) {
                    cardDiv.innerHTML += `<div class="absolute -top-2 -right-2 bg-red-600 text-white rounded-full w-7 h-7 flex items-center justify-center font-bold text-sm border-2 border-gray-800">${char.damage}</div>`;
                }

                const statsOverlay = document.createElement('div');
                statsOverlay.className = 'absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1 flex justify-between font-bold';
                statsOverlay.innerHTML = `<span>${char.strength || '-'}</span><span>${char.willpower || '-'}</span>`;
                cardDiv.appendChild(statsOverlay);

                boardEl.appendChild(cardDiv);
            });

            handEl.innerHTML = '';
            if (player.hand) {
                player.hand.forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'relative card-container rounded-lg shadow-lg border-2 border-transparent';
                    cardDiv.style.backgroundImage = `url('${card.image}')`;

                    const costOverlay = document.createElement('div');
                    costOverlay.className = 'absolute top-0 left-0 bg-black/50 text-white text-xs p-1 font-bold rounded-tl-lg';
                    costOverlay.textContent = card.cost || 0;
                    cardDiv.appendChild(costOverlay);

                    handEl.appendChild(cardDiv);
                });
            }
        }

        let lastLogCount = 0;
        let currentSelectedLog = -1;
        function renderGameState(state = null) {
            if (!state) state = game.getGameState();
            renderPlayerState(state.players[0], 'player1');
            renderPlayerState(state.players[1], 'player2');

            const turnMarker = document.getElementById('turn-marker');
            turnMarker.textContent = `Turn ${state.turnNumber} - Player ${state.players[state.currentPlayer].playerNumber}'s Move`;
            const markerClass = state.currentPlayer === 0 ? 'text-cyan-300' : 'text-amber-300';
            turnMarker.className = `text-2xl font-bold mb-4 border-b-2 border-gray-400 pb-2 text-center ${markerClass}`;

            if (state.gameLog && state.gameLog.length > lastLogCount) {
                const newLogs = state.gameLog.slice(lastLogCount);
                newLogs.forEach((log, i) => {
                    const logEl = document.createElement('div');
                    logEl.className = 'p-2 border-t border-gray-700/50 flex items-center gap-3 text-sm cursor-pointer hover:bg-gray-700/30';
                    logEl.dataset.index = lastLogCount + i;
                    let content = '';
                    if (log.card) {
                        content += `<img src="${log.card.image}" class="w-8 h-auto rounded-sm" alt="${log.card.fullName}">`;
                        content += `<span class="font-semibold">${log.card.fullName}</span>`;
                    }
                    let playerClass = '';
                    if (log.message.includes('Player 1')) playerClass = 'text-cyan-300';
                    else if (log.message.includes('Player 2')) playerClass = 'text-amber-300';
                    content += `<span class="opacity-80 ${playerClass}">${log.message}</span>`;
                    if (log.targetCard) {
                        content += `<span class="font-semibold">${log.targetCard.fullName}</span>`;
                        content += `<img src="${log.targetCard.image}" class="w-8 h-auto rounded-sm" alt="${log.targetCard.fullName}">`;
                    }
                    logEl.innerHTML = content;
                    logEl.addEventListener('click', () => {
                        const index = parseInt(logEl.dataset.index);
                        renderGameState(game.boardStates[index]);
                        updateSelectedLog(index);
                    });
                    logEntriesContainer.prepend(logEl);
                });
                lastLogCount = state.gameLog.length;
            }
        }

        function updateSelectedLog(index) {
            if (currentSelectedLog !== -1) {
                const prevEl = document.querySelector(`[data-index="${currentSelectedLog}"]`);
                if (prevEl) prevEl.classList.remove('selected-log');
            }
            currentSelectedLog = index;
            const currentEl = document.querySelector(`[data-index="${index}"]`);
            if (currentEl) {
                currentEl.classList.add('selected-log');
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        document.addEventListener('keydown', (e) => {
            if (currentSelectedLog === -1 || !game || !game.boardStates) return;
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (currentSelectedLog > 0) {
                    const newIndex = currentSelectedLog - 1;
                    renderGameState(game.boardStates[newIndex]);
                    updateSelectedLog(newIndex);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (currentSelectedLog < game.boardStates.length - 1) {
                    const newIndex = currentSelectedLog + 1;
                    renderGameState(game.boardStates[newIndex]);
                    updateSelectedLog(newIndex);
                }
            }
        });
        
        async function runSimulation() {
            if (isLoadedSimulation) {
                // For loaded simulations, just show the final state
                renderGameState(game.getGameState());
                document.getElementById('export-simulation-btn').style.display = 'block';
                return;
            }

            // ** FIX: PROPERLY START THE FIRST TURN FOR PLAYER 1 **
            const firstPlayer = game.getCurrentPlayer();
            firstPlayer.readyAllCards();
            firstPlayer.draw(1);
            renderGameState(game.getGameState());
            await new Promise(resolve => setTimeout(resolve, 300));


            while(game.gameState === 'playing') {
                game.makeAIMove();
                renderGameState(game.getGameState());
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            // Show export button when simulation ends
            document.getElementById('export-simulation-btn').style.display = 'block';
        }

        startButton.addEventListener('click', () => {
            hideError(); // Hide previous errors

            // Check if hyper-fast mode is enabled
            isHyperFastMode = document.getElementById('hyper-fast-mode').checked;

            if (loadedSimulationData) {
                // Load from saved simulation
                try {
                    loadSimulationIntoGame(loadedSimulationData);
                    isLoadedSimulation = true;
                    lastLogCount = 0;
                    logEntriesContainer.innerHTML = '';
                    setupView.classList.add('hidden');
                    simulationView.classList.remove('hidden');
                    renderGameState(game.getGameState());
                    // Don't run simulation for loaded games
                    document.getElementById('export-simulation-btn').style.display = 'block';
                } catch(e) {
                    showError('Failed to load simulation: ' + e.message);
                    console.error(e);
                }
            } else {
                // Start new simulation
                const deck1Ids = parseDecklist(decklist1El.value);
                const deck2Ids = parseDecklist(decklist2El.value);

                if (deck1Ids && deck2Ids) {
                    try {
                        game = new InkTableGame();
                        game.initGame(deck1Ids, deck2Ids);
                        isLoadedSimulation = false;
                        lastLogCount = 0;
                        logEntriesContainer.innerHTML = '';

                        if (isHyperFastMode) {
                            // Run hyper-fast simulation
                            runHyperFastSimulation();
                        } else {
                            // Run normal simulation
                            setupView.classList.add('hidden');
                            simulationView.classList.remove('hidden');
                            renderGameState(game.getGameState());
                            runSimulation();
                        }
                    } catch(e) {
                        showError(e.message);
                        console.error(e);
                    }
                }
            }
        });

        loadDeck1Btn.addEventListener('click', () => showDeckModal('deck1'));
        loadDeck2Btn.addEventListener('click', () => showDeckModal('deck2'));
        closeDeckModalBtn.addEventListener('click', hideDeckModal);

        deckSearchInput.addEventListener('input', () => {
            const searchTerm = deckSearchInput.value.trim();
            renderDeckList(!searchTerm ? allDecks : deckFuse.search(searchTerm).map(r => r.item));
        });

        // Load simulation button
        document.getElementById('load-simulation-btn').addEventListener('click', () => {
            document.getElementById('simulation-file-input').click();
        });

        // File input change handler
        document.getElementById('simulation-file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    loadedSimulationData = await loadSimulationFromFile(file);
                    document.getElementById('loaded-file-name').textContent = `Loaded: ${file.name}`;
                    document.getElementById('load-simulation-btn').textContent = 'File Loaded - Click Start';
                    document.getElementById('load-simulation-btn').classList.add('bg-green-700');
                    startButton.disabled = false;
                } catch (error) {
                    showError('Failed to load simulation file: ' + error.message);
                    loadedSimulationData = null;
                    document.getElementById('loaded-file-name').textContent = '';
                    document.getElementById('load-simulation-btn').textContent = 'Load Simulation';
                    document.getElementById('load-simulation-btn').classList.remove('bg-green-700');
                }
            }
        });

        // Export simulation button
        document.getElementById('export-simulation-btn').addEventListener('click', () => {
            exportSimulationToFile();
        });

        // Back to main page button
        document.getElementById('back-to-main-btn').addEventListener('click', () => {
            backToMainPage();
        });

        // Initialize the app on load
        initialize();
    </script>
</body>
</html>

