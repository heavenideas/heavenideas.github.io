<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disney Lorcana AI Match Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom dark theme and layout styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        .dark-theme {
            background-color: #111827; /* gray-900 */
            color: #f3f4f6; /* gray-100 */
        }
        .card-container {
            aspect-ratio: 2.5 / 3.5;
            transition: transform 0.3s ease-in-out, filter 0.3s ease-in-out;
            background-size: cover;
            background-position: center;
        }
        .card-container.exhausted {
            transform: rotate(90deg) scale(0.9);
            filter: grayscale(50%);
        }
        /* Custom scrollbar for a better dark mode aesthetic */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="dark-theme">

    <div id="app" class="h-screen w-screen flex flex-col items-center justify-center p-4">

        <!-- Pre-Simulation Setup View -->
        <div id="setup-view" class="w-full max-w-4xl text-center">
            <h1 class="text-4xl font-bold mb-2 text-cyan-300">Disney Lorcana</h1>
            <h2 class="text-5xl font-bold mb-6 text-amber-300">AI Match Simulator</h2>

            <div id="loading-indicator" class="mb-6">
                <p class="text-lg animate-pulse">Fetching card database...</p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <div>
                    <label for="decklist1" class="block mb-2 text-lg font-semibold text-left">Player 1 Deck</label>
                    <textarea id="decklist1" class="w-full h-64 bg-gray-800 border border-gray-600 rounded-lg p-3 text-sm focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none transition"></textarea>
                </div>
                <div>
                    <label for="decklist2" class="block mb-2 text-lg font-semibold text-left">Player 2 Deck</label>
                    <textarea id="decklist2" class="w-full h-64 bg-gray-800 border border-gray-600 rounded-lg p-3 text-sm focus:ring-2 focus:ring-amber-400 focus:border-amber-400 outline-none transition"></textarea>
                </div>
            </div>
            <button id="start-button" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg text-xl hover:bg-indigo-700 transition-transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100" disabled>
                Start Simulation
            </button>
            <!-- New Error Display Area -->
            <div id="error-display" class="hidden mt-4 bg-red-800/50 border border-red-500 text-red-300 px-4 py-3 rounded-lg text-left">
                <p class="font-bold">An error occurred:</p>
                <p id="error-message" class="text-sm"></p>
            </div>
        </div>

        <!-- Simulation View -->
        <div id="simulation-view" class="hidden w-full h-full grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Player 1 Panel -->
            <div id="player1-panel" class="bg-gray-800/50 backdrop-blur-sm rounded-lg p-4 flex flex-col border border-cyan-500/30">
                <h2 class="text-2xl font-bold mb-4 border-b-2 border-cyan-400 pb-2 text-cyan-300">Player 1</h2>
                <div id="player1-stats" class="grid grid-cols-2 gap-2 mb-4 text-center"></div>
                <div id="player1-board" class="flex-grow overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-2 p-2 bg-black/20 rounded-md min-h-[200px]"></div>
            </div>

            <!-- Central Game Log -->
            <div id="game-log-panel" class="bg-gray-800/50 backdrop-blur-sm rounded-lg p-4 flex flex-col border border-gray-500/30 overflow-y-auto">
                <h2 id="turn-marker" class="text-2xl font-bold mb-4 border-b-2 border-gray-400 pb-2 text-center">Game Log</h2>
                <div id="log-entries" class="flex-grow overflow-y-auto flex flex-col-reverse"></div>
            </div>

            <!-- Player 2 Panel -->
            <div id="player2-panel" class="bg-gray-800/50 backdrop-blur-sm rounded-lg p-4 flex flex-col border border-amber-500/30">
                <h2 class="text-2xl font-bold mb-4 border-b-2 border-amber-400 pb-2 text-amber-300">Player 2</h2>
                <div id="player2-stats" class="grid grid-cols-2 gap-2 mb-4 text-center"></div>
                <div id="player2-board" class="flex-grow overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-2 p-2 bg-black/20 rounded-md min-h-[200px]"></div>
            </div>
        </div>

        <!-- Winner Banner -->
        <div id="winner-banner" class="hidden fixed inset-0 bg-black/60 backdrop-blur-md flex items-center justify-center z-50">
            <div id="winner-box" class="text-center bg-gray-800 p-12 rounded-xl border-2 border-yellow-400 shadow-2xl shadow-yellow-400/20">
                <h2 class="text-6xl font-bold text-yellow-300">VICTORY!</h2>
                <p id="winner-message" class="text-3xl mt-4"></p>
            </div>
        </div>

    </div>

    <script type="module">
        // --- EMBEDDED inktable_game_library_v2.js (with modifications) ---
        let REAL_CARDS = [];

        function setCardDatabase(cards) {
            REAL_CARDS = cards;
            console.log(`Loaded ${REAL_CARDS.length} cards into library.`);
        }
        
        class InkTableGame {
            constructor() {
                this.players = [];
                this.currentPlayer = 0;
                this.turnNumber = 1;
                this.gameState = 'setup'; // setup, playing, ended
                this.winner = null;
                this.gameLog = [];
            }

            initGame(player1DeckIds, player2DeckIds) {
                if (REAL_CARDS.length === 0) {
                    throw new Error("Card database not loaded into the library. Call setCardDatabase() first.");
                }

                const player1Deck = this.createDeckFromIds(player1DeckIds);
                const player2Deck = this.createDeckFromIds(player2DeckIds);
                
                if (player1Deck.length < 1 || player2Deck.length < 1) {
                    throw new Error("Decks must not be empty.");
                }

                this.players = [
                    new Player(1, player1Deck, false),
                    new Player(2, player2Deck, false) 
                ];
                
                this.players.forEach(player => {
                    player.shuffleDeck();
                    player.drawInitialHand();
                });
                
                this.gameState = 'playing';
                this.currentPlayer = 0;
                this.log({ message: 'Game started!' });
                // ** FIX: REMOVED FLAWED START-OF-TURN LOGIC FROM HERE **
            }

            createDeckFromIds(cardIds) {
                const deck = [];
                cardIds.forEach(id => {
                    const cardData = REAL_CARDS.find(card => card.id === id);
                    if (cardData) {
                        deck.push(new Card(JSON.parse(JSON.stringify(cardData))));
                    }
                });
                return deck;
            }

            getCurrentPlayer() { return this.players[this.currentPlayer]; }
            getOpponentPlayer() { return this.players[1 - this.currentPlayer]; }

            endTurn() {
                const player = this.getCurrentPlayer();
                this.log({ message: `Player ${player.playerNumber} ends their turn.` });
                
                this.currentPlayer = 1 - this.currentPlayer;
                const newPlayer = this.getCurrentPlayer();
                
                if (this.currentPlayer === 0) {
                    this.turnNumber++;
                }
                
                newPlayer.readyAllCards();
                newPlayer.draw(1);
                
                this.log({ message: `Turn ${this.turnNumber} - Player ${newPlayer.playerNumber}'s turn`});
                this.checkWinCondition();
            }

            checkWinCondition() {
                for (let player of this.players) {
                    if (player.lore >= 20) {
                        this.gameState = 'ended';
                        this.winner = player.playerNumber;
                        this.log({ message: `Player ${player.playerNumber} wins with ${player.lore} lore!`});
                        return true;
                    }
                }
                return false;
            }

            playCard(cardIndex) {
                const player = this.getCurrentPlayer();
                const card = player.hand[cardIndex];
                if (!card || !player.canAffordCard(card)) return false;

                player.payInkCost(card.cost);
                player.hand.splice(cardIndex, 1);
                
                switch (card.type) {
                    case 'Character':
                        player.characters.push(card);
                        card.summoningSickness = true;
                        break;
                    case 'Item': player.items.push(card); break;
                    default: player.discard.push(card); break;
                }
                this.log({ message: `Player ${player.playerNumber} plays`, card: card });
                return true;
            }

            questWithCharacter(characterIndex) {
                const player = this.getCurrentPlayer();
                const character = player.characters[characterIndex];
                if (!character || character.exhausted || character.summoningSickness) return false;
 
                character.exhausted = true;
                const loreGained = character.lore || 0;
                player.lore += loreGained;
                this.log({ message: `Player ${player.playerNumber} quests for ${loreGained} lore with`, card: character});
                this.checkWinCondition();
                return true;
            }

            challengeCharacter(attackerIndex, targetIndex) {
                const player = this.getCurrentPlayer();
                const opponent = this.getOpponentPlayer();
                const attacker = player.characters[attackerIndex];
                const target = opponent.characters[targetIndex];
                if (!attacker || !target || attacker.exhausted || attacker.summoningSickness) return false;
 
                attacker.exhausted = true;
                attacker.damage += target.strength || 0;
                target.damage += attacker.strength || 0;
                this.log({ message: `Player ${player.playerNumber} challenges`, card: attacker, targetCard: target });
                this.checkBanishedCharacters();
                return true;
            }

            checkBanishedCharacters() {
                this.players.forEach(player => {
                    for (let i = player.characters.length - 1; i >= 0; i--) {
                        const character = player.characters[i];
                        if (character.damage >= character.willpower) {
                            player.characters.splice(i, 1);
                            player.discard.push(character);
                            this.log({ message: `Player ${player.playerNumber}'s ${character.fullName} is banished` });
                        }
                    }
                });
            }

            inkCard(cardIndex) {
                const player = this.getCurrentPlayer();
                const card = player.hand[cardIndex];
                if (!card || !card.inkable) return false;

                player.hand.splice(cardIndex, 1);
                player.inkwell.push(card);
                this.log({ message: `Player ${player.playerNumber} inks`, card: card});
                return true;
            }

            generatePossibleMoves(player, opponent) {
                const moves = [];
                // Ink a card (high priority early game)
                if (player.turnInked === false) {
                    for (let i = 0; i < player.hand.length; i++) {
                        if (player.hand[i].inkable) {
                             moves.push({ type: 'ink', cardIndex: i, priority: 1000 - (player.inkwell.length * 100) });
                        }
                    }
                }

                // Play cards
                player.hand.forEach((card, i) => {
                    if (player.canAffordCard(card)) {
                        moves.push({ type: 'play', cardIndex: i, priority: 60 + (card.cost * 5) });
                    }
                });

                // Challenge
                player.characters.forEach((attacker, attIdx) => {
                    if (!attacker.exhausted && !attacker.summoningSickness && attacker.strength > 0) {
                        opponent.characters.forEach((target, tarIdx) => {
                            if (target.exhausted) {
                                moves.push({ type: 'challenge', attackerIndex: attIdx, targetIndex: tarIdx, priority: 80 + (target.lore * 20) });
                            }
                        });
                    }
                });

                // Quest
                player.characters.forEach((char, i) => {
                    if (!char.exhausted && !char.summoningSickness && char.lore > 0) {
                        moves.push({ type: 'quest', characterIndex: i, priority: 70 + (char.lore * 10) });
                    }
                });
                
                moves.push({ type: 'endTurn', priority: 1 });
                return moves.sort((a, b) => b.priority - a.priority);
            }

            makeAIMove() {
                if (this.gameState !== 'playing') return;
                const player = this.getCurrentPlayer();
                const opponent = this.getOpponentPlayer();
                const moves = this.generatePossibleMoves(player, opponent);

                if (moves.length > 0) {
                    this.executeMove(moves[0]);
                } else {
                    this.endTurn();
                }
            }

            executeMove(move) {
                switch (move.type) {
                    case 'play': this.playCard(move.cardIndex); break;
                    case 'quest': this.questWithCharacter(move.characterIndex); break;
                    case 'challenge': this.challengeCharacter(move.attackerIndex, move.targetIndex); break;
                    case 'ink': 
                        this.inkCard(move.cardIndex);
                        this.getCurrentPlayer().turnInked = true;
                        break;
                    case 'endTurn': this.endTurn(); break;
                }
            }

            log(logObject) { this.gameLog.push(logObject); }
            getGameState() {
                return {
                    players: this.players.map(p => p.getPublicState()),
                    currentPlayer: this.currentPlayer,
                    turnNumber: this.turnNumber,
                    gameState: this.gameState,
                    winner: this.winner,
                    gameLog: [...this.gameLog]
                };
            }
        }

        class Player {
            constructor(playerNumber, deck, isHuman = false) {
                this.playerNumber = playerNumber;
                this.deck = [...deck];
                this.hand = [];
                this.discard = [];
                this.characters = [];
                this.items = [];
                this.locations = [];
                this.inkwell = [];
                this.lore = 0;
                this.turnInked = false;
            }
            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }
            drawInitialHand() { this.draw(7); }
            draw(count) {
                for (let i = 0; i < count && this.deck.length > 0; i++) {
                    this.hand.push(this.deck.pop());
                }
            }
            canAffordCard(card) { return this.getAvailableInk() >= card.cost; }
            getAvailableInk() { return this.inkwell.filter(card => !card.exhausted).length; }
            payInkCost(cost) {
                let remaining = cost;
                for (let card of this.inkwell) {
                    if (!card.exhausted && remaining > 0) {
                        card.exhausted = true;
                        remaining--;
                    }
                }
            }
            readyAllCards() {
                this.turnInked = false;
                [...this.characters, ...this.items, ...this.inkwell].forEach(card => {
                    card.exhausted = false;
                    if (card.summoningSickness !== undefined) card.summoningSickness = false;
                });
            }
            getPublicState() {
                return {
                    playerNumber: this.playerNumber,
                    handSize: this.hand.length,
                    deckSize: this.deck.length,
                    inkwellSize: this.inkwell.length,
                    lore: this.lore,
                    characters: this.characters.map(c => ({...c})),
                };
            }
        }

        class Card {
            constructor(data) {
                this.id = data.id;
                this.fullName = data.fullName;
                this.cost = data.cost || 0;
                this.type = data.type;
                this.strength = data.strength;
                this.willpower = data.willpower;
                this.lore = data.lore;
                this.inkable = data.inkwell || false;
                this.image = (data.images && data.images.thumbnail) ? data.images.thumbnail : `https://placehold.co/100x140/2d3748/e2e8f0?text=${data.type}`;
                this.exhausted = false;
                this.summoningSickness = false;
                this.damage = 0;
            }
        }
        // --- END OF EMBEDDED LIBRARY ---

        // --- UI CONTROLLER SCRIPT ---
        const setupView = document.getElementById('setup-view');
        const simulationView = document.getElementById('simulation-view');
        const loadingIndicator = document.getElementById('loading-indicator');
        const startButton = document.getElementById('start-button');
        const decklist1El = document.getElementById('decklist1');
        const decklist2El = document.getElementById('decklist2');
        const winnerBanner = document.getElementById('winner-banner');
        const winnerMessage = document.getElementById('winner-message');
        const logEntriesContainer = document.getElementById('log-entries');
        const errorDisplay = document.getElementById('error-display');
        const errorMessage = document.getElementById('error-message');

        let cardData = [];
        let cardNameMap = new Map();
        let game = null;

        const exampleDeck1 = `4 Jasmine - Resourceful Infiltrator
4 Captain Hook - Forceful Duelist
4 Tipo - Growing Son
4 Doc - Bold Knight
4 Pleakley - Scientific Expert
4 Lawrence - Jealous Manservant
3 Lilo - Best Explorer Ever
4 Jasmine - Steady Strategist
4 Tinker Bell - Giant Fairy
4 Pluto - Guard Dog
2 Bagheera - Guardian Jaguar
4 Vincenzo Santorini - The Explosives Expert
1 Hades - Infernal Schemer
4 Dumptruck - Karnage's Second Mate
4 Strength of a Raging Fire
2 Mr. Smee - Steadfast Mate
4 Sail the Azurite Sea`;
        
        const exampleDeck2 = `4 Lady - Family Dog
4 Rhino - One-Sixteenth Wolf
4 Rhino - Power Hamster
4 Penny - Bolt's Person
4 Tiana - Restaurant Owner
4 Daisy Duck - Donald's Date
4 Pluto - Guard Dog
4 Doc - Bold Knight
4 Strength of a Raging Fire
4 Be Our Guest
4 Mr. Arrow - Legacy's First Mate
4 Pete - Games Referee
4 Calhoun - Marine Sergeant
4 Captain Hook - Forceful Duelist
4 Lilo - Best Explorer Ever`;

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }

        function parseDecklist(decklistText) {
            const lines = decklistText.trim().split('\n');
            const ids = [];
            const errors = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;

                const match = trimmedLine.match(/^(?:(\d+)\s*x?\s+)?(.+)/i);
                if (!match) continue;

                const count = match[1] ? parseInt(match[1], 10) : 1;
                const cardName = match[2].trim();

                if (cardNameMap.has(cardName)) {
                    const cardId = cardNameMap.get(cardName);
                    for (let i = 0; i < count; i++) {
                        ids.push(cardId);
                    }
                } else {
                    errors.push(cardName);
                }
            }
            if (errors.length > 0) {
                showError(`Could not find the following cards:\n- ${errors.join('\n- ')}`);
                return null;
            }
            return ids;
        }

        async function initialize() {
            try {
                const response = await fetch('https://cdn.jsdelivr.net/gh/heavenideas/similcana@main/database/allCards.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                cardData = data.cards;
                cardData.forEach(card => cardNameMap.set(card.fullName, card.id));
                setCardDatabase(cardData); // Set data for the game library

                loadingIndicator.textContent = "Card database loaded!";
                loadingIndicator.classList.remove('animate-pulse');
                startButton.disabled = false;
                decklist1El.value = exampleDeck1;
                decklist2El.value = exampleDeck2;

            } catch (error) {
                loadingIndicator.textContent = "Error loading card data. Please refresh.";
                console.error("Failed to initialize:", error);
            }
        }

        function renderPlayerState(player, panelId) {
            const statsEl = document.getElementById(`${panelId}-stats`);
            const boardEl = document.getElementById(`${panelId}-board`);

            statsEl.innerHTML = `
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.lore}</div><div class="text-xs uppercase opacity-70">Lore</div></div>
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.inkwellSize}</div><div class="text-xs uppercase opacity-70">Inkwell</div></div>
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.handSize}</div><div class="text-xs uppercase opacity-70">Hand</div></div>
                <div class="bg-black/20 p-2 rounded-md"><div class="font-bold text-xl">${player.deckSize}</div><div class="text-xs uppercase opacity-70">Deck</div></div>
            `;
            
            boardEl.innerHTML = '';
            player.characters.forEach(char => {
                const cardDiv = document.createElement('div');
                cardDiv.className = `relative card-container rounded-lg shadow-lg border-2 border-transparent ${char.exhausted ? 'exhausted' : ''}`;
                cardDiv.style.backgroundImage = `url('${char.image}')`;
                
                if (char.damage > 0) {
                    cardDiv.innerHTML += `<div class="absolute -top-2 -right-2 bg-red-600 text-white rounded-full w-7 h-7 flex items-center justify-center font-bold text-sm border-2 border-gray-800">${char.damage}</div>`;
                }

                const statsOverlay = document.createElement('div');
                statsOverlay.className = 'absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1 flex justify-between font-bold';
                statsOverlay.innerHTML = `<span>${char.strength || '-'}</span><span>${char.willpower || '-'}</span>`;
                cardDiv.appendChild(statsOverlay);

                boardEl.appendChild(cardDiv);
            });
        }

        let lastLogCount = 0;
        function renderGameState(state) {
            renderPlayerState(state.players[0], 'player1');
            renderPlayerState(state.players[1], 'player2');
            
            const turnMarker = document.getElementById('turn-marker');
            turnMarker.textContent = `Turn ${state.turnNumber} - Player ${state.players[state.currentPlayer].playerNumber}'s Move`;
            const markerClass = state.currentPlayer === 0 ? 'text-cyan-300' : 'text-amber-300';
            turnMarker.className = `text-2xl font-bold mb-4 border-b-2 border-gray-400 pb-2 text-center ${markerClass}`;
 
            if (state.gameLog.length > lastLogCount) {
                const newLogs = state.gameLog.slice(lastLogCount);
                newLogs.forEach(log => {
                    const logEl = document.createElement('div');
                    logEl.className = 'p-2 border-t border-gray-700/50 flex items-center gap-3 text-sm';
                    let content = '';
                    if (log.card) {
                        content += `<img src="${log.card.image}" class="w-8 h-auto rounded-sm" alt="${log.card.fullName}">`;
                        content += `<span class="font-semibold">${log.card.fullName}</span>`;
                    }
                    let playerClass = '';
                    if (log.message.includes('Player 1')) playerClass = 'text-cyan-300';
                    else if (log.message.includes('Player 2')) playerClass = 'text-amber-300';
                    content += `<span class="opacity-80 ${playerClass}">${log.message}</span>`;
                    if (log.targetCard) {
                        content += `<span class="font-semibold">${log.targetCard.fullName}</span>`;
                        content += `<img src="${log.targetCard.image}" class="w-8 h-auto rounded-sm" alt="${log.targetCard.fullName}">`;
                    }
                    logEl.innerHTML = content;
                    logEntriesContainer.prepend(logEl);
                });
                lastLogCount = state.gameLog.length;
            }
        }
        
        async function runSimulation() {
            // ** FIX: PROPERLY START THE FIRST TURN FOR PLAYER 1 **
            const firstPlayer = game.getCurrentPlayer();
            firstPlayer.readyAllCards();
            firstPlayer.draw(1);
            renderGameState(game.getGameState());
            await new Promise(resolve => setTimeout(resolve, 300));


            while(game.gameState === 'playing') {
                game.makeAIMove();
                renderGameState(game.getGameState());
                await new Promise(resolve => setTimeout(resolve, 300));
            }
        }

        startButton.addEventListener('click', () => {
            hideError(); // Hide previous errors
            const deck1Ids = parseDecklist(decklist1El.value);
            const deck2Ids = parseDecklist(decklist2El.value);
            
            if (deck1Ids && deck2Ids) {
                try {
                    game = new InkTableGame();
                    game.initGame(deck1Ids, deck2Ids);
                    lastLogCount = 0;
                    logEntriesContainer.innerHTML = '';
                    setupView.classList.add('hidden');
                    simulationView.classList.remove('hidden');
                    renderGameState(game.getGameState());
                    runSimulation();
                } catch(e) {
                    showError(e.message);
                    console.error(e);
                }
            }
        });

        // Initialize the app on load
        initialize();
    </script>
</body>
</html>

