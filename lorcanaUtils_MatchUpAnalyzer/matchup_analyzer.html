<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorcana Deck Matchup Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            /* Dark mode background */
            color: #e2e8f0;
            /* Light text for dark mode */
        }

        .card-image {
            width: 100px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }

        .card-image:hover {
            transform: scale(1.1);
        }

        .selectable-card {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .selectable-card:hover {
            background-color: #4a5568;
        }

        .selectable-card.selected {
            background-color: #667eea;
            box-shadow: 0 0 0 2px #a0aec0;
        }

        .selectable-card .card-name {
            font-size: 0.75rem;
            text-align: center;
            margin-top: 4px;
            color: #e2e8f0;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .card-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            background-color: #2d3748;
            /* Slightly lighter dark background for sections */
            border-radius: 8px;
            min-height: 100px;
            /* Adjusted min-height */
            align-items: flex-start;
            /* Align items to the top */
        }

        .analysis-section {
            /* Generic class for major sections */
            background-color: #222b3c;
            /* Slightly different dark for main sections */
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .outcome-section,
        .song-breakdown-section,
        .ability-impact-section,
        .location-interaction-subsection {
            /* Specific styling for subsections */
            background-color: #2d3748;
            padding: 12px;
            /* Slightly reduced padding */
            border-radius: 8px;
            margin-bottom: 12px;
            /* Reduced margin */
        }

        .section-title {
            /* For main section titles like "Character Matchups" */
            font-size: 1.5rem;
            /* Larger */
            font-weight: bold;
            color: #c3dafe;
            /* Light blueish */
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #4a5568;
        }

        .subsection-title {
            /* For titles within outcome/song sections */
            font-weight: bold;
            margin-bottom: 8px;
            color: #a0aec0;
            font-size: 1rem;
            /* Standardized size */
        }

        .ability-title {
            /* For individual ability names */
            font-weight: bold;
            color: #b0c4de;
            /* Lighter blue for ability names */
            margin-top: 10px;
            margin-bottom: 5px;
        }

        textarea {
            background-color: #2d3748;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 8px;
        }

        button {
            background-color: #4a5fa0;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #3c4b80;
        }

        select {
            background-color: #2d3748;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 8px;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            /* Increased width for more text */
            background-color: #374151;
            color: #e5e7eb;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            /* Increased padding */
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            /* Half of new width */
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            line-height: 1.4;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            white-space: pre-line;
            /* Allow newlines in tooltip */
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #374151 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Styling for radio buttons */
        .radio-label {
            margin-right: 10px;
            cursor: pointer;
        }

        .radio-label input[type="radio"] {
            margin-right: 5px;
        }
    </style>
</head>

<body class="p-4 md:p-8">

    <header class="text-center mb-8">
        <h1 class="text-3xl font-bold text-purple-400">Lorcana Matchup Analyzer</h1>
        <p class="text-sm text-gray-400">Analyze character trade values, song threats, and location vulnerabilities.</p>
    </header>

    <div id="loadingIndicator" class="text-center my-4">
        <div class="loading-spinner"></div>
        <p>Loading Card Data & Patterns...</p>
    </div>

    <main id="appContent" class="hidden">
        <section class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                <h2 class="text-xl font-semibold mb-2">Your Deck</h2>
                <textarea id="playerDeckInput" rows="10" class="w-full p-2"
                    placeholder="4 Card Name&#10;2 Another Card Name..."></textarea>
            </div>
            <div>
                <h2 class="text-xl font-semibold mb-2">Opponent's Deck</h2>
                <textarea id="opponentDeckInput" rows="10" class="w-full p-2"
                    placeholder="4 Card Name&#10;2 Another Card Name..."></textarea>
            </div>
        </section>

        <div class="text-center mb-6">
            <button id="analyzeButton" class="px-6 py-3">Load Decks & Analyze</button>
        </div>

        <section id="analysisControls" class="hidden mt-8 p-4 bg-gray-700 rounded-lg shadow-md">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                <div class="mb-4 sm:mb-0">
                    <span class="mr-2 font-semibold">Analysis Mode:</span>
                    <label class="radio-label"><input type="radio" name="analysisMode" value="character" checked> My
                        Character</label>
                    <label class="radio-label"><input type="radio" name="analysisMode" value="song"> My Song</label>
                </div>

                <div id="challengePerspectiveContainer">
                    <label for="turnContextSelect" class="mr-2 font-semibold">Challenge Perspective:</label>
                    <select id="turnContextSelect">
                        <option value="player">My Turn (I Challenge)</option>
                        <option value="opponent">Opponent's Turn (They Challenge)</option>
                    </select>
                </div>
            </div>
        </section>

        <section id="cardSelectionGrid" class="hidden mt-6">
            <h3 class="text-xl font-semibold mb-4 text-center" id="cardSelectionTitle">Select a Character to Analyze
            </h3>
            <div id="playerCardsGrid"
                class="grid grid-cols-12 md:grid-cols-20 lg:grid-cols-25 xl:grid-cols-20 gap-1 p-1 bg-gray-800 rounded-lg">
                <!-- Cards will be populated here -->
            </div>
        </section>

        <section id="resultsDisplay" class="mt-8">
        </section>
    </main>

    <script>
        // --- Globals ---
        let ALL_CARDS_DATA = null;
        let ALL_CARDS_MAP = new Map();
        let LORCANA_PATTERNS = {};
        let PLAYER_DECK_CHARS = [];
        let OPPONENT_DECK_CHARS = [];
        let PLAYER_DECK_SONGS = [];
        let OPPONENT_DECK_SONGS = [];
        let PLAYER_DECK_LOCATIONS = [];
        let OPPONENT_DECK_LOCATIONS = [];


        const CARD_DATA_URL = 'https://raw.githubusercontent.com/heavenideas/similcana/refs/heads/main/database/allCards.json';

        // Inlined patterns to prevent network errors
        const LORCANA_PATTERNS_TEXT = `
Lorcana Ability Patterns Export
============================

Pattern Name: Lore: Gain
Regex: /Gain (\\d+) ◊/gi
----------------------------------------

Pattern Name: Lore: Lose
Regex: /(chosen opponent(s?)|each opponent) loses (\\d+) ◊/gi
----------------------------------------

Pattern Name: Card Effect: Draw
Regex: /Draw (\\d+|a|one|two|three) card(s?)/gi
----------------------------------------

Pattern Name: Card Effect: Opponent Discards
Regex: /(chosen opponent|each opponent) discard(s)? (\\d+|a|one) card(s?)( at random)?/gi
----------------------------------------

Pattern Name: Card Effect: Self Discard
Regex: /discard (\\d+|a|one|two|three) card(s?)/gi
----------------------------------------

Pattern Name: Card Effect: Look at Deck
Regex: /Look at the top (\\d+|one|two|three|four|five) cards of your deck/gi
----------------------------------------

Pattern Name: Card Effect: Deck to Hand/Bottom
Regex: /put (?:one of them|a (?:character|item|action|song) card) into your hand and(?: put)? the rest on the bottom of your deck/gi
----------------------------------------

Pattern Name: Card Effect: Discard to Hand
Regex: /return a(nother)? (?:character|item|action|song|card)(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))? from your discard (?:pile )?to your hand/gi
----------------------------------------

Pattern Name: Card Effect: Discard to Deck
Regex: /shuffle a card from your discard into your deck/gi
----------------------------------------

Pattern Name: Card Effect: Look at Opponent's Hand
Regex: /Look at chosen opponent's hand/gi
----------------------------------------

Pattern Name: Card Effect: Hand to Inkwell
Regex: /put a card from your hand into your inkwell facedown( and undried)?/gi
----------------------------------------

Pattern Name: Bounce: Opposing Character
Regex: /Return chosen (?:opposing |opponent's )?(character|item|location|character or item|character, item or location)(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))? to (its|their|the) player's hand/gi
----------------------------------------

Pattern Name: Add to Inkwell: Opposing Character
Regex: /put chosen (?:opposing |opponent's )?(character|item|location|character or item|character, item or location)(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))? into (its|their|the) player's inkwell/gi
----------------------------------------

Pattern Name: Banish: Chosen Target
Regex: /Banish chosen (?:opposing |opponent's )?(character|item|location|character or item|character, item or location)(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))?/gi
----------------------------------------

Pattern Name: Banish: All Characters
Regex: /Banish all (opposing )?characters(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))?/gi
----------------------------------------

Pattern Name: Banish: This Character
Regex: /Banish (this |them )?character (?:of your)/gi
----------------------------------------

Pattern Name: Banish: Opponent's Choice
Regex: /((?:An|Each) opponent chooses and banishes one of their characters)/gi
----------------------------------------

Pattern Name: Banish: As a Cost/Choice
Regex: /You may banish (?:this character|one of your characters) to/gi
----------------------------------------

Pattern Name: Damage: Deal to One
Regex: /(Deal|move) (\\d+) damage to (chosen|another|another chosen) (?:opposing )?(character|location|item)(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))?/gi
----------------------------------------

Pattern Name: Damage: Deal to Many
Regex: /(Deal|move) (\\d+) damage to each opposing character/gi
----------------------------------------

Pattern Name: Damage: Deal Divided
Regex: /(Deal|move) (\\d+) damage divided as you choose among any number of chosen opposing characters/gi
----------------------------------------

Pattern Name: Damage: Heal
Regex: /Remove up to (\\d+) damage from (?:chosen )?(?:one of )?(?:your )?(character|location)/gi
----------------------------------------

Pattern Name: State: Ready Character
Regex: /Ready chosen (?:your |another )?(character|item)/gi
----------------------------------------

Pattern Name: State: Exert Character
Regex: /Exert chosen (?:opposing |opponent's )?(character|item)(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))?/gi
----------------------------------------

Pattern Name: State: Prevent Readying
Regex: /chosen (?:opposing )?character can't ready at the start of (?:their|your) next turn/gi
----------------------------------------

Pattern Name: Movement: To Location
Regex: /move (?:one of )?your characters to a location for free/gi
----------------------------------------

Pattern Name: Stat: Strength Buff
Regex: /(?:gets|has|gains) \\+(\\d+) ¤/gi
----------------------------------------

Pattern Name: Stat: Strength Debuff
Regex: /(?:gets|has) -(\\d+) ¤/gi
----------------------------------------

Pattern Name: Stat: Willpower Buff
Regex: /gains \\+(\\d+) ⛉/gi
----------------------------------------

Pattern Name: Stat: Cost Reduction
Regex: /pay (\\d+) ⬡ less/gi
----------------------------------------

Pattern Name: Play: From Discard
Regex: /You may play a (character|item) card(?: with \\d+ (?:¤|⬡|⛉) or (?:less|more))? from your discard/gi
----------------------------------------

Pattern Name: Play: For Free
Regex: /You may play a character with cost (\\d+) or less for free/gi
----------------------------------------

Pattern Name: Play: Cheaper
Regex: /The next time you play a (?:character|item|action|song) card this turn, pay (\\d+) ⬡ less/gi
----------------------------------------

Pattern Name: Trigger: On Play
Regex: /When you play this (?:character|item|action)/gi
----------------------------------------

Pattern Name: Trigger: On Quest
Regex: /Whenever this character quests/gi
----------------------------------------

Pattern Name: Trigger: On Banish (Self)
Regex: /When this character is banished/gi
----------------------------------------

Pattern Name: Trigger: On Banish (Other)
Regex: /Whenever (?:another|a|one of your other|an opposing) character is banished/gi
----------------------------------------

Pattern Name: Trigger: On Banish (in Challenge)
Regex: /Whenever (?:this character is banished in a challenge|an opposing character is banished in a challenge)/gi
----------------------------------------

Pattern Name: Trigger: On Being Challenged
Regex: /Whenever this character is challenged/gi
----------------------------------------

Pattern Name: Trigger: On Challenging
Regex: /When this character challenges/gi
----------------------------------------

Pattern Name: Trigger: Start of Turn
Regex: /At the start of your turn/gi
----------------------------------------

Pattern Name: Trigger: End of Turn
Regex: /At the end of your turn/gi
----------------------------------------

Pattern Name: Keyword: Evasive
Regex: /\\b(Evasive)\\b/gi
----------------------------------------

Pattern Name: Keyword: Rush
Regex: /\\b(Rush)\\b/gi
----------------------------------------

Pattern Name: Keyword: Ward
Regex: /\\b(Ward)\\b/gi
----------------------------------------

Pattern Name: Keyword: Bodyguard
Regex: /\\b(Bodyguard)\\b/gi
----------------------------------------

Pattern Name: Keyword: Challenger
Regex: /(Challenger \\+\\d+)/gi
----------------------------------------

Pattern Name: Keyword: Resist
Regex: /(Resist \\+\\d+)/gi
----------------------------------------

Pattern Name: Keyword: Shift
Regex: /(Shift (?:\\d+|an? .*?|into this character))/gi
----------------------------------------

Pattern Name: Keyword: Support
Regex: /\\b(Support)\\b/gi
----------------------------------------

Pattern Name: Keyword: Singer
Regex: /\\b(Singer \\d+)\\b/gi
----------------------------------------

Pattern Name: Keyword: Reckless
Regex: /\\b(Reckless)\\b/gi
----------------------------------------

Pattern Name: Static: Cannot Be Challenged
Regex: /This character can't be challenged( except by characters with (?:Rush|Evasive))?/gi
----------------------------------------

Pattern Name: Static: Cannot Quest
Regex: /This character can't quest/gi
----------------------------------------

Pattern Name: Static: Must Challenge
Regex: /must challenge if able/gi
----------------------------------------
`;


        const DEFAULT_PLAYER_DECK = `4 Diablo - Obedient Raven
4 Fairy Ship - Royal Vessel
4 Chernabog's Followers - Creatures of Evil
4 Kuzco - Wanted Llama
4 The Library - A Gift for Belle
4 Madam Mim - Fox
3 Merlin - Crab
4 Friends on the Other Side
4 Brawl
2 The Queen's Castle - Mirror Chamber
4 Merlin - Goat
2 Merlin - Rabbit
3 Genie - Wish Fulfilled
3 Be Prepared
2 Peter Pan - Shadow Finder
2 Elsa - The Fifth Spirit
2 Madam Mim - Snake
1 Madame Medusa - The Boss
2 Maui - Half-Shark
2 Lady Tremaine - Imperious Queen`;

        const DEFAULT_OPPONENT_DECK = `4 Diablo - Maleficent's Spy
3 Morph - Space Goo
4 Sudden Chill
4 Ursula - Deceiver
4 Pete - Games Referee
4 Diablo - Devoted Herald
4 Ursula - Deceiver of All
4 Hypnotize
3 Prince John - Greediest of All
4 Strength of a Raging Fire
3 Let the Storm Rage On
3 The Muses - Proclaimers of Heroes
4 We Don't Talk About Bruno
3 Beast - Tragic Hero
3 Beyond the Horizon
3 Pete - Space Pirate
2 Hidden Cove - Tranquil Haven
1 Namaari - Single-Minded Rival`;

        // --- DOM Elements ---
        const loadingIndicator = document.getElementById('loadingIndicator');
        const appContent = document.getElementById('appContent');
        const playerDeckInput = document.getElementById('playerDeckInput');
        const opponentDeckInput = document.getElementById('opponentDeckInput');
        const analyzeButton = document.getElementById('analyzeButton');
        const analysisControls = document.getElementById('analysisControls');
        const cardSelectionGrid = document.getElementById('cardSelectionGrid');
        const cardSelectionTitle = document.getElementById('cardSelectionTitle');
        const playerCardsGrid = document.getElementById('playerCardsGrid');

        const analysisModeRadios = document.querySelectorAll('input[name="analysisMode"]');
        const challengePerspectiveContainer = document.getElementById('challengePerspectiveContainer');

        const turnContextSelect = document.getElementById('turnContextSelect');
        const resultsDisplay = document.getElementById('resultsDisplay');

        // --- Selection State ---
        let selectedCardIndex = -1;
        let selectedCardType = null; // 'character' or 'song'

        // --- Initialization ---
        async function initializeApp() {
            console.log("Initializing app...");
            try {
                // Fetch card data
                const cardsResponse = await fetch(CARD_DATA_URL);

                if (!cardsResponse.ok) throw new Error(`HTTP error! status: ${cardsResponse.status}`);
                ALL_CARDS_DATA = await cardsResponse.json();
                console.log("Card data fetched successfully:", ALL_CARDS_DATA.cards.length, "cards loaded.");

                ALL_CARDS_DATA.cards.forEach(card => {
                    ALL_CARDS_MAP.set(card.fullName, card);
                    if (card.simpleName && card.simpleName !== card.fullName) {
                        ALL_CARDS_MAP.set(card.simpleName, card);
                    }
                });
                console.log("ALL_CARDS_MAP populated with", ALL_CARDS_MAP.size, "entries.");

                // Parse the inline patterns, removing the failing network request
                parseAndStorePatterns(LORCANA_PATTERNS_TEXT);

                loadingIndicator.classList.add('hidden');
                appContent.classList.remove('hidden');

                playerDeckInput.value = DEFAULT_PLAYER_DECK;
                opponentDeckInput.value = DEFAULT_OPPONENT_DECK;
                console.log("Default decklists set.");

                analyzeButton.addEventListener('click', handleAnalyzeButtonClick);
                turnContextSelect.addEventListener('change', displayAnalysisResults);

                analysisModeRadios.forEach(radio => {
                    radio.addEventListener('change', handleAnalysisModeChange);
                });
                console.log("Event listeners attached.");

            } catch (error) {
                console.error("Error during app initialization:", error);
                loadingIndicator.innerHTML = `<p class="text-red-500">Error loading data. Please try refreshing. Details: ${error.message}</p>`;
            }
        }

        // --- Pattern Parsing ---
        function parseAndStorePatterns(text) {
            const patternBlocks = text.split('----------------------------------------').map(s => s.trim()).filter(Boolean);
            patternBlocks.forEach(block => {
                const nameMatch = block.match(/Pattern Name: (.*)/);
                const regexMatch = block.match(/Regex: \/(.*)\/(.*)/);

                if (nameMatch && regexMatch) {
                    const fullName = nameMatch[1].trim();
                    const [category, name] = fullName.split(': ');
                    const regexString = regexMatch[1];
                    const flags = regexMatch[2]; // Includes 'g' and 'i'

                    if (!LORCANA_PATTERNS[category]) {
                        LORCANA_PATTERNS[category] = [];
                    }

                    LORCANA_PATTERNS[category].push({
                        name: name,
                        fullName: fullName,
                        regex: new RegExp(regexString, flags) // The 'i' flag makes it case-insensitive
                    });
                }
            });
            console.log("Lorcana patterns parsed and stored:", LORCANA_PATTERNS);
        }

        // --- Deck Parsing ---
        function parseDeckString(deckString) {
            console.log("Parsing deck string:", deckString.substring(0, 50) + "...");
            const lines = deckString.trim().split('\n');
            const characters = [];
            const songs = [];
            const locations = []; // Added for locations
            const uniqueCharNames = new Set();
            const uniqueSongNames = new Set();
            const uniqueLocationNames = new Set(); // Added for locations


            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                const match = line.match(/^(\d+)\s+(.+)/);
                if (match) {
                    const count = parseInt(match[1], 10);
                    const cardName = match[2].trim();
                    const cardData = ALL_CARDS_MAP.get(cardName);

                    if (cardData) {
                        if (cardData.type === 'Character') {
                            if (!uniqueCharNames.has(cardData.fullName)) {
                                characters.push({ cardInfo: cardData, count: count });
                                uniqueCharNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Action' && cardData.subtypes?.includes('Song')) {
                            if (!uniqueSongNames.has(cardData.fullName)) {
                                songs.push({ cardInfo: cardData, count: count });
                                uniqueSongNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Location') { // Added location check
                            if (!uniqueLocationNames.has(cardData.fullName)) {
                                locations.push({ cardInfo: cardData, count: count });
                                uniqueLocationNames.add(cardData.fullName);
                            }
                        }
                    } else {
                        console.warn(`Card not found during parsing: ${cardName}`);
                    }
                } else {
                    console.warn(`Invalid deck line format during parsing: ${line}`);
                }
            });
            const parsedResult = {
                characters: Array.from(uniqueCharNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })),
                songs: Array.from(uniqueSongNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })),
                locations: Array.from(uniqueLocationNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })) // Added locations
            };
            console.log("Deck parsed. Characters:", parsedResult.characters.length, "Songs:", parsedResult.songs.length, "Locations:", parsedResult.locations.length);
            return parsedResult;
        }

        // --- Keyword Extraction ---
        function extractCharacterKeywords(card) {
            const keywords = { Resist: 0, Challenger: 0, Evasive: false, Ward: false };
            const otherKeywords = ['support', 'bodyguard', 'reckless', 'singer'];

            if (card.abilities && Array.isArray(card.abilities)) {
                card.abilities.forEach(ability => {
                    if (ability.type === 'keyword') {
                        const lowerKeyword = ability.keyword.toLowerCase();
                        if (lowerKeyword === 'resist') keywords.Resist = ability.keywordValueNumber || 0;
                        else if (lowerKeyword === 'challenger') keywords.Challenger = ability.keywordValueNumber || 0;
                        else if (lowerKeyword === 'evasive') keywords.Evasive = true;
                        else if (lowerKeyword === 'ward') keywords.Ward = true;
                        else if (otherKeywords.includes(lowerKeyword)) {
                            keywords[ability.keyword.toLowerCase()] = true;
                        }
                    }
                });
            }
            if (card.subtypes && Array.isArray(card.subtypes)) {
                card.subtypes.forEach(subtype => {
                    keywords[subtype.toLowerCase()] = true;
                });
            }
            return keywords;
        }

        // --- Banish Condition Checker ---
        function checkBanishConditions(pattern, match, targetCharacterCard, abilityText) {
            console.log(`Checking banish conditions for pattern: ${pattern.name}, target: ${targetCharacterCard.fullName}, ability: ${abilityText.substring(0, 50)}...`);

            // Handle special cases that don't target opponent characters
            if (pattern.name === 'This Character') {
                return {
                    canBanish: false,
                    details: `'${pattern.name}' only affects the source character, not opponent characters.`
                };
            }

            if (pattern.name === 'As a Cost/Choice') {
                return {
                    canBanish: false,
                    details: `'${pattern.name}' is a cost/choice effect, not targeting opponent characters.`
                };
            }

            if (pattern.name === "Opponent's Choice") {
                return {
                    canBanish: false,
                    details: `'${pattern.name}' lets opponent choose their own character to banish.`
                };
            }

            const targetCharStrength = targetCharacterCard.strength || 0;
            const targetCharWillpower = targetCharacterCard.willpower || 0;
            const targetCharCost = targetCharacterCard.cost || 0;

            // Extract the condition part from the ability text
            const conditionMatch = abilityText.match(/with (\d+) (¤|⬡|⛉) or (less|more)/i);

            if (!conditionMatch) {
                // No specific condition - can banish any character
                console.log(`No condition found, can banish any character`);
                return {
                    canBanish: true,
                    details: `Can banish any character via '${pattern.name}'.`
                };
            }

            const conditionValue = parseInt(conditionMatch[1], 10);
            const statType = conditionMatch[2]; // ¤ (strength), ⬡ (cost), ⛉ (willpower)
            const comparison = conditionMatch[3]; // "less" or "more"

            console.log(`Condition found: ${conditionValue} ${statType} or ${comparison}`);

            let targetStat;
            let statName;

            switch (statType) {
                case '¤': // Strength
                    targetStat = targetCharStrength;
                    statName = 'strength';
                    break;
                case '⬡': // Cost
                    targetStat = targetCharCost;
                    statName = 'cost';
                    break;
                case '⛉': // Willpower
                    targetStat = targetCharWillpower;
                    statName = 'willpower';
                    break;
                default:
                    // Unknown stat type, assume it can banish
                    return {
                        canBanish: true,
                        details: `Can banish via '${pattern.name}' (unknown stat condition).`
                    };
            }

            let canBanish;
            if (comparison === 'less') {
                canBanish = targetStat <= conditionValue;
            } else if (comparison === 'more') {
                canBanish = targetStat >= conditionValue;
            } else {
                // Unknown comparison, assume it can banish
                canBanish = true;
            }

            console.log(`Target has ${statName} ${targetStat}, condition: ${comparison} than ${conditionValue}, canBanish: ${canBanish}`);

            if (canBanish) {
                return {
                    canBanish: true,
                    details: `Can banish character with ${statName} ${comparison} than or equal to ${conditionValue} (target has ${targetStat}).`
                };
            } else {
                return {
                    canBanish: false,
                    details: `Cannot banish character with ${statName} ${comparison} than or equal to ${conditionValue} (target has ${targetStat}).`
                };
            }
        }

        // --- Matchup Calculation (Characters) ---
        function calculateSingleMatchup(playerCharData, opponentCharData, turnType) {
            const pKeywords = extractCharacterKeywords(playerCharData);
            const oKeywords = extractCharacterKeywords(opponentCharData);
            let pStrength = playerCharData.strength || 0;
            const pWillpower = playerCharData.willpower || 0;
            const pCost = playerCharData.cost || 0;
            let oStrength = opponentCharData.strength || 0;
            const oWillpower = opponentCharData.willpower || 0;
            const oCost = opponentCharData.cost || 0;

            if (turnType === 'player' && oKeywords.Evasive && !pKeywords.Evasive) return { outcomeName: "NoInteraction_OpponentEvasive", classification: "Neutral", details: "Opponent is Evasive" };
            if (turnType === 'opponent' && pKeywords.Evasive && !oKeywords.Evasive) return { outcomeName: "NoInteraction_PlayerEvasive", classification: "Neutral", details: "Your character is Evasive" };

            if (turnType === 'player' && pKeywords.Challenger > 0) pStrength += pKeywords.Challenger;
            if (turnType === 'opponent' && oKeywords.Challenger > 0) oStrength += oKeywords.Challenger;

            let damageToPlayer = Math.max(0, oStrength - pKeywords.Resist);
            let damageToOpponent = Math.max(0, pStrength - oKeywords.Resist);

            const playerBanished = damageToPlayer >= pWillpower;
            const opponentBanished = damageToOpponent >= oWillpower;

            let result;
            if (playerBanished && opponentBanished) {
                const inkDiff = oCost - pCost;
                let classification = "Neutral";
                if (inkDiff >= 2) classification = "Positive";
                else if (inkDiff <= -2) classification = "Negative";
                result = { outcomeName: "BothBanished", classification, details: `Ink Diff (Opp-Player): ${inkDiff}` };
            } else if (!opponentBanished && playerBanished) {
                result = { outcomeName: "OpponentSurvives_PlayerBanished", classification: "Negative", details: "Your character banished" };
            } else if (opponentBanished && !playerBanished) {
                result = { outcomeName: "PlayerSurvives_OpponentBanished", classification: "Positive", details: "Opponent character banished" };
            } else if (!opponentBanished && !playerBanished) {
                result = { outcomeName: "BothSurvive", classification: "Neutral", details: "Stalemate, both survive" };
            } else {
                result = { outcomeName: "Unknown", classification: "Neutral", details: "Error in logic" };
            }
            return result;
        }

        // --- Generic Ability/Effect Interaction Analysis (Refactored) ---
        function classifyAbilityEffectOnTarget(sourceCardInfo, abilityText, targetCharacterCard, sourceIsPlayerPerspective) {
            const cleanedAbilityText = (abilityText || "").replace(/\n/g, ' ').trim();
            if (!cleanedAbilityText) {
                return { classification: "NoInteraction", details: "No ability text.", card: sourceCardInfo };
            }

            const targetCharKeywords = extractCharacterKeywords(targetCharacterCard);
            const targetCharWillpower = targetCharacterCard.willpower || 0;

            // Ward Check: Ward protects from being CHOSEN, except by effects that say "each" or "all".
            const isSingleTarget = cleanedAbilityText.toLowerCase().includes('chosen');
            if (targetCharKeywords.Ward && isSingleTarget) {
                return { classification: "NoInteractionDueToWard", details: "Target character has Ward, protected from 'chosen' effects.", card: sourceCardInfo };
            }

            for (const category in LORCANA_PATTERNS) {
                for (const pattern of LORCANA_PATTERNS[category]) {
                    const match = cleanedAbilityText.match(pattern.regex);
                    if (match) {
                        // We have a match, now we interpret it based on the category and name
                        switch (category) {
                            case 'Banish':
                                console.log(`Banish match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                // Check specific banish conditions against target character
                                const banishResult = checkBanishConditions(pattern, match, targetCharacterCard, cleanedAbilityText);
                                if (banishResult.canBanish) {
                                    console.log(`Banish result: ${banishResult.details}`);
                                    return { classification: "DirectRemoval", details: banishResult.details, card: sourceCardInfo };
                                } else {
                                    return { classification: "NoInteraction", details: banishResult.details, card: sourceCardInfo };
                                }

                            case 'Damage':
                                console.log(`Damage match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                const damageAmount = parseInt(match[1], 10) || 0;
                                console.log(`Damage amount: ${damageAmount}`);
                                if (damageAmount > 0) {
                                    if (damageAmount >= targetCharWillpower) {
                                        return { classification: "DirectRemoval", details: `Deals ${damageAmount} damage (lethal).`, card: sourceCardInfo };
                                    } else {
                                        return { classification: "PotentialRemoval", details: `Deals ${damageAmount} damage.`, card: sourceCardInfo };
                                    }
                                }
                                break; // Continue if damage amount is not clear
                            case 'Bounce':
                                console.log(`Bounce match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                return { classification: "DirectRemoval", details: `Bounces ${pattern.name}.`, card: sourceCardInfo };
                            case 'Add to Inkwell':
                                console.log(`Add to Inkwell match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName} `);
                                return { classification: "DirectRemoval", details: `Adds to Inkwell ${pattern.name}.`, card: sourceCardInfo };
                            case 'State':
                                // These affect the character but don't remove it
                                return { classification: "AffectsNoRemoval", details: `Matched '${pattern.fullName}'.`, card: sourceCardInfo };

                            case 'Static':
                                if (pattern.name.includes('Cannot Be Challenged')) {
                                    return { classification: "AffectsNoRemoval", details: `Cannot be challenged.`, card: sourceCardInfo };
                                }
                                break;
                        }
                    }
                }
            }

            // Fallback for text that doesn't match a specific pattern but might still be relevant
            // const genericTargeting = /character|item|location/i;
            // if (genericTargeting.test(cleanedAbilityText)) {
            //     return { classification: "PotentialRemoval", details: "Targets character with an unclassified effect.", card: sourceCardInfo };
            // }

            return { classification: "NoInteraction", details: "Effect does not appear to target characters.", card: sourceCardInfo };
        }

        // --- Location Interaction Analysis (Refactored) ---
        function classifyLocationInteraction(sourceCardInfo, abilityText, sourceIsPlayerPerspective) {
            const cleanedAbilityText = (abilityText || "").replace(/\n/g, ' ').trim();
            if (!cleanedAbilityText) return null;

            const banishPatterns = LORCANA_PATTERNS['Banish'] || [];
            const damagePatterns = LORCANA_PATTERNS['Damage'] || [];

            for (const pattern of banishPatterns) {
                if (pattern.regex.test(cleanedAbilityText) && cleanedAbilityText.toLowerCase().includes('location')) {
                    return { canInteract: true, interactionType: "Banish", details: `Can banish a location via '${pattern.name}'.`, card: sourceCardInfo };
                }
            }
            for (const pattern of damagePatterns) {
                if (pattern.regex.test(cleanedAbilityText) && cleanedAbilityText.toLowerCase().includes('location')) {
                    return { canInteract: true, interactionType: "Damage", details: `Can damage a location via '${pattern.name}'.`, card: sourceCardInfo };
                }
            }

            // Generic fallback
            if (cleanedAbilityText.toLowerCase().includes('chosen location')) {
                return { canInteract: true, interactionType: "Target", details: "Can target a location.", card: sourceCardInfo };
            }

            return null;
        }


        function getActiveAbilitiesForCharacter(characterCard, analysisContext) {
            const activeAbilities = [];
            if (!characterCard.abilities || !Array.isArray(characterCard.abilities)) {
                return activeAbilities;
            }

            characterCard.abilities.forEach(ability => {
                const cleanedFullText = (ability.fullText || "").replace(/\n/g, ' ');
                const abilityTextLower = cleanedFullText.toLowerCase();
                let isRelevant = false;

                // For this tool, we consider most abilities potentially active to analyze their text.
                // A more sophisticated logic could be added here based on triggers.
                // We will use the trigger patterns to refine this.
                const triggerPatterns = LORCANA_PATTERNS['Trigger'] || [];
                let hasTrigger = false;

                for (const pattern of triggerPatterns) {
                    if (pattern.regex.test(cleanedFullText)) {
                        hasTrigger = true;
                        if (analysisContext.perspective === "playerTurn") {
                            if (pattern.name.includes('On Play') || pattern.name.includes('On Challenging') || pattern.name.includes('On Quest') || pattern.name.includes('Start of Turn')) {
                                isRelevant = true;
                                break;
                            }
                        } else { // Opponent's turn
                            if (pattern.name.includes('On Being Challenged') || pattern.name.includes('Start of Turn')) { // Opponent's start of turn
                                isRelevant = true;
                                break;
                            }
                        }
                    }
                }

                // If it's a static ability or has no specific trigger, we assume it's always active for analysis.
                if (ability.type === 'static' || !hasTrigger) {
                    isRelevant = true;
                }

                if (isRelevant && ability.fullText) {
                    activeAbilities.push({ text: cleanedFullText, name: ability.name || "Unnamed Ability" });
                }
            });
            return activeAbilities;
        }

        // --- Event Handlers & UI Updates ---
        function populateCardGrid() {
            playerCardsGrid.innerHTML = '';
            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;

            let cardsToShow = [];
            if (selectedMode === 'character') {
                cardsToShow = PLAYER_DECK_CHARS;
                cardSelectionTitle.textContent = 'Select a Character to Analyze';
            } else {
                cardsToShow = PLAYER_DECK_SONGS;
                cardSelectionTitle.textContent = 'Select a Song to Analyze';
            }

            if (cardsToShow.length === 0) {
                playerCardsGrid.innerHTML = `<p class="text-center text-gray-400 italic col-span-full">No ${selectedMode}s in your deck.</p>`;
                return;
            }

            cardsToShow.forEach((cardEntry, index) => {
                const card = cardEntry.cardInfo;
                const cardElement = document.createElement('div');
                cardElement.className = 'selectable-card';
                cardElement.dataset.index = index;
                cardElement.dataset.type = selectedMode;

                const img = document.createElement('img');
                img.src = card.images?.thumbnail || `https://placehold.co/100x140/2d3748/e2e8f0?text=${card.name.substring(0, 10)}`;
                img.alt = card.fullName;
                img.className = 'card-image';
                img.onerror = () => { img.src = `https://placehold.co/100x140/2d3748/e2e8f0?text=Error`; };

                const nameElement = document.createElement('div');
                nameElement.className = 'card-name';
                nameElement.textContent = card.name;

                cardElement.appendChild(img);
                cardElement.appendChild(nameElement);

                // Add click handler
                cardElement.addEventListener('click', () => {
                    // Remove previous selection
                    const previouslySelected = playerCardsGrid.querySelector('.selectable-card.selected');
                    if (previouslySelected) {
                        previouslySelected.classList.remove('selected');
                    }

                    // Select this card
                    cardElement.classList.add('selected');
                    selectedCardIndex = index;
                    selectedCardType = selectedMode;

                    // Trigger analysis
                    displayAnalysisResults();
                });

                playerCardsGrid.appendChild(cardElement);
            });
        }

        function handleAnalysisModeChange() {
            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;
            console.log("Analysis mode changed to:", selectedMode);

            // Reset selection when mode changes
            selectedCardIndex = -1;
            selectedCardType = null;

            // Update challenge perspective visibility
            if (selectedMode === 'character') {
                challengePerspectiveContainer.classList.remove('hidden');
            } else { // song mode
                challengePerspectiveContainer.classList.add('hidden');
            }

            // Repopulate grid with new card type
            if (cardSelectionGrid.classList.contains('hidden') === false) {
                populateCardGrid();
            }

            // Clear results
            resultsDisplay.innerHTML = '';
        }

        function handleAnalyzeButtonClick() {
            console.log("Analyze button clicked.");
            const playerData = parseDeckString(playerDeckInput.value);
            PLAYER_DECK_CHARS = playerData.characters;
            PLAYER_DECK_SONGS = playerData.songs;
            PLAYER_DECK_LOCATIONS = playerData.locations;


            const opponentData = parseDeckString(opponentDeckInput.value);
            OPPONENT_DECK_CHARS = opponentData.characters;
            OPPONENT_DECK_SONGS = opponentData.songs;
            OPPONENT_DECK_LOCATIONS = opponentData.locations;

            console.log("Decks loaded. Player Chars:", PLAYER_DECK_CHARS.length, "Player Songs:", PLAYER_DECK_SONGS.length, "Player Locations:", PLAYER_DECK_LOCATIONS.length);
            console.log("Opponent Chars:", OPPONENT_DECK_CHARS.length, "Opponent Songs:", OPPONENT_DECK_SONGS.length, "Opponent Locations:", OPPONENT_DECK_LOCATIONS.length);

            // Reset selection state
            selectedCardIndex = -1;
            selectedCardType = null;

            // Populate the card grid
            populateCardGrid();

            analysisControls.classList.remove('hidden');
            cardSelectionGrid.classList.remove('hidden');
            handleAnalysisModeChange();
        }

        function displayAnalysisResults() {
            console.log("Displaying analysis results...");
            resultsDisplay.innerHTML = '';

            // Check if a card is selected
            if (selectedCardIndex === -1 || selectedCardType === null) {
                resultsDisplay.innerHTML = `<p class="text-center text-gray-400 italic">Please select a card from the grid above to analyze.</p>`;
                return;
            }

            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;
            console.log("Current analysis mode for display:", selectedMode);

            if (selectedMode === 'character') {
                displayCharacterAnalysis();
            } else {
                displayPlayerSongAnalysis();
            }
            // Always display location analysis regardless of character/song mode, if decks are loaded
            if (PLAYER_DECK_CHARS.length > 0 || PLAYER_DECK_SONGS.length > 0 || OPPONENT_DECK_CHARS.length > 0 || OPPONENT_DECK_SONGS.length > 0) {
                displayLocationInteractionAnalysis();
            }
        }

        function displayCharacterAnalysis() {
            console.log("Displaying Character Analysis.");
            if (PLAYER_DECK_CHARS.length === 0 || selectedCardIndex === -1 || selectedCardType !== 'character') {
                resultsDisplay.innerHTML += `<p class="text-center text-gray-400 italic">Please load decks and select a character to analyze.</p>`;
                return;
            }

            const playerCharEntry = PLAYER_DECK_CHARS[selectedCardIndex];
            if (!playerCharEntry) {
                resultsDisplay.innerHTML += `<p class="text-yellow-400 text-center">Invalid character selection.</p>`;
                console.warn("Invalid player character selection index:", selectedCardIndex);
                return;
            }
            const playerChar = playerCharEntry.cardInfo;
            const turnType = turnContextSelect.value;
            console.log(`Analyzing player character: ${playerChar.fullName}, Turn type: ${turnType}`);

            const overallAnalysisContainer = document.createElement('div');

            const playerCharDisplay = document.createElement('div');
            playerCharDisplay.className = 'text-center mb-6 pb-4 border-b border-gray-700';
            const pKeywords = extractCharacterKeywords(playerChar);
            let pKeywordStr = Object.entries(pKeywords)
                .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                .map(([key, value]) => {
                    if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                    return key.charAt(0).toUpperCase() + key.slice(1);
                }).join(', ');
            if (!pKeywordStr) pKeywordStr = 'No notable keywords/subtypes';

            playerCharDisplay.innerHTML = `
                <h2 class="text-2xl font-bold text-purple-300 mb-2">Analysis for Your Character: ${playerChar.fullName}</h2>
                <img src="${playerChar.images?.thumbnail || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Img'}" alt="${playerChar.fullName}" class="card-image mx-auto mb-2">
                <p class="text-sm text-gray-300">Cost: ${playerChar.cost || 'N/A'} | Str: ${playerChar.strength || 'N/A'} | Wp: ${playerChar.willpower || 'N/A'} | Lore: ${playerChar.lore || '0'}</p>
                <p class="text-xs text-gray-400">${pKeywordStr}</p>
            `;
            overallAnalysisContainer.appendChild(playerCharDisplay);

            // Character Matchups Section
            const charMatchupSection = document.createElement('section');
            charMatchupSection.className = 'analysis-section';
            const charMatchupTitle = document.createElement('h3');
            charMatchupTitle.className = 'section-title';
            charMatchupTitle.textContent = "Character Matchups (vs Opponent's Characters)";
            charMatchupSection.appendChild(charMatchupTitle);

            if (OPPONENT_DECK_CHARS.length > 0) {
                const analysisResults = { noInteraction: [], bothBanishedPositive: [], bothBanishedNeutral: [], bothBanishedNegative: [], opponentSurvivesPlayerBanished: [], playerSurvivesOpponentBanished: [], bothSurvive: [] };
                OPPONENT_DECK_CHARS.forEach(opponentCharEntry => {
                    const matchup = calculateSingleMatchup(playerChar, opponentCharEntry.cardInfo, turnType);
                    const opponentCard = opponentCharEntry.cardInfo;
                    if (matchup.outcomeName.startsWith("NoInteraction")) analysisResults.noInteraction.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "BothBanished") {
                        if (matchup.classification === "Positive") analysisResults.bothBanishedPositive.push({ card: opponentCard, details: matchup.details });
                        else if (matchup.classification === "Negative") analysisResults.bothBanishedNegative.push({ card: opponentCard, details: matchup.details });
                        else analysisResults.bothBanishedNeutral.push({ card: opponentCard, details: matchup.details });
                    }
                    else if (matchup.outcomeName === "OpponentSurvives_PlayerBanished") analysisResults.opponentSurvivesPlayerBanished.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "PlayerSurvives_OpponentBanished") analysisResults.playerSurvivesOpponentBanished.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "BothSurvive") analysisResults.bothSurvive.push({ card: opponentCard, details: matchup.details });
                });

                const charGrid = document.createElement('div');
                charGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';
                charGrid.appendChild(createOutcomeSectionDOM("CAN'T CHALLENGE/BE CHALLENGED BY", analysisResults.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-600'));
                charGrid.appendChild(createOutcomeSectionDOM("FAVORABLE (Player Survives, Opp Banished)", analysisResults.playerSurvivesOpponentBanished, OPPONENT_DECK_CHARS.length, 'bg-green-700'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Favorable Ink)", analysisResults.bothBanishedPositive, OPPONENT_DECK_CHARS.length, 'bg-green-600'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Neutral Ink)", analysisResults.bothBanishedNeutral, OPPONENT_DECK_CHARS.length, 'bg-yellow-600'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Unfavorable Ink)", analysisResults.bothBanishedNegative, OPPONENT_DECK_CHARS.length, 'bg-red-600'));
                charGrid.appendChild(createOutcomeSectionDOM("UNFAVORABLE (Opp Survives, Player Banished)", analysisResults.opponentSurvivesPlayerBanished, OPPONENT_DECK_CHARS.length, 'bg-red-700'));
                charGrid.appendChild(createOutcomeSectionDOM("STALEMATE (Both Survive Challenge)", analysisResults.bothSurvive, OPPONENT_DECK_CHARS.length, 'bg-blue-600'));
                charMatchupSection.appendChild(charGrid);
            } else {
                charMatchupSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters loaded for matchup analysis.</p>`;
            }
            overallAnalysisContainer.appendChild(charMatchupSection);

            // Player Character's Abilities Impact Section
            if (turnType === "player") {
                const playerAbilitiesSection = document.createElement('section');
                playerAbilitiesSection.className = 'analysis-section';
                const playerAbilitiesTitle = document.createElement('h3');
                playerAbilitiesTitle.className = 'section-title';
                playerAbilitiesTitle.textContent = `Your "${playerChar.name}" Abilities vs Opponent's Characters`;
                playerAbilitiesSection.appendChild(playerAbilitiesTitle);
                console.log(`Analyzing abilities for ${playerChar.name} on player's turn.`);

                const activePlayerAbilities = getActiveAbilitiesForCharacter(playerChar, { perspective: "playerTurn", action: "onPlayOrChallenge" });
                if (activePlayerAbilities.length > 0 && OPPONENT_DECK_CHARS.length > 0) {
                    activePlayerAbilities.forEach(ability => {
                        console.log(`Processing ability: ${ability.name}`);
                        const abilityImpactTitle = document.createElement('h4');
                        abilityImpactTitle.className = 'ability-title';
                        abilityImpactTitle.textContent = `Ability: ${ability.name}`;
                        playerAbilitiesSection.appendChild(abilityImpactTitle);

                        const abilityImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                        OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                            const classificationResult = classifyAbilityEffectOnTarget(playerChar, ability.text, oppCharEntry.cardInfo, true);
                            const displayItem = {
                                card: oppCharEntry.cardInfo,
                                details: classificationResult.details,
                                classification: classificationResult.classification,
                            };
                            if (classificationResult.classification === "DirectRemoval") abilityImpactOnOppChars.directRemoval.push(displayItem);
                            else if (classificationResult.classification === "PotentialRemoval") abilityImpactOnOppChars.potentialRemoval.push(displayItem);
                            else if (classificationResult.classification === "AffectsNoRemoval") abilityImpactOnOppChars.affectsNoRemoval.push(displayItem);
                            else abilityImpactOnOppChars.noInteraction.push(displayItem);
                        });
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Directly Removes Opp Chars (via ${ability.name})`, abilityImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-800', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Potentially Removes Opp Chars (via ${ability.name})`, abilityImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-700 text-black', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Affects Opp Chars (No Direct Removal via ${ability.name})`, abilityImpactOnOppChars.affectsNoRemoval, OPPONENT_DECK_CHARS.length, 'bg-teal-800', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`No Interaction with Opp Chars / Warded (via ${ability.name})`, abilityImpactOnOppChars.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-700', playerChar, ability.name));
                    });
                } else if (activePlayerAbilities.length === 0) {
                    playerAbilitiesSection.innerHTML += `<p class="text-center text-gray-400 italic">Your selected character has no relevant active abilities for this turn context.</p>`;
                } else {
                    playerAbilitiesSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters to analyze abilities against.</p>`;
                }
                overallAnalysisContainer.appendChild(playerAbilitiesSection);
            }


            // Opponent's Song Interaction Section
            const opponentSongSection = document.createElement('section');
            opponentSongSection.className = 'analysis-section';
            const opponentSongTitle = document.createElement('h3');
            opponentSongTitle.className = 'section-title';
            opponentSongTitle.textContent = `Opponent's Song Threats vs Your ${playerChar.name}`;
            opponentSongSection.appendChild(opponentSongTitle);
            console.log(`Analyzing opponent songs vs ${playerChar.name}`);

            if (OPPONENT_DECK_SONGS.length > 0) {
                const songAnalysis = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                OPPONENT_DECK_SONGS.forEach(songEntry => {
                    const songFullText = songEntry.cardInfo.effects?.join(' ') || songEntry.cardInfo.fullText || "";
                    const result = classifyAbilityEffectOnTarget(songEntry.cardInfo, songFullText, playerChar, false);
                    if (result.classification === "DirectRemoval") songAnalysis.directRemoval.push(result);
                    else if (result.classification === "PotentialRemoval") songAnalysis.potentialRemoval.push(result);
                    else if (result.classification === "AffectsNoRemoval") songAnalysis.affectsNoRemoval.push(result);
                    else songAnalysis.noInteraction.push(result);
                });

                opponentSongSection.appendChild(createSongBreakdownDOM("DIRECT REMOVAL THREATS", songAnalysis.directRemoval, OPPONENT_DECK_SONGS.length, 'bg-red-700', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("POTENTIAL REMOVAL / HIGH IMPACT", songAnalysis.potentialRemoval, OPPONENT_DECK_SONGS.length, 'bg-yellow-700 text-black', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("AFFECTS (No Direct Removal)", songAnalysis.affectsNoRemoval, OPPONENT_DECK_SONGS.length, 'bg-blue-700', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("NO INTERACTION / WARDED", songAnalysis.noInteraction, OPPONENT_DECK_SONGS.length, 'bg-gray-600', null, playerChar));
            } else {
                opponentSongSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent songs loaded for analysis.</p>`;
            }
            overallAnalysisContainer.appendChild(opponentSongSection);
            resultsDisplay.appendChild(overallAnalysisContainer);
        }

        function displayPlayerSongAnalysis() {
            console.log("Displaying Player Song Analysis.");
            if (PLAYER_DECK_SONGS.length === 0 || selectedCardIndex === -1 || selectedCardType !== 'song') {
                resultsDisplay.innerHTML += `<p class="text-center text-gray-400 italic">Please load decks and select a song to analyze.</p>`;
                return;
            }
            const playerSongEntry = PLAYER_DECK_SONGS[selectedCardIndex];
            if (!playerSongEntry) {
                resultsDisplay.innerHTML += `<p class="text-yellow-400 text-center">Invalid song selection.</p>`;
                console.warn("Invalid player song selection index:", selectedCardIndex);
                return;
            }
            const playerSongToAnalyze = playerSongEntry.cardInfo;
            console.log(`Analyzing player song: ${playerSongToAnalyze.fullName}`);

            const overallAnalysisContainer = document.createElement('div');

            const playerSongDisplay = document.createElement('div');
            playerSongDisplay.className = 'text-center mb-6 pb-4 border-b border-gray-700';
            const songFullTextForDisplay = (playerSongToAnalyze.effects?.join(' ') || playerSongToAnalyze.fullText || 'No effect text.').replace(/\n/g, ' ');
            playerSongDisplay.innerHTML = `
                <h2 class="text-2xl font-bold text-purple-300 mb-2">Analysis for Your Song: ${playerSongToAnalyze.fullName}</h2>
                <img src="${playerSongToAnalyze.images?.thumbnail || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Img'}" alt="${playerSongToAnalyze.fullName}" class="card-image mx-auto mb-2">
                <p class="text-sm text-gray-300">Cost: ${playerSongToAnalyze.cost || 'N/A'} | Inkable: ${playerSongToAnalyze.inkwell ? 'Yes' : 'No'}</p>
                <p class="text-xs text-gray-400">${songFullTextForDisplay}</p>
            `;
            overallAnalysisContainer.appendChild(playerSongDisplay);

            const playerSongImpactSection = document.createElement('section');
            playerSongImpactSection.className = 'analysis-section';
            const playerSongImpactTitle = document.createElement('h3');
            playerSongImpactTitle.className = 'section-title';
            playerSongImpactTitle.textContent = `Impact of Your "${playerSongToAnalyze.name}" on Opponent's Characters`;
            playerSongImpactSection.appendChild(playerSongImpactTitle);

            if (OPPONENT_DECK_CHARS.length > 0) {
                const songImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                const songFullTextForAnalysis = playerSongToAnalyze.effects?.join(' ') || playerSongToAnalyze.fullText || "";

                OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                    const classificationResult = classifyAbilityEffectOnTarget(playerSongToAnalyze, songFullTextForAnalysis, oppCharEntry.cardInfo, true);
                    const displayItem = {
                        card: oppCharEntry.cardInfo,
                        details: classificationResult.details,
                        classification: classificationResult.classification,
                    };
                    if (classificationResult.classification === "DirectRemoval") songImpactOnOppChars.directRemoval.push(displayItem);
                    else if (classificationResult.classification === "PotentialRemoval") songImpactOnOppChars.potentialRemoval.push(displayItem);
                    else if (classificationResult.classification === "AffectsNoRemoval") songImpactOnOppChars.affectsNoRemoval.push(displayItem);
                    else songImpactOnOppChars.noInteraction.push(displayItem);
                });

                playerSongImpactSection.appendChild(createSongBreakdownDOM("DIRECTLY REMOVES OPP CHARS", songImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-700', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("POTENTIALLY REMOVES OPP CHARS", songImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-600 text-black', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("AFFECTS OPP CHARS (No Direct Removal)", songImpactOnOppChars.affectsNoRemoval, OPPONENT_DECK_CHARS.length, 'bg-teal-700', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("NO INTERACTION WITH OPP CHARS / WARDED", songImpactOnOppChars.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-600', playerSongToAnalyze));

            } else {
                playerSongImpactSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters loaded to analyze song against.</p>`;
            }
            overallAnalysisContainer.appendChild(playerSongImpactSection);
            resultsDisplay.appendChild(overallAnalysisContainer);
        }

        function displayLocationInteractionAnalysis() {
            console.log("Displaying Location Interaction Analysis.");
            const locationAnalysisSection = document.createElement('section');
            locationAnalysisSection.className = 'analysis-section';
            const locationTitle = document.createElement('h3');
            locationTitle.className = 'section-title';
            locationTitle.textContent = 'Location Interaction Analysis';
            locationAnalysisSection.appendChild(locationTitle);

            // Opponent's Threats to Your Locations
            const oppThreatsContainer = document.createElement('div');
            oppThreatsContainer.className = 'mb-6';
            const oppThreatsTitle = document.createElement('h4');
            oppThreatsTitle.className = 'text-lg font-semibold text-red-400 mb-2';
            oppThreatsTitle.textContent = "Opponent's Threats to Your Locations";
            oppThreatsContainer.appendChild(oppThreatsTitle);

            let oppCharsThreateningLocations = [];
            OPPONENT_DECK_CHARS.forEach(oppChar => {
                const activeAbilities = getActiveAbilitiesForCharacter(oppChar.cardInfo, { perspective: "opponentTurn", action: "any" }); // Generic context for location abilities
                activeAbilities.forEach(ability => {
                    const interaction = classifyLocationInteraction(oppChar.cardInfo, ability.text, false); // false: opponent's card
                    if (interaction && interaction.canInteract) {
                        oppCharsThreateningLocations.push({ card: oppChar.cardInfo, details: `Ability: ${ability.name} - ${interaction.details}` });
                    }
                });
            });
            // Remove duplicates by card name if a char has multiple abilities affecting locations
            oppCharsThreateningLocations = Array.from(new Set(oppCharsThreateningLocations.map(item => item.card.fullName)))
                .map(name => oppCharsThreateningLocations.find(item => item.card.fullName === name));
            oppThreatsContainer.appendChild(createLocationInteractorsDOM("Opponent Characters That Can Remove/Target Your Locations", oppCharsThreateningLocations, 'bg-red-800'));

            let oppSongsThreateningLocations = [];
            OPPONENT_DECK_SONGS.forEach(oppSong => {
                const songText = oppSong.cardInfo.effects?.join(' ') || oppSong.cardInfo.fullText || "";
                const interaction = classifyLocationInteraction(oppSong.cardInfo, songText, false);
                if (interaction && interaction.canInteract) {
                    oppSongsThreateningLocations.push({ card: oppSong.cardInfo, details: interaction.details });
                }
            });
            oppThreatsContainer.appendChild(createLocationInteractorsDOM("Opponent Songs That Can Remove/Target Your Locations", oppSongsThreateningLocations, 'bg-red-700'));
            locationAnalysisSection.appendChild(oppThreatsContainer);


            // Your Options Against Opponent's Locations
            const playerOptionsContainer = document.createElement('div');
            const playerOptionsTitle = document.createElement('h4');
            playerOptionsTitle.className = 'text-lg font-semibold text-green-400 mb-2';
            playerOptionsTitle.textContent = "Your Options Against Opponent's Locations";
            playerOptionsContainer.appendChild(playerOptionsTitle);

            let playerCharsRemovingLocations = [];
            PLAYER_DECK_CHARS.forEach(playerChar => {
                const activeAbilities = getActiveAbilitiesForCharacter(playerChar.cardInfo, { perspective: "playerTurn", action: "any" });
                activeAbilities.forEach(ability => {
                    const interaction = classifyLocationInteraction(playerChar.cardInfo, ability.text, true); // true: player's card
                    if (interaction && interaction.canInteract) {
                        playerCharsRemovingLocations.push({ card: playerChar.cardInfo, details: `Ability: ${ability.name} - ${interaction.details}` });
                    }
                });
            });
            playerCharsRemovingLocations = Array.from(new Set(playerCharsRemovingLocations.map(item => item.card.fullName)))
                .map(name => playerCharsRemovingLocations.find(item => item.card.fullName === name));
            playerOptionsContainer.appendChild(createLocationInteractorsDOM("Your Characters That Can Remove/Target Opponent's Locations", playerCharsRemovingLocations, 'bg-green-800'));

            let playerSongsRemovingLocations = [];
            PLAYER_DECK_SONGS.forEach(playerSong => {
                const songText = playerSong.cardInfo.effects?.join(' ') || playerSong.cardInfo.fullText || "";
                const interaction = classifyLocationInteraction(playerSong.cardInfo, songText, true);
                if (interaction && interaction.canInteract) {
                    playerSongsRemovingLocations.push({ card: playerSong.cardInfo, details: interaction.details });
                }
            });
            playerOptionsContainer.appendChild(createLocationInteractorsDOM("Your Songs That Can Remove/Target Opponent's Locations", playerSongsRemovingLocations, 'bg-green-700'));
            locationAnalysisSection.appendChild(playerOptionsContainer);

            resultsDisplay.appendChild(locationAnalysisSection);
        }

        function createOutcomeSectionDOM(title, cardsWithObjects, totalTargetChars, bgColorClass = 'bg-gray-700') {
            const section = document.createElement('div');
            section.className = `outcome-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalTargetChars > 0 ? ((cardsWithObjects.length / totalTargetChars) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            titleElem.textContent = `${title} (${cardsWithObjects.length}/${totalTargetChars} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (cardsWithObjects.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs text-gray-400 italic p-1">None.</p>`;
            } else {
                cardsWithObjects.forEach(obj => {
                    const card = obj.card;
                    const details = obj.details;
                    const keywords = extractCharacterKeywords(card);
                    let keywordStr = Object.entries(keywords)
                        .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                        .map(([key, value]) => {
                            if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                            return key.charAt(0).toUpperCase() + key.slice(1);
                        }).join(', ');
                    if (!keywordStr) keywordStr = 'None';

                    const tooltipText = `Name: ${card.fullName}\nCost: ${card.cost}, Str: ${card.strength}, Wp: ${card.willpower}, Lore: ${card.lore || 0}\nKeywords: ${keywordStr}\nMatchup: ${details || 'N/A'}`;

                    const tooltipWrapper = createCardTooltipWrapper(card, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createSongBreakdownDOM(title, classifiedItems, totalTargetableItemsCount, bgColorClass = 'bg-gray-700', contextSongCard = null, contextCharCard = null) {
            const section = document.createElement('div');
            section.className = `song-breakdown-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalTargetableItemsCount > 0 ? ((classifiedItems.length / totalTargetableItemsCount) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            if (bgColorClass.includes('text-black')) {
                titleElem.classList.add('text-black');
            }
            titleElem.textContent = `${title} (${classifiedItems.length}/${totalTargetableItemsCount} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (classifiedItems.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs ${bgColorClass.includes('text-black') ? 'text-gray-700' : 'text-gray-400'} italic p-1">None.</p>`;
            } else {
                classifiedItems.forEach(item => {
                    const cardForDisplay = item.card;
                    const interactionSummary = item.details;
                    const classificationType = item.classification;
                    let tooltipText;

                    if (contextSongCard) {
                        const targetCharCard = cardForDisplay;
                        const keywords = extractCharacterKeywords(targetCharCard);
                        let keywordStr = Object.entries(keywords)
                            .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                            .map(([key, value]) => {
                                if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                                return key.charAt(0).toUpperCase() + key.slice(1);
                            }).join(', ');
                        if (!keywordStr) keywordStr = 'None';
                        tooltipText = `Target Char: ${targetCharCard.fullName}\nCost: ${targetCharCard.cost}, Str: ${targetCharCard.strength}, Wp: ${targetCharCard.willpower}\nKeywords: ${keywordStr}\nAffected by Your Song: "${contextSongCard.fullName}"\nInteraction: ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;
                    } else {
                        const opponentSongCard = cardForDisplay; // Here, item.card is the song itself
                        tooltipText = `Opponent's Song: ${opponentSongCard.fullName}\nCost: ${opponentSongCard.cost} | Inkable: ${opponentSongCard.inkwell ? 'Yes' : 'No'}\nEffect Snippet: ${(opponentSongCard.effects?.join('; ') || opponentSongCard.fullText || '').replace(/\n/g, ' ').substring(0, 70) + '...'}\nInteraction with Your Char (${contextCharCard?.name || 'Selected Char'}): ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;
                    }

                    const tooltipWrapper = createCardTooltipWrapper(cardForDisplay, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createAbilityImpactDOM(title, classifiedTargetChars, totalOpponentChars, bgColorClass = 'bg-gray-700', sourceCharCard, sourceAbilityName) {
            const section = document.createElement('div');
            section.className = `ability-impact-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalOpponentChars > 0 ? ((classifiedTargetChars.length / totalOpponentChars) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            if (bgColorClass.includes('text-black')) {
                titleElem.classList.add('text-black');
            }
            titleElem.textContent = `${title} (${classifiedTargetChars.length}/${totalOpponentChars} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (classifiedTargetChars.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs ${bgColorClass.includes('text-black') ? 'text-gray-700' : 'text-gray-400'} italic p-1">None.</p>`;
            } else {
                classifiedTargetChars.forEach(item => {
                    const targetCharCard = item.card;
                    const interactionSummary = item.details;
                    const classificationType = item.classification;

                    const keywords = extractCharacterKeywords(targetCharCard);
                    let keywordStr = Object.entries(keywords)
                        .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                        .map(([key, value]) => {
                            if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                            return key.charAt(0).toUpperCase() + key.slice(1);
                        }).join(', ');
                    if (!keywordStr) keywordStr = 'None';

                    const tooltipText = `Target Char: ${targetCharCard.fullName}\nCost: ${targetCharCard.cost}, Str: ${targetCharCard.strength}, Wp: ${targetCharCard.willpower}\nKeywords: ${keywordStr}\nAffected by ${sourceCharCard.name}'s Ability: "${sourceAbilityName}"\nInteraction: ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;

                    const tooltipWrapper = createCardTooltipWrapper(targetCharCard, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createLocationInteractorsDOM(title, interactingCards, bgColorClass = 'bg-gray-700') {
            const section = document.createElement('div');
            section.className = `location-interaction-subsection shadow-md ${bgColorClass} p-3`;

            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            titleElem.textContent = `${title} (${interactingCards.length})`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (interactingCards.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs text-gray-400 italic p-1">None found.</p>`;
            } else {
                interactingCards.forEach(item => {
                    const card = item.card; // This is the Character or Song card
                    const details = item.details;
                    const tooltipText = `Card: ${card.fullName}\nType: ${card.type}\nInteraction: ${details}`;
                    const tooltipWrapper = createCardTooltipWrapper(card, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }


        function createCardTooltipWrapper(cardData, tooltipTextContent) {
            const tooltipWrapper = document.createElement('div');
            tooltipWrapper.className = 'tooltip';

            const img = document.createElement('img');
            img.src = cardData.images?.thumbnail || `https://placehold.co/100x140/2d3748/e2e8f0?text=${cardData.name.substring(0, 10)}`;
            img.alt = cardData.fullName;
            img.className = 'card-image';
            img.onerror = () => { img.src = `https://placehold.co/100x140/2d3748/e2e8f0?text=Error`; };
            tooltipWrapper.appendChild(img);

            const tooltipSpan = document.createElement('span');
            tooltipSpan.className = 'tooltiptext';
            tooltipSpan.textContent = tooltipTextContent;
            tooltipWrapper.appendChild(tooltipSpan);

            return tooltipWrapper;
        }

        // --- Start the app ---
        initializeApp();
    </script>
</body>

</html>