<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorcana Deck Matchup Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            /* Dark mode background */
            color: #e2e8f0;
            /* Light text for dark mode */
        }

        .card-image {
            width: 100px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }

        .card-image:hover {
            transform: scale(1.1);
        }

        .selectable-card {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .selectable-card:hover {
            background-color: #4a5568;
        }

        .selectable-card.selected {
            background-color: #667eea;
            box-shadow: 0 0 0 2px #a0aec0;
        }

        .selectable-card .card-name {
            font-size: 0.75rem;
            text-align: center;
            margin-top: 4px;
            color: #e2e8f0;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .card-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            background-color: #2d3748;
            /* Slightly lighter dark background for sections */
            border-radius: 8px;
            min-height: 100px;
            /* Adjusted min-height */
            align-items: flex-start;
            /* Align items to the top */
        }

        .analysis-section {
            /* Generic class for major sections */
            background-color: #222b3c;
            /* Slightly different dark for main sections */
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .outcome-section,
        .song-breakdown-section,
        .ability-impact-section,
        .location-interaction-subsection {
            /* Specific styling for subsections */
            background-color: #2d3748;
            padding: 12px;
            /* Slightly reduced padding */
            border-radius: 8px;
            margin-bottom: 12px;
            /* Reduced margin */
        }

        .section-title {
            /* For main section titles like "Character Matchups" */
            font-size: 1.5rem;
            /* Larger */
            font-weight: bold;
            color: #c3dafe;
            /* Light blueish */
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #4a5568;
        }

        .subsection-title {
            /* For titles within outcome/song sections */
            font-weight: bold;
            margin-bottom: 8px;
            color: #a0aec0;
            font-size: 1rem;
            /* Standardized size */
        }

        .ability-title {
            /* For individual ability names */
            font-weight: bold;
            color: #b0c4de;
            /* Lighter blue for ability names */
            margin-top: 10px;
            margin-bottom: 5px;
        }

        textarea {
            background-color: #2d3748;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 8px;
        }

        button {
            background-color: #4a5fa0;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #3c4b80;
        }

        select {
            background-color: #2d3748;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 8px;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            /* Increased width for more text */
            background-color: #374151;
            color: #e5e7eb;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            /* Increased padding */
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            /* Half of new width */
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            line-height: 1.4;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            white-space: pre-line;
            /* Allow newlines in tooltip */
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #374151 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Styling for radio buttons */
        .radio-label {
            margin-right: 10px;
            cursor: pointer;
        }

        .radio-label input[type="radio"] {
            margin-right: 5px;
        }
    </style>
</head>

<body class="p-4 md:p-8">

    <header class="text-center mb-8">
        <h1 class="text-3xl font-bold text-purple-400">Lorcana Matchup Analyzer</h1>
        <p class="text-sm text-gray-400">Analyze character trade values, song threats, and location vulnerabilities.</p>
    </header>

    <div id="loadingIndicator" class="text-center my-4">
        <div class="loading-spinner"></div>
        <p>Loading Card Data & Patterns...</p>
    </div>

    <main id="appContent" class="hidden">
        <section class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                <h2 class="text-xl font-semibold mb-2">Your Deck</h2>
                <div class="flex items-center gap-2 mb-2">
                  <button id="loadPlayerDeckBtn" class="px-3 py-1.5 bg-purple-700 hover:bg-purple-800 rounded text-sm font-semibold">Load from Database</button>
                </div>
                <textarea id="playerDeckInput" rows="10" class="w-full p-2"
                    placeholder="4 Card Name&#10;2 Another Card Name..."></textarea>
            </div>
            <div>
                <h2 class="text-xl font-semibold mb-2">Opponent's Deck</h2>
                <div class="flex items-center gap-2 mb-2">
                  <button id="loadOpponentDeckBtn" class="px-3 py-1.5 bg-purple-700 hover:bg-purple-800 rounded text-sm font-semibold">Load from Database</button>
                </div>
                <textarea id="opponentDeckInput" rows="10" class="w-full p-2"
                    placeholder="4 Card Name&#10;2 Another Card Name..."></textarea>
            </div>
        </section>

        <div class="text-center mb-6">
            <button id="analyzeButton" class="px-6 py-3">Load Decks & Analyze</button>
        </div>

        <section id="analysisControls" class="hidden mt-8 p-4 bg-gray-700 rounded-lg shadow-md">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                <div class="mb-4 sm:mb-0">
                    <span class="mr-2 font-semibold">Analysis Mode:</span>
                    <label class="radio-label"><input type="radio" name="analysisMode" value="character" checked> My
                        Character</label>
                    <label class="radio-label"><input type="radio" name="analysisMode" value="song"> My Song</label>
                </div>

                <div id="challengePerspectiveContainer">
                    <label for="turnContextSelect" class="mr-2 font-semibold">Challenge Perspective:</label>
                    <select id="turnContextSelect">
                        <option value="player">My Turn (I Challenge)</option>
                        <option value="opponent">Opponent's Turn (They Challenge)</option>
                    </select>
                </div>
            </div>
        </section>

        <section id="cardSelectionGrid" class="hidden mt-6">
            <h3 class="text-xl font-semibold mb-4 text-center" id="cardSelectionTitle">Select a Character to Analyze
            </h3>
            <div id="playerCardsGrid"
                class="grid grid-cols-12 md:grid-cols-20 lg:grid-cols-25 xl:grid-cols-20 gap-1 p-1 bg-gray-800 rounded-lg">
                <!-- Cards will be populated here -->
            </div>
        </section>

        <section id="resultsDisplay" class="mt-8">
        </section>

        <!-- UWPM Win Probability Display -->
        <div class="mt-8 p-6 bg-gray-800 rounded-lg shadow-xl">
            <h2 class="text-2xl font-bold text-center text-purple-400 mb-4">Unified Win Probability Model (UWPM)</h2>
            <div id="win-probability-display" class="text-center">
                <p class="text-lg text-gray-400">Load both decks to calculate win probability.</p>
            </div>
        </div>
    </main>

    <!-- Deck Load Modal -->
    <div id="deckLoadModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 p-4 opacity-0 pointer-events-none transition-opacity duration-200">
      <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
        <h3 class="text-lg font-bold text-white mb-4">Select a Deck</h3>
        <input type="text" id="deckSearchInput" placeholder="Search decks by name..." class="w-full mb-4 px-3 py-2 rounded bg-gray-700 border border-gray-600 text-gray-200 focus:ring-2 focus:ring-purple-500 focus:outline-none">
        <div id="deckListContainer" class="max-h-64 overflow-y-auto space-y-2">
          <!-- Decks will be injected here -->
        </div>
        <div class="flex justify-end mt-6">
          <button id="closeDeckModalBtn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded font-semibold">Cancel</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>

    <script>
        // --- Globals ---
        let ALL_CARDS_DATA = null;
        let ALL_CARDS_MAP = new Map();
        let LORCANA_PATTERNS = {};
        let PLAYER_DECK_CHARS = [];
        let OPPONENT_DECK_CHARS = [];
        let PLAYER_DECK_SONGS = [];
        let OPPONENT_DECK_SONGS = [];
        let PLAYER_DECK_LOCATIONS = [];
        let OPPONENT_DECK_LOCATIONS = [];

        // --- Supabase Deck Loading ---
        const SUPABASE_URL = 'https://cjlhrfhximjldqrfblkj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNqbGhyZmh4aW1qbGRxcmZibGtqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA0MTcxNzQsImV4cCI6MjA2NTk5MzE3NH0.zLiQcPnKt2SnNfQIkUnOG7bOo6F7MPMh8MsasdFF6lw';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let allDecks = [];
        let deckFuse;
        let deckLoadTarget = null; // 'player' or 'opponent'

        // Modal elements
        const deckLoadModal = document.createElement('div');
        // (But we already inject it above, so just get by id)
        // --- DOM Elements ---
        // ... existing code ...
        // Add after DOMContentLoaded or in initializeApp
        document.addEventListener('DOMContentLoaded', () => {
          // ... existing code ...
          // Modal DOM
          const deckLoadModal = document.getElementById('deckLoadModal');
          const deckListContainer = document.getElementById('deckListContainer');
          const deckSearchInput = document.getElementById('deckSearchInput');
          const closeDeckModalBtn = document.getElementById('closeDeckModalBtn');
          const loadPlayerDeckBtn = document.getElementById('loadPlayerDeckBtn');
          const loadOpponentDeckBtn = document.getElementById('loadOpponentDeckBtn');
          const playerDeckInput = document.getElementById('playerDeckInput');
          const opponentDeckInput = document.getElementById('opponentDeckInput');

          // Modal show/hide helpers
          function showDeckModal(target) {
            deckLoadTarget = target;
            deckLoadModal.classList.remove('opacity-0', 'pointer-events-none');
            deckSearchInput.value = '';
            renderDeckList(allDecks);
            deckSearchInput.focus();
          }
          function hideDeckModal() {
            deckLoadModal.classList.add('opacity-0', 'pointer-events-none');
            deckLoadTarget = null;
          }

          // Fetch decks from Supabase
          async function fetchDecksFromDatabase() {
            const { data, error } = await supabaseClient.from('decks').select('*').order('created_at', { ascending: true });
            if (error) {
              console.error('Error fetching decks:', error);
              allDecks = [];
            } else {
              allDecks = data;
            }
            deckFuse = new Fuse(allDecks, { keys: ['name'], includeScore: true, threshold: 0.4 });
          }

          // Render deck list in modal
          function renderDeckList(decksToRender) {
            deckListContainer.innerHTML = '';
            if (!decksToRender.length) {
              deckListContainer.innerHTML = '<p class="text-gray-400 italic text-center">No decks found.</p>';
              return;
            }
            decksToRender.forEach(deck => {
              const btn = document.createElement('button');
              btn.className = 'w-full text-left p-3 rounded-md hover:bg-purple-700 focus:bg-purple-800 focus:outline-none transition-colors font-semibold text-gray-100';
              btn.textContent = deck.name;
              btn.addEventListener('click', () => {
                if (deckLoadTarget === 'player') {
                  playerDeckInput.value = deck.decklist || '';
                } else if (deckLoadTarget === 'opponent') {
                  opponentDeckInput.value = deck.decklist || '';
                }
                hideDeckModal();
              });
              deckListContainer.appendChild(btn);
            });
          }

          // Modal search
          deckSearchInput.addEventListener('input', () => {
            const searchTerm = deckSearchInput.value.trim();
            if (!searchTerm) {
              renderDeckList(allDecks);
              return;
            }
            const results = deckFuse.search(searchTerm);
            const filteredDecks = results.map(r => r.item);
            renderDeckList(filteredDecks);
          });

          // Modal close
          closeDeckModalBtn.addEventListener('click', hideDeckModal);

          // Open modal for player deck
          loadPlayerDeckBtn.addEventListener('click', async () => {
            await fetchDecksFromDatabase();
            showDeckModal('player');
          });
          // Open modal for opponent deck
          loadOpponentDeckBtn.addEventListener('click', async () => {
            await fetchDecksFromDatabase();
            showDeckModal('opponent');
          });
        });

        const CARD_DATA_URL = 'https://raw.githubusercontent.com/heavenideas/similcana/refs/heads/main/database/allCards.json';

        // Patterns will be loaded from external file
        const PATTERNS_URL = 'https://raw.githubusercontent.com/heavenideas/heavenideas.github.io/refs/heads/main/lorcanaUtils_MatchUpAnalyzer/lorcana_patterns.txt';

        const DEFAULT_PLAYER_DECK = `1 Be Prepared
1 Prince Eric - Expert Helmsman
1 Vinnie - Green Pigeon
1 Calhoun - Marine Sergeant
1 Mother Gothel - Knows What's Best
1 Ludwig Von Drake - All-Around Expert
1 Kuzco - Wanted Llama
1 Tramp - Dapper Rascal
1 Belle - Apprentice Inventor
1 Tinker Bell - Giant Fairy
1 Pawpsicle
1 Croquet Mallet
1 Chernabog's Followers - Creatures of Evil
1 Madam Mim - Snake
1 Ring the Bell
1 Lyle Tiberius Rourke - Cunning Mercenary
1 Magic Broom - Illuminary Keeper
1 Prince Phillip - Vanquisher of Foes
1 Palace Guard - Spectral Sentry
1 Magic Carpet - Phantom Rug
1 The Sultan - Royal Apparition
1 Abu - Illusory Pachyderm
1 Jafar - Newly Crowned
1 Jafar - Dreadnought
1 The Lamp
1 Madam Mim - Elephant
1 Ratigan - Greedy Genius
1 Mickey Mouse - Giant Mouse
1 Mickey Mouse - Inspirational Warrior
1 Clarabelle - Clumsy Guest
1 Hades - Double Dealer
1 Stitch - Alien Troublemaker
1 Bagheera - Guardian Jaguar
1 Sisu - Empowered Sibling
1 I Find 'Em, I Flatten 'Em
1 Pete - Pirate Scoundrel
1 Mushu - Majestic Dragon
1 King Candy - Royal Racer
1 King Candy - Sugar Rush Nightmare
1 Candy Drift
1 Sisu - Daring Visitor
1 Glimmer vs Glimmer
1 Candlehead - Dedicated Racer
1 Sisu - Empowered Sibling
1 Brawl
1 Vitalisphere
1 Robin Hood - Champion of Sherwood
1 Simba - Fighting Prince
1 Emerald Chromicon
1 Mr. Snoops - Betrayed Partner
1 Dragon Fire
1 Bolt - Superdog
1 Chief Bogo - Commanding Officer
1 Robin Hood - Champion of Sherwood
1 Fred - Major Science Enthusiast
1 Cheshire Cat - From the Shadows
1 Cheshire Cat - Not All There
1 Most Everyone's Mad Here
1 Pua - Protective Pig
1 Mufasa - Betrayed Leader
1 Lady Tremaine - Imperious Queen
1 Lumiere - Fired Up
1 Get Out!
1 Belle's Favorite Book
1 Beast - Frustrated Designer
1 Maurice's Machine
1 Royal Tantrum
1 Maurice - Unconventional Inventor
1 Unconventional Tool
1 Camilo Madrigal - Center Stage
1 Helga Sinclair - Vengeful Partner
1 Madame Medusa - The Boss
1 Anna - Diplomatic Queen
1 Fortisphere
1 Hiram Flaversham - Toymaker
1 Last Cannon
1 Naveen's Ukulele
1 Scar - Vicious Cheater
1 Calhoun - Hard-Nosed Leader
1 Walk the Plank!
1 Donald Duck - Buccaneer
1 Maui - Stubborn Trickster
1 Benja - Guardian of the Dragon Gem
1 Maleficent - Monstrous Dragon
1 Launch
1 Potion of Might
1 Gold Coin
1 Sumerian Talisman
1 Tinker Bell - Very Clever Fairy
1 Gale - Wind Spirit
1 Bruni - Fire Salamander
1 Miracle Candle
1 HeiHei - Persistent Presence
1 Shield of Arendelle
1 Ratigan's Marvelous Trap
1 Galactic Communicator
1 Retrosphere
1 Billy Bones - Space Sailor
1 Mickey Mouse - Wayward Sorcerer
1 Be King Undisputed
1 Razoul - Menacing Guard
1 Aladdin - Brave Rescuer
1 Beast - Hardheaded
1 Simba - Rightful Heir
1 Frying Pan
1 Iago - Reappearing Parrot
1 Dr. Facilier - Agent Provocateur
1 Monsieur D'Arque - Despicable Proprietor
1 Mrs. Potts - Head Housekeeper
1 Glean
1 Avalanche
1 Wasabi - Methodical Engineer
1 Jumbo Pop
1 Magic Golden Flower`;

        const DEFAULT_OPPONENT_DECK = `1 Cinderella - Ballroom Sensation
1 Daisy Duck - Donald's Date
1 Lady - Family Dog
1 Penny - Bolt's Person
1 Piglet - Pooh Pirate Captain
1 Rapunzel - Gifted with Healing
1 Goofy - Groundbreaking Chef
1 Rhino - Power Hamster
1 Rhino - One-Sixteenth Wolf
1 Rapunzel's Tower - Secluded Prison
1 Perdita - Playful Mother
1 Thunderbolt - Wonder Dog
1 Pongo - Dear Old Dad
1 Stitch - New Dog
1 Stitch - Rock Star
1 99 Puppies
1 Perdita - Determined Mother
1 Patch - Playful Pup
1 Ludwig Von Drake - All-Around Expert
1 Lilo - Escape Artist
1 Minnie Mouse - Storyteller
1 Lady - Miss Park Avenue
1 Tramp - Dapper Rascal
1 Lady - Decisive Dog
1 Tramp - Street-Smart Dog
1 Sven - Reindeer Steed
1 Nala - Mischievous Cub
1 The Colonel - Old Sheepdog
1 Dalmatian Puppy - Tail Wagger
1 Perdita - On the Lookout
1 Roger Radcliffe - Dog Lover
1 Dalmatian Puppy - Tail Wagger
1 Ariel - Spectacular Singer
1 The Troubadour - Musical Narrator
1 Ursula - Vanessa
1 World's Greatest Criminal Mind
1 Prince Naveen - Ukulele Player
1 Chernabog - Evildoer
1 Antonio Madrigal - Friend to All
1 Mirabel Madrigal - Curious Child
1 Bruno Madrigal - Singing Seer
1 Mirabel Madrigal - Hopeful Dreamer
1 The Bare Necessities
1 Be Our Guest
1 Pepa Madrigal - Sensitive Sister
1 Bolt - Down but Not Out
1 Darling Dear - Beloved Wife
1 Alan-a-Dale - Rockin' Rooster
1 Donald Duck - Musketeer Soldier
1 Calhoun - Battle-Tested
1 The Prince - Vigilant Suitor
1 Donald Duck - Coin Collector
1 Gaston - Despicable Dealer
1 The Queen - Regal Monarch
1 The Queen - Commanding Presence
1 Tiana - Restaurant Owner
1 Lilo - Making a Wish
1 Baloo - von Bruinwald XIII
1 Pascal - Garden Chameleon
1 Jim Dear - Beloved Husband
1 She's Your Person
1 So Much To Give
1 Bolt - Superdog
1 Chief Bogo - Commanding Officer
1 Bolt - Dependable Friend
1 Painting the Roses Red
1 Rhino - Motivational Speaker`;

        // --- DOM Elements ---
        const loadingIndicator = document.getElementById('loadingIndicator');
        const appContent = document.getElementById('appContent');
        const playerDeckInput = document.getElementById('playerDeckInput');
        const opponentDeckInput = document.getElementById('opponentDeckInput');
        const analyzeButton = document.getElementById('analyzeButton');
        const analysisControls = document.getElementById('analysisControls');
        const cardSelectionGrid = document.getElementById('cardSelectionGrid');
        const cardSelectionTitle = document.getElementById('cardSelectionTitle');
        const playerCardsGrid = document.getElementById('playerCardsGrid');

        const analysisModeRadios = document.querySelectorAll('input[name="analysisMode"]');
        const challengePerspectiveContainer = document.getElementById('challengePerspectiveContainer');

        const turnContextSelect = document.getElementById('turnContextSelect');
        const resultsDisplay = document.getElementById('resultsDisplay');

        // --- Selection State ---
        let selectedCardIndex = -1;
        let selectedCardType = null; // 'character' or 'song'

        /**
         * @typedef {object} UWPCard - An enriched card object with features for the UWPM.
         * @property {string} name - The card's name.
         * @property {number} cost - The ink cost.
         * @property {number} strength - The strength value.
         * @property {number} willpower - The willpower value.
         * @property {number} lore - The lore value.
         * @property {boolean} isUninkable - True if the card cannot be put in the inkwell.
         * @property {Set<string>} keywords - A set of keywords (e.g., 'Rush', 'Ward', 'Evasive').
         * @property {Set<string>} abilityPatterns - A set of identified ability patterns from lorcana_patterns.txt.
         * @property {object} rawData - The original card data.
         */

        /**
         * Processes a raw card object and extracts features required for UWPM calculations.
         * @param {object} rawCard - The card object from allCards.json.
         * @param {object} LORCANA_PATTERNS - The parsed regex patterns.
         * @returns {UWPCard} - The enriched card object.
         */
        function extractCardFeatures(rawCard, LORCANA_PATTERNS) {
            // 1. Initialize the UWPCard object with basic stats.
            const features = {
                name: rawCard.name,
                cost: rawCard.cost,
                strength: rawCard.strength || 0,
                willpower: rawCard.willpower || 0,
                lore: rawCard.lore || 0,
                isUninkable: rawCard.inkable === false,
                keywords: new Set(),
                abilityPatterns: new Set(),
                rawData: rawCard,
            };

            // 2. Extract keywords from both the keywords field and ability text
            // (a) From keywords field
            if (Array.isArray(rawCard.keywords)) {
                rawCard.keywords.forEach(kw => features.keywords.add(kw));
            }
            // (b) From abilities (look for keyword type or parse text)
            if (Array.isArray(rawCard.abilities)) {
                rawCard.abilities.forEach(ability => {
                    if (ability.type === 'keyword' && ability.keyword) {
                        features.keywords.add(ability.keyword);
                    }
                    // Also parse for common keywords in text (e.g., 'Rush', 'Ward', etc.)
                    const text = (ability.fullText || '').toLowerCase();
                    ['rush', 'ward', 'evasive', 'resist', 'challenger', 'support', 'bodyguard', 'reckless', 'singer'].forEach(kw => {
                        if (text.includes(kw)) features.keywords.add(kw.charAt(0).toUpperCase() + kw.slice(1));
                    });
                });
            }
            // (c) From subtypes (sometimes subtypes are used as keywords)
            if (Array.isArray(rawCard.subtypes)) {
                rawCard.subtypes.forEach(subtype => features.keywords.add(subtype));
            }

            // 3. Use the regex from LORCANA_PATTERNS to identify all matching ability patterns
            // in the card's `fullText` or `abilities` field.
            let allText = '';
            if (rawCard.fullText) allText += rawCard.fullText + '\n';
            if (Array.isArray(rawCard.abilities)) {
                rawCard.abilities.forEach(ability => {
                    if (ability.fullText) allText += ability.fullText + '\n';
                });
            }
            // For each pattern in all categories, if it matches, add its name
            for (const category in LORCANA_PATTERNS) {
                for (const pattern of LORCANA_PATTERNS[category]) {
                    if (pattern.regex && pattern.name && pattern.regex.test(allText)) {
                        features.abilityPatterns.add(pattern.name);
                    }
                }
            }

            return features;
        }

        /**
         * Calculates the Resource Dominance Score (RDS) for a given deck.
         * @param {UWPCard[]} deck
         * @returns {number}
         */
        function calculateRDS(deck) {
            let cardAdvantageGeneration = 0;
            let cardAdvantageDenial = 0;
            let inkAcceleration = 0;
            let uninkableBurden = 0;

            deck.forEach(card => {
                // Card Advantage Generation (CAG)
                if (card.abilityPatterns.has('Card Effect: Draw')) {
                    // Estimate draw count from text if possible, else +1
                    let drawCount = 1;
                    const drawMatch = (card.rawData.fullText || '').match(/draw (\d+) cards?/i);
                    if (drawMatch) drawCount = parseInt(drawMatch[1], 10);
                    cardAdvantageGeneration += drawCount * (2 / (card.cost || 1));
                }
                if (card.abilityPatterns.has('Play: From Discard')) {
                    cardAdvantageGeneration += 1.5;
                }

                // Card Advantage Denial (CAD)
                if (card.abilityPatterns.has('Card Effect: Opponent Discards')) {
                    cardAdvantageDenial += 1.5;
                }

                // Ink Acceleration (IA)
                if (card.abilityPatterns.has('Card Effect: Hand to Inkwell')) {
                    inkAcceleration += 2.0;
                }
                if (card.abilityPatterns.has('Stat: Cost Reduction')) {
                    inkAcceleration += 1.0;
                }

                // Uninkable Burden (UB)
                if (card.isUninkable) {
                    uninkableBurden += (card.cost || 1) * 0.25;
                }
            });

            const rds = cardAdvantageGeneration + cardAdvantageDenial + inkAcceleration - uninkableBurden;
            return rds;
        }

        /**
         * Calculates the Lore Velocity Index (LVI) for a given deck.
         * @param {UWPCard[]} deck
         * @returns {number}
         */
        function calculateLVI(deck) {
            let loreVelocityIndex = 0;
            deck.forEach(card => {
                if (card.lore > 0) {
                    let baseLorePotential = card.lore / (card.cost || 1);
                    let loreSurvivabilityModifier = 1.0;
                    let questSafetyModifier = 1.0;
                    // Lore Survivability Modifier (LSM)
                    if (card.keywords.has('Ward')) loreSurvivabilityModifier *= 1.4;
                    if (card.keywords.has('Resist')) loreSurvivabilityModifier *= 1.2;
                    if ((card.willpower || 0) >= 5) loreSurvivabilityModifier *= 1.1;
                    // Quest Safety Modifier (QSM)
                    if (card.keywords.has('Evasive')) questSafetyModifier *= 1.5;
                    loreVelocityIndex += baseLorePotential * loreSurvivabilityModifier * questSafetyModifier;
                }
                // Direct Lore Manipulation (DLM)
                if (card.abilityPatterns.has('Lore: Gain')) {
                    loreVelocityIndex += 1.5;
                }
            });
            return loreVelocityIndex;
        }

        /**
         * Calculates the Board Control Rating (BCR) for a given deck.
         * @param {UWPCard[]} deck
         * @returns {number}
         */
        function calculateBCR(deck) {
            let boardControlRating = 0;
            deck.forEach(card => {
                // Removal Efficiency (RE)
                if (card.abilityPatterns.has('Banish: Chosen Target') || card.abilityPatterns.has('Banish: Any')) {
                    boardControlRating += 7 / (card.cost || 1);
                }
                if (card.abilityPatterns.has('Damage: Deal to One')) {
                    boardControlRating += 4 / (card.cost || 1);
                }
                // Removal Versatility (RV)
                if (card.abilityPatterns.has('Banish: All Characters')) {
                    boardControlRating += 5.0;
                }
                // Proactive Control (PC)
                if (card.keywords.has('Rush')) {
                    boardControlRating += (card.strength || 0) * 0.5;
                }
            });
            return boardControlRating;
        }

        /**
         * Calculates the final win probability for Deck A against Deck B.
         * @param {UWPCard[]} deckA - The player's deck.
         * @param {UWPCard[]} deckB - The opponent's deck.
         * @returns {number} - The win probability for Deck A (e.g., 0.55 for 55%).
         */
        function calculateWinProbability(deckA, deckB) {
            // 1. Calculate Intrinsic Scores for both decks
            const rdsA = calculateRDS(deckA);
            const lviA = calculateLVI(deckA);
            const bcrA = calculateBCR(deckA);

            const rdsB = calculateRDS(deckB);
            const lviB = calculateLVI(deckB);
            const bcrB = calculateBCR(deckB);

            // 2. Calculate Matchup-Specific Modifiers (placeholders for now)
            const aim = 0; // Archetype Interaction Modifier
            const tfa = 0; // Tempo Flow Analysis
            const taes = 0; // Threat-Answer Efficiency Score

            // 3. Define weights (tunable)
            const weights = { rds: 0.15, lvi: 0.25, bcr: 0.25, aim: 1.0, tfa: 1.0, taes: 1.0 };

            // 4. Calculate the final Matchup Score using the Master Equation
            const matchupScore =
                weights.rds * (rdsA - rdsB) +
                weights.lvi * (lviA - lviB) +
                weights.bcr * (bcrA - bcrB) +
                weights.aim * aim +
                weights.tfa * tfa +
                weights.taes * taes;

            // 5. Convert the score to a probability using the Logistic Function
            const k = 1; // Scaling factor, tunable
            const winProbability = 1 / (1 + Math.exp(-k * matchupScore));

            return winProbability;
        }

        // --- Initialization ---
        async function initializeApp() {
            console.log("Initializing app...");
            try {
                // Fetch card data
                const cardsResponse = await fetch(CARD_DATA_URL);

                if (!cardsResponse.ok) throw new Error(`HTTP error! status: ${cardsResponse.status}`);
                ALL_CARDS_DATA = await cardsResponse.json();
                console.log("Card data fetched successfully:", ALL_CARDS_DATA.cards.length, "cards loaded.");

                ALL_CARDS_DATA.cards.forEach(card => {
                    ALL_CARDS_MAP.set(card.fullName, card);
                    if (card.simpleName && card.simpleName !== card.fullName) {
                        ALL_CARDS_MAP.set(card.simpleName, card);
                    }
                });
                console.log("ALL_CARDS_MAP populated with", ALL_CARDS_MAP.size, "entries.");

                // Fetch patterns from external file
                const patternsResponse = await fetch(PATTERNS_URL);
                if (!patternsResponse.ok) throw new Error(`HTTP error! status: ${patternsResponse.status}`);
                const patternsText = await patternsResponse.text();
                parseAndStorePatterns(patternsText);

                loadingIndicator.classList.add('hidden');
                appContent.classList.remove('hidden');

                playerDeckInput.value = DEFAULT_PLAYER_DECK;
                opponentDeckInput.value = DEFAULT_OPPONENT_DECK;
                console.log("Default decklists set.");

                analyzeButton.addEventListener('click', handleAnalyzeButtonClick);
                turnContextSelect.addEventListener('change', displayAnalysisResults);

                analysisModeRadios.forEach(radio => {
                    radio.addEventListener('change', handleAnalysisModeChange);
                });
                console.log("Event listeners attached.");

            } catch (error) {
                console.error("Error during app initialization:", error);
                loadingIndicator.innerHTML = `<p class="text-red-500">Error loading data. Please try refreshing. Details: ${error.message}</p>`;
            }
        }

        // --- Pattern Parsing ---
        function parseAndStorePatterns(text) {
            const patternBlocks = text.split('----------------------------------------').map(s => s.trim()).filter(Boolean);
            patternBlocks.forEach(block => {
                const nameMatch = block.match(/Pattern Name: (.*)/);
                const regexMatch = block.match(/Regex: \/(.*)\/(.*)/);

                if (nameMatch && regexMatch) {
                    const fullName = nameMatch[1].trim();
                    const [category, name] = fullName.split(': ');
                    const regexString = regexMatch[1];
                    const flags = regexMatch[2]; // Includes 'g' and 'i'

                    if (!LORCANA_PATTERNS[category]) {
                        LORCANA_PATTERNS[category] = [];
                    }

                    LORCANA_PATTERNS[category].push({
                        name: name,
                        fullName: fullName,
                        regex: new RegExp(regexString, flags) // The 'i' flag makes it case-insensitive
                    });
                }
            });
            console.log("Lorcana patterns parsed and stored:", LORCANA_PATTERNS);
        }

        // --- Deck Parsing ---
        function parseDeckString(deckString) {
            console.log("Parsing deck string:", deckString.substring(0, 50) + "...");
            const lines = deckString.trim().split('\n');
            const characters = [];
            const songs = [];
            const locations = []; // Added for locations
            const uniqueCharNames = new Set();
            const uniqueSongNames = new Set();
            const uniqueLocationNames = new Set(); // Added for locations


            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                const match = line.match(/^(\d+)\s+(.+)/);
                if (match) {
                    const count = parseInt(match[1], 10);
                    const cardName = match[2].trim();
                    const cardData = ALL_CARDS_MAP.get(cardName);

                    if (cardData) {
                        if (cardData.type === 'Character') {
                            if (!uniqueCharNames.has(cardData.fullName)) {
                                characters.push({ cardInfo: cardData, count: count });
                                uniqueCharNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Action' && cardData.subtypes?.includes('Song')) {
                            if (!uniqueSongNames.has(cardData.fullName)) {
                                songs.push({ cardInfo: cardData, count: count });
                                uniqueSongNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Location') { // Added location check
                            if (!uniqueLocationNames.has(cardData.fullName)) {
                                locations.push({ cardInfo: cardData, count: count });
                                uniqueLocationNames.add(cardData.fullName);
                            }
                        }
                    } else {
                        console.warn(`Card not found during parsing: ${cardName}`);
                    }
                } else {
                    console.warn(`Invalid deck line format during parsing: ${line}`);
                }
            });
            const parsedResult = {
                characters: Array.from(uniqueCharNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })),
                songs: Array.from(uniqueSongNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })),
                locations: Array.from(uniqueLocationNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })) // Added locations
            };
            console.log("Deck parsed. Characters:", parsedResult.characters.length, "Songs:", parsedResult.songs.length, "Locations:", parsedResult.locations.length);
            return parsedResult;
        }

        // --- Keyword Extraction ---
        function extractCharacterKeywords(card) {
            const keywords = { Resist: 0, Challenger: 0, Evasive: false, Ward: false };
            const otherKeywords = ['support', 'bodyguard', 'reckless', 'singer'];

            if (card.abilities && Array.isArray(card.abilities)) {
                card.abilities.forEach(ability => {
                    if (ability.type === 'keyword') {
                        const lowerKeyword = ability.keyword.toLowerCase();
                        if (lowerKeyword === 'resist') keywords.Resist = ability.keywordValueNumber || 0;
                        else if (lowerKeyword === 'challenger') keywords.Challenger = ability.keywordValueNumber || 0;
                        else if (lowerKeyword === 'evasive') keywords.Evasive = true;
                        else if (lowerKeyword === 'ward') keywords.Ward = true;
                        else if (otherKeywords.includes(lowerKeyword)) {
                            keywords[ability.keyword.toLowerCase()] = true;
                        }
                    }
                });
            }
            if (card.subtypes && Array.isArray(card.subtypes)) {
                card.subtypes.forEach(subtype => {
                    keywords[subtype.toLowerCase()] = true;
                });
            }
            return keywords;
        }

        // --- Banish Condition Checker ---
        function checkBanishConditions(pattern, match, targetCharacterCard, abilityText) {
            console.log(`Checking banish conditions for pattern: ${pattern.name}, target: ${targetCharacterCard.fullName}, ability: ${abilityText.substring(0, 50)}...`);

            // Handle special cases that don't target opponent characters
            if (pattern.name === 'This Character') {
                return {
                    canBanish: false,
                    details: `'${pattern.name}' only affects the source character, not opponent characters.`
                };
            }

            if (pattern.name === 'As a Cost/Choice') {
                return {
                    canBanish: false,
                    details: `'${pattern.name}' is a cost/choice effect, not targeting opponent characters.`
                };
            }

            if (pattern.name === "Opponent's Choice") {
                return {
                    canBanish: true,
                    details: `'${pattern.name}' lets opponent choose their own character to banish.`
                };
            }

            const targetCharStrength = targetCharacterCard.strength || 0;
            const targetCharWillpower = targetCharacterCard.willpower || 0;
            const targetCharCost = targetCharacterCard.cost || 0;

            // Extract the condition part from the ability text
            const conditionMatch = abilityText.match(/with (\d+) (¤|⬡|⛉) or (less|more)/i);

            if (!conditionMatch) {
                // No specific condition - can banish any character
                console.log(`No condition found, can banish any character`);
                return {
                    canBanish: true,
                    details: `Can banish any character via '${pattern.name}'.`
                };
            }

            const conditionValue = parseInt(conditionMatch[1], 10);
            const statType = conditionMatch[2]; // ¤ (strength), ⬡ (cost), ⛉ (willpower)
            const comparison = conditionMatch[3]; // "less" or "more"

            console.log(`Condition found: ${conditionValue} ${statType} or ${comparison}`);

            let targetStat;
            let statName;

            switch (statType) {
                case '¤': // Strength
                    targetStat = targetCharStrength;
                    statName = 'strength';
                    break;
                case '⬡': // Cost
                    targetStat = targetCharCost;
                    statName = 'cost';
                    break;
                case '⛉': // Willpower
                    targetStat = targetCharWillpower;
                    statName = 'willpower';
                    break;
                default:
                    // Unknown stat type, assume it can banish
                    return {
                        canBanish: true,
                        details: `Can banish via '${pattern.name}' (unknown stat condition).`
                    };
            }

            let canBanish;
            if (comparison === 'less') {
                canBanish = targetStat <= conditionValue;
            } else if (comparison === 'more') {
                canBanish = targetStat >= conditionValue;
            } else {
                // Unknown comparison, assume it can banish
                canBanish = true;
            }

            console.log(`Target has ${statName} ${targetStat}, condition: ${comparison} than ${conditionValue}, canBanish: ${canBanish}`);

            if (canBanish) {
                return {
                    canBanish: true,
                    details: `Can banish character with ${statName} ${comparison} than or equal to ${conditionValue} (target has ${targetStat}).`
                };
            } else {
                return {
                    canBanish: false,
                    details: `Cannot banish character with ${statName} ${comparison} than or equal to ${conditionValue} (target has ${targetStat}).`
                };
            }
        }

        // --- Matchup Calculation (Characters) ---
        function calculateSingleMatchup(playerCharData, opponentCharData, turnType) {
            const pKeywords = extractCharacterKeywords(playerCharData);
            const oKeywords = extractCharacterKeywords(opponentCharData);
            let pStrength = playerCharData.strength || 0;
            const pWillpower = playerCharData.willpower || 0;
            const pCost = playerCharData.cost || 0;
            let oStrength = opponentCharData.strength || 0;
            const oWillpower = opponentCharData.willpower || 0;
            const oCost = opponentCharData.cost || 0;

            if (turnType === 'player' && oKeywords.Evasive && !pKeywords.Evasive) return { outcomeName: "NoInteraction_OpponentEvasive", classification: "Neutral", details: "Opponent is Evasive" };
            if (turnType === 'opponent' && pKeywords.Evasive && !oKeywords.Evasive) return { outcomeName: "NoInteraction_PlayerEvasive", classification: "Neutral", details: "Your character is Evasive" };

            if (turnType === 'player' && pKeywords.Challenger > 0) pStrength += pKeywords.Challenger;
            if (turnType === 'opponent' && oKeywords.Challenger > 0) oStrength += oKeywords.Challenger;

            let damageToPlayer = Math.max(0, oStrength - pKeywords.Resist);
            let damageToOpponent = Math.max(0, pStrength - oKeywords.Resist);

            const playerBanished = damageToPlayer >= pWillpower;
            const opponentBanished = damageToOpponent >= oWillpower;

            let result;
            if (playerBanished && opponentBanished) {
                const inkDiff = oCost - pCost;
                let classification = "Neutral";
                if (inkDiff >= 2) classification = "Positive";
                else if (inkDiff <= -2) classification = "Negative";
                result = { outcomeName: "BothBanished", classification, details: `Ink Diff (Opp-Player): ${inkDiff}` };
            } else if (!opponentBanished && playerBanished) {
                result = { outcomeName: "OpponentSurvives_PlayerBanished", classification: "Negative", details: "Your character banished" };
            } else if (opponentBanished && !playerBanished) {
                result = { outcomeName: "PlayerSurvives_OpponentBanished", classification: "Positive", details: "Opponent character banished" };
            } else if (!opponentBanished && !playerBanished) {
                result = { outcomeName: "BothSurvive", classification: "Neutral", details: "Stalemate, both survive" };
            } else {
                result = { outcomeName: "Unknown", classification: "Neutral", details: "Error in logic" };
            }
            return result;
        }

        // --- Generic Ability/Effect Interaction Analysis (Refactored) ---
        function classifyAbilityEffectOnTarget(sourceCardInfo, abilityText, targetCharacterCard, sourceIsPlayerPerspective) {
            const cleanedAbilityText = (abilityText || "").replace(/\n/g, ' ').trim();
            if (!cleanedAbilityText) {
                return { classification: "NoInteraction", details: "No ability text.", card: sourceCardInfo };
            }

            const targetCharKeywords = extractCharacterKeywords(targetCharacterCard);
            const targetCharWillpower = targetCharacterCard.willpower || 0;

            // Ward Check: Ward protects from being CHOSEN, except by effects that say "each" or "all".
            const isSingleTarget = cleanedAbilityText.toLowerCase().includes('chosen');
            if (targetCharKeywords.Ward && isSingleTarget) {
                return { classification: "NoInteractionDueToWard", details: "Target character has Ward, protected from 'chosen' effects.", card: sourceCardInfo };
            }

            for (const category in LORCANA_PATTERNS) {
                for (const pattern of LORCANA_PATTERNS[category]) {
                    const match = cleanedAbilityText.match(pattern.regex);
                    if (match) {
                        // We have a match, now we interpret it based on the category and name
                        switch (category) {
                            case 'Banish':
                                console.log(`Banish match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                // Check specific banish conditions against target character
                                const banishResult = checkBanishConditions(pattern, match, targetCharacterCard, cleanedAbilityText);
                                if (banishResult.canBanish) {
                                    console.log(`Banish result: ${banishResult.details}`);
                                    return { classification: "DirectRemoval", details: banishResult.details, card: sourceCardInfo };
                                } else {
                                    return { classification: "NoInteraction", details: banishResult.details, card: sourceCardInfo };
                                }

                            case 'Damage':
                                console.log(`Damage match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                const damageAmount = parseInt(match[1], 10) || 0;
                                console.log(`Damage amount: ${damageAmount}`);
                                if (damageAmount > 0) {
                                    if (damageAmount >= targetCharWillpower) {
                                        return { classification: "DirectRemoval", details: `Deals ${damageAmount} damage (lethal).`, card: sourceCardInfo };
                                    } else {
                                        return { classification: "PotentialRemoval", details: `Deals ${damageAmount} damage.`, card: sourceCardInfo };
                                    }
                                }
                                break; // Continue if damage amount is not clear
                            case 'Bounce':
                                console.log(`Bounce match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                return { classification: "DirectRemoval", details: `Bounces ${pattern.name}.`, card: sourceCardInfo };
                            case 'Add to Inkwell':
                                console.log(`Add to Inkwell match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName} `);
                                return { classification: "DirectRemoval", details: `Adds to Inkwell ${pattern.name}.`, card: sourceCardInfo };
                            case 'State':
                                // These affect the character but don't remove it
                                return { classification: "AffectsNoRemoval", details: `Matched '${pattern.fullName}'.`, card: sourceCardInfo };

                            case 'Static':
                                if (pattern.name.includes('Cannot Be Challenged')) {
                                    return { classification: "AffectsNoRemoval", details: `Cannot be challenged.`, card: sourceCardInfo };
                                }
                                break;
                        }
                    }
                }
            }

            // Fallback for text that doesn't match a specific pattern but might still be relevant
            // const genericTargeting = /character|item|location/i;
            // if (genericTargeting.test(cleanedAbilityText)) {
            //     return { classification: "PotentialRemoval", details: "Targets character with an unclassified effect.", card: sourceCardInfo };
            // }

            return { classification: "NoInteraction", details: "Effect does not appear to target characters.", card: sourceCardInfo };
        }

        // --- Location Interaction Analysis (Refactored) ---
        function classifyLocationInteraction(sourceCardInfo, abilityText, sourceIsPlayerPerspective) {
            const cleanedAbilityText = (abilityText || "").replace(/\n/g, ' ').trim();
            if (!cleanedAbilityText) return null;

            const banishPatterns = LORCANA_PATTERNS['Banish'] || [];
            const damagePatterns = LORCANA_PATTERNS['Damage'] || [];

            for (const pattern of banishPatterns) {
                if (pattern.regex.test(cleanedAbilityText) && cleanedAbilityText.toLowerCase().includes('location')) {
                    return { canInteract: true, interactionType: "Banish", details: `Can banish a location via '${pattern.name}'.`, card: sourceCardInfo };
                }
            }
            for (const pattern of damagePatterns) {
                if (pattern.regex.test(cleanedAbilityText) && cleanedAbilityText.toLowerCase().includes('location')) {
                    return { canInteract: true, interactionType: "Damage", details: `Can damage a location via '${pattern.name}'.`, card: sourceCardInfo };
                }
            }

            // Generic fallback
            if (cleanedAbilityText.toLowerCase().includes('chosen location')) {
                return { canInteract: true, interactionType: "Target", details: "Can target a location.", card: sourceCardInfo };
            }

            return null;
        }


        function getActiveAbilitiesForCharacter(characterCard, analysisContext) {
            const activeAbilities = [];
            if (!characterCard.abilities || !Array.isArray(characterCard.abilities)) {
                return activeAbilities;
            }

            // Expanded list of player-turn triggers using new patterns
            const playerTurnTriggers = [
                'On Play', 'On Challenging', 'On Quest', 'Start of Turn',
                'On Playing Other Character', 'On Playing Song', 'On Banishing Other',
                'On Readying', 'On Healing', 'On Opponent Damaged', 'On Any Character Challenging',
                'On Inking', 'On Moving to Location', 'On Drawing Card'
            ];

            // Opponent-turn triggers
            const opponentTurnTriggers = [
                'On Being Challenged', 'On Being Challenged and Banished',
                'Start of Turn'
            ];

            characterCard.abilities.forEach(ability => {
                const cleanedFullText = (ability.fullText || "").replace(/\n/g, ' ');
                let isRelevant = false;
                let hasSpecificTrigger = false;

                const relevantPatterns = analysisContext.perspective === "playerTurn" ? playerTurnTriggers : opponentTurnTriggers;

                for (const patternName of relevantPatterns) {
                    const patternCategory = LORCANA_PATTERNS['Trigger'] || [];
                    const pattern = patternCategory.find(p => p.name === patternName);
                    if (pattern && pattern.regex.test(cleanedFullText)) {
                        isRelevant = true;
                        hasSpecificTrigger = true;
                        break;
                    }
                }

                // If it's a static ability or activated ability (which can be used on your turn),
                // or if it has no specific, parsed trigger, assume it's potentially active.
                if (ability.type === 'static' || (cleanedFullText.includes('—') && analysisContext.perspective === "playerTurn") || !hasSpecificTrigger) {
                    isRelevant = true;
                }

                if (isRelevant && ability.fullText) {
                    activeAbilities.push({ text: cleanedFullText, name: ability.name || "Unnamed Ability" });
                }
            });
            return activeAbilities;
        }

        // --- Event Handlers & UI Updates ---
        function populateCardGrid() {
            playerCardsGrid.innerHTML = '';
            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;

            let cardsToShow = [];
            if (selectedMode === 'character') {
                cardsToShow = PLAYER_DECK_CHARS;
                cardSelectionTitle.textContent = 'Select a Character to Analyze';
            } else {
                cardsToShow = PLAYER_DECK_SONGS;
                cardSelectionTitle.textContent = 'Select a Song to Analyze';
            }

            if (cardsToShow.length === 0) {
                playerCardsGrid.innerHTML = `<p class="text-center text-gray-400 italic col-span-full">No ${selectedMode}s in your deck.</p>`;
                return;
            }

            cardsToShow.forEach((cardEntry, index) => {
                const card = cardEntry.cardInfo;
                const cardElement = document.createElement('div');
                cardElement.className = 'selectable-card';
                cardElement.dataset.index = index;
                cardElement.dataset.type = selectedMode;

                const img = document.createElement('img');
                img.src = card.images?.thumbnail || `https://placehold.co/100x140/2d3748/e2e8f0?text=${card.name.substring(0, 10)}`;
                img.alt = card.fullName;
                img.className = 'card-image';
                img.onerror = () => { img.src = `https://placehold.co/100x140/2d3748/e2e8f0?text=Error`; };

                const nameElement = document.createElement('div');
                nameElement.className = 'card-name';
                nameElement.textContent = card.name;

                cardElement.appendChild(img);
                cardElement.appendChild(nameElement);

                // Add click handler
                cardElement.addEventListener('click', () => {
                    // Remove previous selection
                    const previouslySelected = playerCardsGrid.querySelector('.selectable-card.selected');
                    if (previouslySelected) {
                        previouslySelected.classList.remove('selected');
                    }

                    // Select this card
                    cardElement.classList.add('selected');
                    selectedCardIndex = index;
                    selectedCardType = selectedMode;

                    // Trigger analysis
                    displayAnalysisResults();
                });

                playerCardsGrid.appendChild(cardElement);
            });
        }

        function handleAnalysisModeChange() {
            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;
            console.log("Analysis mode changed to:", selectedMode);

            // Reset selection when mode changes
            selectedCardIndex = -1;
            selectedCardType = null;

            // Update challenge perspective visibility
            if (selectedMode === 'character') {
                challengePerspectiveContainer.classList.remove('hidden');
            } else { // song mode
                challengePerspectiveContainer.classList.add('hidden');
            }

            // Repopulate grid with new card type
            if (cardSelectionGrid.classList.contains('hidden') === false) {
                populateCardGrid();
            }

            // Clear results
            resultsDisplay.innerHTML = '';
        }

        function handleAnalyzeButtonClick() {
            console.log("Analyze button clicked.");
            const playerData = parseDeckString(playerDeckInput.value);
            PLAYER_DECK_CHARS = playerData.characters;
            PLAYER_DECK_SONGS = playerData.songs;
            PLAYER_DECK_LOCATIONS = playerData.locations;

            const opponentData = parseDeckString(opponentDeckInput.value);
            OPPONENT_DECK_CHARS = opponentData.characters;
            OPPONENT_DECK_SONGS = opponentData.songs;
            OPPONENT_DECK_LOCATIONS = opponentData.locations;

            // --- UWPM Phase 1: Enrich cards with features ---
            const playerUWPCards = PLAYER_DECK_CHARS.map(entry => extractCardFeatures(entry.cardInfo, LORCANA_PATTERNS));
            const opponentUWPCards = OPPONENT_DECK_CHARS.map(entry => extractCardFeatures(entry.cardInfo, LORCANA_PATTERNS));
            console.log('UWPM Player UWPCard objects:', playerUWPCards);
            console.log('UWPM Opponent UWPCard objects:', opponentUWPCards);

            // --- UWPM Phase 2: Calculate intrinsic deck scores ---
            const playerRDS = calculateRDS(playerUWPCards);
            const playerLVI = calculateLVI(playerUWPCards);
            const playerBCR = calculateBCR(playerUWPCards);
            const opponentRDS = calculateRDS(opponentUWPCards);
            const opponentLVI = calculateLVI(opponentUWPCards);
            const opponentBCR = calculateBCR(opponentUWPCards);
            console.log('UWPM Player RDS:', playerRDS, 'LVI:', playerLVI, 'BCR:', playerBCR);
            console.log('UWPM Opponent RDS:', opponentRDS, 'LVI:', opponentLVI, 'BCR:', opponentBCR);

            // --- UWPM Phase 3: Calculate win probability ---
            const winProb = calculateWinProbability(playerUWPCards, opponentUWPCards);
            console.log('UWPM Win Probability (Player Deck):', winProb, '(', (winProb * 100).toFixed(1) + '% )');

            console.log("Decks loaded. Player Chars:", PLAYER_DECK_CHARS.length, "Player Songs:", PLAYER_DECK_SONGS.length, "Player Locations:", PLAYER_DECK_LOCATIONS.length);
            console.log("Opponent Chars:", OPPONENT_DECK_CHARS.length, "Opponent Songs:", OPPONENT_DECK_SONGS.length, "Opponent Locations:", OPPONENT_DECK_LOCATIONS.length);

            // Reset selection state
            selectedCardIndex = -1;
            selectedCardType = null;

            // Populate the card grid
            populateCardGrid();

            analysisControls.classList.remove('hidden');
            cardSelectionGrid.classList.remove('hidden');
            handleAnalysisModeChange();

            // --- UWPM Phase 4: UI Integration ---
            const winProbDisplay = document.getElementById('win-probability-display');
            if (playerUWPCards.length > 0 && opponentUWPCards.length > 0) {
                // Store weights in a mutable object for live editing
                const weights = { rds: 0.15, lvi: 0.25, bcr: 0.25, aim: 1.0, tfa: 1.0, taes: 1.0 };
                const k = 1;

                // Helper for tooltips
                function infoIcon(text) {
                    return `<span class=\"ml-1 cursor-pointer text-blue-300\" title=\"${text.replace(/\"/g, '&quot;')}\">&#9432;</span>`;
                }

                // Function to recalculate and update the table and probability
                function updateUWPMTable() {
                    // Parse weights from inputs
                    weights.rds = parseFloat(document.getElementById('uwpm-weight-rds').value) || 0;
                    weights.lvi = parseFloat(document.getElementById('uwpm-weight-lvi').value) || 0;
                    weights.bcr = parseFloat(document.getElementById('uwpm-weight-bcr').value) || 0;
                    weights.aim = parseFloat(document.getElementById('uwpm-weight-aim').value) || 0;
                    weights.tfa = parseFloat(document.getElementById('uwpm-weight-tfa').value) || 0;
                    weights.taes = parseFloat(document.getElementById('uwpm-weight-taes').value) || 0;

                    // Calculate contributions
                    const contribRDS = weights.rds * (playerRDS - opponentRDS);
                    const contribLVI = weights.lvi * (playerLVI - opponentLVI);
                    const contribBCR = weights.bcr * (playerBCR - opponentBCR);
                    const contribAIM = weights.aim * 0;
                    const contribTFA = weights.tfa * 0;
                    const contribTAES = weights.taes * 0;
                    const matchupScore = contribRDS + contribLVI + contribBCR + contribAIM + contribTFA + contribTAES;
                    const winProb = 1 / (1 + Math.exp(-k * matchupScore));
                    const winPercent = (winProb * 100).toFixed(1);
                    const lossPercent = (100 - winPercent).toFixed(1);

                    // Update the table and probability
                    document.getElementById('uwpm-win-chance').textContent = `${winPercent}%`;
                    document.getElementById('uwpm-opp-chance').textContent = `(Opponent's Chance: ${lossPercent}%)`;
                    document.getElementById('uwpm-matchup-score').textContent = matchupScore.toFixed(3);
                    document.getElementById('uwpm-logistic').textContent = `1 / (1 + exp(-k × Matchup Score)), k = ${k}`;
                    document.getElementById('uwpm-final-prob').textContent = `${winPercent}%`;
                    document.getElementById('uwpm-contrib-rds').textContent = contribRDS.toFixed(3);
                    document.getElementById('uwpm-contrib-lvi').textContent = contribLVI.toFixed(3);
                    document.getElementById('uwpm-contrib-bcr').textContent = contribBCR.toFixed(3);
                    document.getElementById('uwpm-contrib-aim').textContent = contribAIM.toFixed(3);
                    document.getElementById('uwpm-contrib-tfa').textContent = contribTFA.toFixed(3);
                    document.getElementById('uwpm-contrib-taes').textContent = contribTAES.toFixed(3);
                }

                // Initial values
                const contribRDS = weights.rds * (playerRDS - opponentRDS);
                const contribLVI = weights.lvi * (playerLVI - opponentLVI);
                const contribBCR = weights.bcr * (playerBCR - opponentBCR);
                const contribAIM = weights.aim * 0;
                const contribTFA = weights.tfa * 0;
                const contribTAES = weights.taes * 0;
                const matchupScore = contribRDS + contribLVI + contribBCR + contribAIM + contribTFA + contribTAES;
                const winProb = 1 / (1 + Math.exp(-k * matchupScore));
                const winPercent = (winProb * 100).toFixed(1);
                const lossPercent = (100 - winPercent).toFixed(1);

                winProbDisplay.innerHTML = `
                    <p class=\"text-xl\">Your Deck's Estimated Win Chance:</p>
                    <p id=\"uwpm-win-chance\" class=\"text-5xl font-bold text-green-400 my-2\">${winPercent}%</p>
                    <p id=\"uwpm-opp-chance\" class=\"text-lg text-gray-400\">(Opponent's Chance: ${lossPercent}%)</p>
                    <div class=\"mt-6 text-left max-w-2xl mx-auto bg-gray-900 rounded-lg p-4 shadow-inner\">
                        <h3 class=\"text-lg font-semibold text-purple-300 mb-2\">UWPM Calculation Breakdown</h3>
                        <div class=\"overflow-x-auto\">
                        <table class=\"w-full text-sm text-left border-collapse\">
                            <thead>
                                <tr class=\"border-b border-gray-700\">
                                    <th class=\"py-1 px-2\">Metric</th>
                                    <th class=\"py-1 px-2\">Player</th>
                                    <th class=\"py-1 px-2\">Opponent</th>
                                    <th class=\"py-1 px-2\">Weight</th>
                                    <th class=\"py-1 px-2\">Contribution</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class=\"py-1 px-2\">RDS ${infoIcon('Resource Dominance Score: Measures card advantage, ink acceleration, and uninkable burden.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">${playerRDS.toFixed(2)}</td>
                                    <td class=\"py-1 px-2 text-pink-300\">${opponentRDS.toFixed(2)}</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-rds\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.rds}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-rds\">${contribRDS.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">LVI ${infoIcon('Lore Velocity Index: Measures lore gain potential, survivability, and quest safety.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">${playerLVI.toFixed(2)}</td>
                                    <td class=\"py-1 px-2 text-pink-300\">${opponentLVI.toFixed(2)}</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-lvi\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.lvi}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-lvi\">${contribLVI.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">BCR ${infoIcon('Board Control Rating: Measures removal, versatility, and proactive board presence.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">${playerBCR.toFixed(2)}</td>
                                    <td class=\"py-1 px-2 text-pink-300\">${opponentBCR.toFixed(2)}</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-bcr\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.bcr}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-bcr\">${contribBCR.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">AIM ${infoIcon('Archetype Interaction Modifier: Placeholder for matchup-specific archetype effects.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">0</td>
                                    <td class=\"py-1 px-2 text-pink-300\">0</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-aim\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.aim}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-aim\">${contribAIM.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">TFA ${infoIcon('Tempo Flow Analysis: Placeholder for tempo-based matchup effects.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">0</td>
                                    <td class=\"py-1 px-2 text-pink-300\">0</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-tfa\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.tfa}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-tfa\">${contribTFA.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">TAES ${infoIcon('Threat-Answer Efficiency Score: Placeholder for threat/answer matchup effects.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">0</td>
                                    <td class=\"py-1 px-2 text-pink-300\">0</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-taes\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.taes}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-taes\">${contribTAES.toFixed(3)}</span></td>
                                </tr>
                            </tbody>
                        </table>
                        </div>
                        <div class=\"mt-4 mb-2\"><b>Matchup Score:</b> <span id=\"uwpm-matchup-score\" class=\"text-yellow-200\">${matchupScore.toFixed(3)}</span></div>
                        <div class=\"mb-2\"><b>Logistic Function:</b> <span id=\"uwpm-logistic\" class=\"text-gray-300\">1 / (1 + exp(-k × Matchup Score)), k = ${k}</span></div>
                        <div class=\"mb-2\"><b>Final Win Probability:</b> <span id=\"uwpm-final-prob\" class=\"text-green-400\">${winPercent}%</span></div>
                    </div>
                `;

                // Add event listeners for all weight inputs
                [
                    'uwpm-weight-rds',
                    'uwpm-weight-lvi',
                    'uwpm-weight-bcr',
                    'uwpm-weight-aim',
                    'uwpm-weight-tfa',
                    'uwpm-weight-taes',
                ].forEach(id => {
                    const input = document.getElementById(id);
                    if (input) {
                        input.addEventListener('input', updateUWPMTable);
                    }
                });

                // Tooltips are handled via the title attribute for now

            } else {
                winProbDisplay.innerHTML = `<p class=\"text-lg text-gray-400\">Load both decks to calculate win probability.</p>`;
            }
        }

        function displayAnalysisResults() {
            console.log("Displaying analysis results...");
            resultsDisplay.innerHTML = '';

            // Check if a card is selected
            if (selectedCardIndex === -1 || selectedCardType === null) {
                resultsDisplay.innerHTML = `<p class="text-center text-gray-400 italic">Please select a card from the grid above to analyze.</p>`;
                return;
            }

            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;
            console.log("Current analysis mode for display:", selectedMode);

            if (selectedMode === 'character') {
                displayCharacterAnalysis();
            } else {
                displayPlayerSongAnalysis();
            }
            // Always display location analysis regardless of character/song mode, if decks are loaded
            if (PLAYER_DECK_CHARS.length > 0 || PLAYER_DECK_SONGS.length > 0 || OPPONENT_DECK_CHARS.length > 0 || OPPONENT_DECK_SONGS.length > 0) {
                displayLocationInteractionAnalysis();
            }
        }

        function displayCharacterAnalysis() {
            console.log("Displaying Character Analysis.");
            if (PLAYER_DECK_CHARS.length === 0 || selectedCardIndex === -1 || selectedCardType !== 'character') {
                resultsDisplay.innerHTML += `<p class="text-center text-gray-400 italic">Please load decks and select a character to analyze.</p>`;
                return;
            }

            const playerCharEntry = PLAYER_DECK_CHARS[selectedCardIndex];
            if (!playerCharEntry) {
                resultsDisplay.innerHTML += `<p class="text-yellow-400 text-center">Invalid character selection.</p>`;
                console.warn("Invalid player character selection index:", selectedCardIndex);
                return;
            }
            const playerChar = playerCharEntry.cardInfo;
            const turnType = turnContextSelect.value;
            console.log(`Analyzing player character: ${playerChar.fullName}, Turn type: ${turnType}`);

            const overallAnalysisContainer = document.createElement('div');

            const playerCharDisplay = document.createElement('div');
            playerCharDisplay.className = 'text-center mb-6 pb-4 border-b border-gray-700';
            const pKeywords = extractCharacterKeywords(playerChar);
            let pKeywordStr = Object.entries(pKeywords)
                .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                .map(([key, value]) => {
                    if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                    return key.charAt(0).toUpperCase() + key.slice(1);
                }).join(', ');
            if (!pKeywordStr) pKeywordStr = 'No notable keywords/subtypes';

            const pAllTraitsStr = extractAllCharacterTraits(playerChar);

            playerCharDisplay.innerHTML = `
                <h2 class="text-2xl font-bold text-purple-300 mb-2">Analysis for Your Character: ${playerChar.fullName}</h2>
                <img src="${playerChar.images?.thumbnail || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Img'}" alt="${playerChar.fullName}" class="card-image mx-auto mb-2">
                <p class="text-sm text-gray-300">Cost: ${playerChar.cost || 'N/A'} | Str: ${playerChar.strength || 'N/A'} | Wp: ${playerChar.willpower || 'N/A'} | Lore: ${playerChar.lore || '0'}</p>
                <p class="text-xs text-gray-400"><b>Traits:</b> ${pAllTraitsStr}</p>
            `;
            overallAnalysisContainer.appendChild(playerCharDisplay);

            // Character Matchups Section
            const charMatchupSection = document.createElement('section');
            charMatchupSection.className = 'analysis-section';
            const charMatchupTitle = document.createElement('h3');
            charMatchupTitle.className = 'section-title';
            charMatchupTitle.textContent = "Character Matchups (vs Opponent's Characters)";
            charMatchupSection.appendChild(charMatchupTitle);

            if (OPPONENT_DECK_CHARS.length > 0) {
                const analysisResults = { noInteraction: [], bothBanishedPositive: [], bothBanishedNeutral: [], bothBanishedNegative: [], opponentSurvivesPlayerBanished: [], playerSurvivesOpponentBanished: [], bothSurvive: [] };
                OPPONENT_DECK_CHARS.forEach(opponentCharEntry => {
                    const matchup = calculateSingleMatchup(playerChar, opponentCharEntry.cardInfo, turnType);
                    const opponentCard = opponentCharEntry.cardInfo;
                    if (matchup.outcomeName.startsWith("NoInteraction")) analysisResults.noInteraction.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "BothBanished") {
                        if (matchup.classification === "Positive") analysisResults.bothBanishedPositive.push({ card: opponentCard, details: matchup.details });
                        else if (matchup.classification === "Negative") analysisResults.bothBanishedNegative.push({ card: opponentCard, details: matchup.details });
                        else analysisResults.bothBanishedNeutral.push({ card: opponentCard, details: matchup.details });
                    }
                    else if (matchup.outcomeName === "OpponentSurvives_PlayerBanished") analysisResults.opponentSurvivesPlayerBanished.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "PlayerSurvives_OpponentBanished") analysisResults.playerSurvivesOpponentBanished.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "BothSurvive") analysisResults.bothSurvive.push({ card: opponentCard, details: matchup.details });
                });

                const charGrid = document.createElement('div');
                charGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';
                charGrid.appendChild(createOutcomeSectionDOM("CAN'T CHALLENGE/BE CHALLENGED BY", analysisResults.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-600'));
                charGrid.appendChild(createOutcomeSectionDOM("FAVORABLE (Player Survives, Opp Banished)", analysisResults.playerSurvivesOpponentBanished, OPPONENT_DECK_CHARS.length, 'bg-green-700'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Favorable Ink)", analysisResults.bothBanishedPositive, OPPONENT_DECK_CHARS.length, 'bg-green-600'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Neutral Ink)", analysisResults.bothBanishedNeutral, OPPONENT_DECK_CHARS.length, 'bg-yellow-600'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Unfavorable Ink)", analysisResults.bothBanishedNegative, OPPONENT_DECK_CHARS.length, 'bg-red-600'));
                charGrid.appendChild(createOutcomeSectionDOM("UNFAVORABLE (Opp Survives, Player Banished)", analysisResults.opponentSurvivesPlayerBanished, OPPONENT_DECK_CHARS.length, 'bg-red-700'));
                charGrid.appendChild(createOutcomeSectionDOM("STALEMATE (Both Survive Challenge)", analysisResults.bothSurvive, OPPONENT_DECK_CHARS.length, 'bg-blue-600'));
                charMatchupSection.appendChild(charGrid);
            } else {
                charMatchupSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters loaded for matchup analysis.</p>`;
            }
            overallAnalysisContainer.appendChild(charMatchupSection);

            // Player Character's Abilities Impact Section
            if (turnType === "player") {
                const playerAbilitiesSection = document.createElement('section');
                playerAbilitiesSection.className = 'analysis-section';
                const playerAbilitiesTitle = document.createElement('h3');
                playerAbilitiesTitle.className = 'section-title';
                playerAbilitiesTitle.textContent = `Your "${playerChar.name}" Abilities vs Opponent's Characters`;
                playerAbilitiesSection.appendChild(playerAbilitiesTitle);
                console.log(`Analyzing abilities for ${playerChar.name} on player's turn.`);

                const activePlayerAbilities = getActiveAbilitiesForCharacter(playerChar, { perspective: "playerTurn", action: "onPlayOrChallenge" });
                if (activePlayerAbilities.length > 0 && OPPONENT_DECK_CHARS.length > 0) {
                    activePlayerAbilities.forEach(ability => {
                        if (ability.name === "Unnamed Ability") return;
                        console.log(`Processing ability: ${ability.name}`);
                        const abilityImpactTitle = document.createElement('h4');
                        abilityImpactTitle.className = 'ability-title';
                        abilityImpactTitle.textContent = `Ability: ${ability.name}`;
                        playerAbilitiesSection.appendChild(abilityImpactTitle);

                        const abilityImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                        OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                            const classificationResult = classifyAbilityEffectOnTarget(playerChar, ability.text, oppCharEntry.cardInfo, true);
                            const displayItem = {
                                card: oppCharEntry.cardInfo,
                                details: classificationResult.details,
                                classification: classificationResult.classification,
                            };
                            if (classificationResult.classification === "DirectRemoval") abilityImpactOnOppChars.directRemoval.push(displayItem);
                            else if (classificationResult.classification === "PotentialRemoval") abilityImpactOnOppChars.potentialRemoval.push(displayItem);
                            else if (classificationResult.classification === "AffectsNoRemoval") abilityImpactOnOppChars.affectsNoRemoval.push(displayItem);
                            else abilityImpactOnOppChars.noInteraction.push(displayItem);
                        });
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Directly Removes Opp Chars (via ${ability.name})`, abilityImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-800', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Potentially Removes Opp Chars (via ${ability.name})`, abilityImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-700 text-black', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Affects Opp Chars (No Direct Removal via ${ability.name})`, abilityImpactOnOppChars.affectsNoRemoval, OPPONENT_DECK_CHARS.length, 'bg-teal-800', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`No Interaction with Opp Chars / Warded (via ${ability.name})`, abilityImpactOnOppChars.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-700', playerChar, ability.name));
                    });
                } else if (activePlayerAbilities.length === 0) {
                    playerAbilitiesSection.innerHTML += `<p class="text-center text-gray-400 italic">Your selected character has no relevant active abilities for this turn context.</p>`;
                } else {
                    playerAbilitiesSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters to analyze abilities against.</p>`;
                }
                overallAnalysisContainer.appendChild(playerAbilitiesSection);
            }


            // Opponent's Song Interaction Section
            const opponentSongSection = document.createElement('section');
            opponentSongSection.className = 'analysis-section';
            const opponentSongTitle = document.createElement('h3');
            opponentSongTitle.className = 'section-title';
            opponentSongTitle.textContent = `Opponent's Song Threats vs Your ${playerChar.name}`;
            opponentSongSection.appendChild(opponentSongTitle);
            console.log(`Analyzing opponent songs vs ${playerChar.name}`);

            if (OPPONENT_DECK_SONGS.length > 0) {
                const songAnalysis = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                OPPONENT_DECK_SONGS.forEach(songEntry => {
                    const songFullText = songEntry.cardInfo.effects?.join(' ') || songEntry.cardInfo.fullText || "";
                    const result = classifyAbilityEffectOnTarget(songEntry.cardInfo, songFullText, playerChar, false);
                    if (result.classification === "DirectRemoval") songAnalysis.directRemoval.push(result);
                    else if (result.classification === "PotentialRemoval") songAnalysis.potentialRemoval.push(result);
                    else if (result.classification === "AffectsNoRemoval") songAnalysis.affectsNoRemoval.push(result);
                    else songAnalysis.noInteraction.push(result);
                });

                opponentSongSection.appendChild(createSongBreakdownDOM("DIRECT REMOVAL THREATS", songAnalysis.directRemoval, OPPONENT_DECK_SONGS.length, 'bg-red-700', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("POTENTIAL REMOVAL / HIGH IMPACT", songAnalysis.potentialRemoval, OPPONENT_DECK_SONGS.length, 'bg-yellow-700 text-black', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("AFFECTS (No Direct Removal)", songAnalysis.affectsNoRemoval, OPPONENT_DECK_SONGS.length, 'bg-blue-700', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("NO INTERACTION / WARDED", songAnalysis.noInteraction, OPPONENT_DECK_SONGS.length, 'bg-gray-600', null, playerChar));
            } else {
                opponentSongSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent songs loaded for analysis.</p>`;
            }
            overallAnalysisContainer.appendChild(opponentSongSection);

            // Activated Ability Analysis
            const activatedAbilitySection = document.createElement('section');
            activatedAbilitySection.className = 'analysis-section';
            const activatedAbilityTitle = document.createElement('h3');
            activatedAbilityTitle.className = 'section-title';
            activatedAbilityTitle.textContent = `Your "${playerChar.name}" Activated Abilities vs Opponent's Board`;
            activatedAbilitySection.appendChild(activatedAbilityTitle);

            const activatedPattern = LORCANA_PATTERNS['Activated']?.find(p => p.name === 'Cost-Effect');
            const allAbilitiesText = (playerChar.abilities || []).map(a => a.fullText).join('\n');
            const activatedMatches = activatedPattern ? allAbilitiesText.match(activatedPattern.regex) : null;

            if (activatedMatches && activatedMatches.length > 0) {
                activatedMatches.forEach(abilityText => {
                    const effectText = abilityText.split('—')[1] || '';
                    const abilityImpactTitle = document.createElement('h4');
                    abilityImpactTitle.className = 'ability-title';
                    abilityImpactTitle.textContent = `Activated Ability: "${abilityText}"`;
                    activatedAbilitySection.appendChild(abilityImpactTitle);

                    const abilityImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                    OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                        const classificationResult = classifyAbilityEffectOnTarget(playerChar, effectText, oppCharEntry.cardInfo, true);
                        const displayItem = { card: oppCharEntry.cardInfo, details: classificationResult.details, classification: classificationResult.classification };
                        if (classificationResult.classification === "DirectRemoval") abilityImpactOnOppChars.directRemoval.push(displayItem);
                        else if (classificationResult.classification === "PotentialRemoval") abilityImpactOnOppChars.potentialRemoval.push(displayItem);
                        else if (classificationResult.classification === "AffectsNoRemoval") abilityImpactOnOppChars.affectsNoRemoval.push(displayItem);
                        else abilityImpactOnOppChars.noInteraction.push(displayItem);
                    });

                    activatedAbilitySection.appendChild(createAbilityImpactDOM(`Directly Removes`, abilityImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-800', playerChar, abilityText));
                    activatedAbilitySection.appendChild(createAbilityImpactDOM(`Potentially Affects/Removes`, abilityImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-700 text-black', playerChar, abilityText));
                });
            } else {
                activatedAbilitySection.innerHTML += `<p class="text-center text-gray-400 italic">No activated abilities found on this character.</p>`;
            }
            overallAnalysisContainer.appendChild(activatedAbilitySection);

            // Song Synergy Section
            const songSynergySection = document.createElement('section');
            songSynergySection.className = 'analysis-section';
            songSynergySection.innerHTML = `<h3 class="section-title">Song Synergies (for Your ${playerChar.name})</h3>`;

            const singerAbility = (playerChar.abilities || []).find(a => a.keyword === 'Singer');
            const characterSingValue = singerAbility ? singerAbility.keywordValueNumber : playerChar.cost;

            let canSingList = [];
            let cannotSingList = [];

            PLAYER_DECK_SONGS.forEach(songEntry => {
                const song = songEntry.cardInfo;
                const singCost = getSongSingCost(song);
                if (characterSingValue >= singCost) {
                    canSingList.push({card: song, details: `Can sing (Value ${characterSingValue} >= Cost ${singCost})`});
                } else {
                    cannotSingList.push({card: song, details: `Cannot sing (Value ${characterSingValue} < Cost ${singCost})`});
                }
            });

            songSynergySection.appendChild(createLocationInteractorsDOM("Can Sing These Songs", canSingList, 'bg-blue-800'));
            songSynergySection.appendChild(createLocationInteractorsDOM("Cannot Sing These Songs", cannotSingList, 'bg-gray-700'));
            overallAnalysisContainer.appendChild(songSynergySection);

            resultsDisplay.appendChild(overallAnalysisContainer);
        }

        function displayPlayerSongAnalysis() {
            console.log("Displaying Player Song Analysis.");
            if (PLAYER_DECK_SONGS.length === 0 || selectedCardIndex === -1 || selectedCardType !== 'song') {
                resultsDisplay.innerHTML += `<p class="text-center text-gray-400 italic">Please load decks and select a song to analyze.</p>`;
                return;
            }
            const playerSongEntry = PLAYER_DECK_SONGS[selectedCardIndex];
            if (!playerSongEntry) {
                resultsDisplay.innerHTML += `<p class="text-yellow-400 text-center">Invalid song selection.</p>`;
                console.warn("Invalid player song selection index:", selectedCardIndex);
                return;
            }
            const playerSongToAnalyze = playerSongEntry.cardInfo;
            console.log(`Analyzing player song: ${playerSongToAnalyze.fullName}`);

            const overallAnalysisContainer = document.createElement('div');

            const playerSongDisplay = document.createElement('div');
            playerSongDisplay.className = 'text-center mb-6 pb-4 border-b border-gray-700';
            const songFullTextForDisplay = (playerSongToAnalyze.effects?.join(' ') || playerSongToAnalyze.fullText || 'No effect text.').replace(/\n/g, ' ');
            playerSongDisplay.innerHTML = `
                <h2 class="text-2xl font-bold text-purple-300 mb-2">Analysis for Your Song: ${playerSongToAnalyze.fullName}</h2>
                <img src="${playerSongToAnalyze.images?.thumbnail || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Img'}" alt="${playerSongToAnalyze.fullName}" class="card-image mx-auto mb-2">
                <p class="text-sm text-gray-300">Cost: ${playerSongToAnalyze.cost || 'N/A'} | Inkable: ${playerSongToAnalyze.inkwell ? 'Yes' : 'No'}</p>
                <p class="text-xs text-gray-400">${songFullTextForDisplay}</p>
            `;
            overallAnalysisContainer.appendChild(playerSongDisplay);

            const playerSongImpactSection = document.createElement('section');
            playerSongImpactSection.className = 'analysis-section';
            const playerSongImpactTitle = document.createElement('h3');
            playerSongImpactTitle.className = 'section-title';
            playerSongImpactTitle.textContent = `Impact of Your "${playerSongToAnalyze.name}" on Opponent's Characters`;
            playerSongImpactSection.appendChild(playerSongImpactTitle);

            if (OPPONENT_DECK_CHARS.length > 0) {
                const songImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                const songFullTextForAnalysis = playerSongToAnalyze.effects?.join(' ') || playerSongToAnalyze.fullText || "";

                OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                    const classificationResult = classifyAbilityEffectOnTarget(playerSongToAnalyze, songFullTextForAnalysis, oppCharEntry.cardInfo, true);
                    const displayItem = {
                        card: oppCharEntry.cardInfo,
                        details: classificationResult.details,
                        classification: classificationResult.classification,
                    };
                    if (classificationResult.classification === "DirectRemoval") songImpactOnOppChars.directRemoval.push(displayItem);
                    else if (classificationResult.classification === "PotentialRemoval") songImpactOnOppChars.potentialRemoval.push(displayItem);
                    else if (classificationResult.classification === "AffectsNoRemoval") songImpactOnOppChars.affectsNoRemoval.push(displayItem);
                    else songImpactOnOppChars.noInteraction.push(displayItem);
                });

                playerSongImpactSection.appendChild(createSongBreakdownDOM("DIRECTLY REMOVES OPP CHARS", songImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-700', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("POTENTIALLY REMOVES OPP CHARS", songImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-600 text-black', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("AFFECTS OPP CHARS (No Direct Removal)", songImpactOnOppChars.affectsNoRemoval, OPPONENT_DECK_CHARS.length, 'bg-teal-700', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("NO INTERACTION WITH OPP CHARS / WARDED", songImpactOnOppChars.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-600', playerSongToAnalyze));

            } else {
                playerSongImpactSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters loaded to analyze song against.</p>`;
            }
            overallAnalysisContainer.appendChild(playerSongImpactSection);

            // Eligible Singers Section
            const singersSection = document.createElement('section');
            singersSection.className = 'analysis-section';
            singersSection.innerHTML = `<h3 class="section-title">Eligible Singers in Your Deck (for ${playerSongToAnalyze.name})</h3>`;

            const songSingCost = getSongSingCost(playerSongToAnalyze);
            let eligibleSingers = [];

            PLAYER_DECK_CHARS.forEach(charEntry => {
                const character = charEntry.cardInfo;
                const singerAbility = (character.abilities || []).find(a => a.keyword === 'Singer');
                const singValue = singerAbility ? singerAbility.keywordValueNumber : character.cost;
                if (singValue >= songSingCost) {
                    eligibleSingers.push({card: character, details: `Eligible (Value ${singValue} >= Cost ${songSingCost})`});
                }
            });

            singersSection.appendChild(createLocationInteractorsDOM("Can Sing This Song", eligibleSingers, 'bg-blue-800'));
            overallAnalysisContainer.appendChild(singersSection);

            resultsDisplay.appendChild(overallAnalysisContainer);
        }

        function displayLocationInteractionAnalysis() {
            console.log("Displaying Location Interaction Analysis.");
            const locationAnalysisSection = document.createElement('section');
            locationAnalysisSection.className = 'analysis-section';
            const locationTitle = document.createElement('h3');
            locationTitle.className = 'section-title';
            locationTitle.textContent = 'Location Interaction Analysis';
            locationAnalysisSection.appendChild(locationTitle);

            // Opponent's Threats to Your Locations
            const oppThreatsContainer = document.createElement('div');
            oppThreatsContainer.className = 'mb-6';
            const oppThreatsTitle = document.createElement('h4');
            oppThreatsTitle.className = 'text-lg font-semibold text-red-400 mb-2';
            oppThreatsTitle.textContent = "Opponent's Threats to Your Locations";
            oppThreatsContainer.appendChild(oppThreatsTitle);

            let oppCharsThreateningLocations = [];
            OPPONENT_DECK_CHARS.forEach(oppChar => {
                const activeAbilities = getActiveAbilitiesForCharacter(oppChar.cardInfo, { perspective: "opponentTurn", action: "any" }); // Generic context for location abilities
                activeAbilities.forEach(ability => {
                    const interaction = classifyLocationInteraction(oppChar.cardInfo, ability.text, false); // false: opponent's card
                    if (interaction && interaction.canInteract) {
                        oppCharsThreateningLocations.push({ card: oppChar.cardInfo, details: `Ability: ${ability.name} - ${interaction.details}` });
                    }
                });
            });
            // --- NEW LOGIC: Check for strength-based removal of locations ---
            if (PLAYER_DECK_LOCATIONS.length > 0) {
                PLAYER_DECK_LOCATIONS.forEach(locationEntry => {
                    const location = locationEntry.cardInfo;
                    const locationWillpower = location.willpower || 0;
                    OPPONENT_DECK_CHARS.forEach(oppChar => {
                        const oppStrength = oppChar.cardInfo.strength || 0;
                        if (oppStrength >= locationWillpower && locationWillpower > 0) {
                            oppCharsThreateningLocations.push({
                                card: oppChar.cardInfo,
                                details: `Can remove your location '${location.fullName}' by strength (${oppStrength} ≥ ${locationWillpower})`
                            });
                        }
                    });
                });
            }
            // Remove duplicates by card name if a char has multiple abilities affecting locations
            oppCharsThreateningLocations = Array.from(new Set(oppCharsThreateningLocations.map(item => item.card.fullName + (item.details || '')))
                ).map(key => oppCharsThreateningLocations.find(item => (item.card.fullName + (item.details || '')) === key));
            oppThreatsContainer.appendChild(createLocationInteractorsDOM("Opponent Characters That Can Remove/Target Your Locations", oppCharsThreateningLocations, 'bg-red-800'));

            let oppSongsThreateningLocations = [];
            OPPONENT_DECK_SONGS.forEach(oppSong => {
                const songText = oppSong.cardInfo.effects?.join(' ') || oppSong.cardInfo.fullText || "";
                const interaction = classifyLocationInteraction(oppSong.cardInfo, songText, false);
                if (interaction && interaction.canInteract) {
                    oppSongsThreateningLocations.push({ card: oppSong.cardInfo, details: interaction.details });
                }
            });
            oppThreatsContainer.appendChild(createLocationInteractorsDOM("Opponent Songs That Can Remove/Target Your Locations", oppSongsThreateningLocations, 'bg-red-700'));
            locationAnalysisSection.appendChild(oppThreatsContainer);


            // Your Options Against Opponent's Locations
            const playerOptionsContainer = document.createElement('div');
            const playerOptionsTitle = document.createElement('h4');
            playerOptionsTitle.className = 'text-lg font-semibold text-green-400 mb-2';
            playerOptionsTitle.textContent = "Your Options Against Opponent's Locations";
            playerOptionsContainer.appendChild(playerOptionsTitle);

            let playerCharsRemovingLocations = [];
            PLAYER_DECK_CHARS.forEach(playerChar => {
                const activeAbilities = getActiveAbilitiesForCharacter(playerChar.cardInfo, { perspective: "playerTurn", action: "any" });
                activeAbilities.forEach(ability => {
                    const interaction = classifyLocationInteraction(playerChar.cardInfo, ability.text, true); // true: player's card
                    if (interaction && interaction.canInteract) {
                        playerCharsRemovingLocations.push({ card: playerChar.cardInfo, details: `Ability: ${ability.name} - ${interaction.details}` });
                    }
                });
            });
            playerCharsRemovingLocations = Array.from(new Set(playerCharsRemovingLocations.map(item => item.card.fullName)))
                .map(name => playerCharsRemovingLocations.find(item => item.card.fullName === name));
            playerOptionsContainer.appendChild(createLocationInteractorsDOM("Your Characters That Can Remove/Target Opponent's Locations", playerCharsRemovingLocations, 'bg-green-800'));

            let playerSongsRemovingLocations = [];
            PLAYER_DECK_SONGS.forEach(playerSong => {
                const songText = playerSong.cardInfo.effects?.join(' ') || playerSong.cardInfo.fullText || "";
                const interaction = classifyLocationInteraction(playerSong.cardInfo, songText, true);
                if (interaction && interaction.canInteract) {
                    playerSongsRemovingLocations.push({ card: playerSong.cardInfo, details: interaction.details });
                }
            });
            playerOptionsContainer.appendChild(createLocationInteractorsDOM("Your Songs That Can Remove/Target Opponent's Locations", playerSongsRemovingLocations, 'bg-green-700'));
            locationAnalysisSection.appendChild(playerOptionsContainer);

            resultsDisplay.appendChild(locationAnalysisSection);
        }

        function createOutcomeSectionDOM(title, cardsWithObjects, totalTargetChars, bgColorClass = 'bg-gray-700') {
            const section = document.createElement('div');
            section.className = `outcome-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalTargetChars > 0 ? ((cardsWithObjects.length / totalTargetChars) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            titleElem.textContent = `${title} (${cardsWithObjects.length}/${totalTargetChars} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (cardsWithObjects.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs text-gray-400 italic p-1">None.</p>`;
            } else {
                cardsWithObjects.forEach(obj => {
                    const card = obj.card;
                    const details = obj.details;
                    const keywords = extractCharacterKeywords(card);
                    let keywordStr = Object.entries(keywords)
                        .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                        .map(([key, value]) => {
                            if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                            return key.charAt(0).toUpperCase() + key.slice(1);
                        }).join(', ');
                    if (!keywordStr) keywordStr = 'None';

                    const tooltipText = `Name: ${card.fullName}\nCost: ${card.cost}, Str: ${card.strength}, Wp: ${card.willpower}, Lore: ${card.lore || 0}\nKeywords: ${keywordStr}\nMatchup: ${details || 'N/A'}`;

                    const tooltipWrapper = createCardTooltipWrapper(card, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createSongBreakdownDOM(title, classifiedItems, totalTargetableItemsCount, bgColorClass = 'bg-gray-700', contextSongCard = null, contextCharCard = null) {
            const section = document.createElement('div');
            section.className = `song-breakdown-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalTargetableItemsCount > 0 ? ((classifiedItems.length / totalTargetableItemsCount) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            if (bgColorClass.includes('text-black')) {
                titleElem.classList.add('text-black');
            }
            titleElem.textContent = `${title} (${classifiedItems.length}/${totalTargetableItemsCount} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (classifiedItems.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs ${bgColorClass.includes('text-black') ? 'text-gray-700' : 'text-gray-400'} italic p-1">None.</p>`;
            } else {
                classifiedItems.forEach(item => {
                    const cardForDisplay = item.card;
                    const interactionSummary = item.details;
                    const classificationType = item.classification;
                    let tooltipText;

                    if (contextSongCard) {
                        const targetCharCard = cardForDisplay;
                        const keywords = extractCharacterKeywords(targetCharCard);
                        let keywordStr = Object.entries(keywords)
                            .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                            .map(([key, value]) => {
                                if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                                return key.charAt(0).toUpperCase() + key.slice(1);
                            }).join(', ');
                        if (!keywordStr) keywordStr = 'None';
                        tooltipText = `Target Char: ${targetCharCard.fullName}\nCost: ${targetCharCard.cost}, Str: ${targetCharCard.strength}, Wp: ${targetCharCard.willpower}\nKeywords: ${keywordStr}\nAffected by Your Song: "${contextSongCard.fullName}"\nInteraction: ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;
                    } else {
                        const opponentSongCard = cardForDisplay; // Here, item.card is the song itself
                        tooltipText = `Opponent's Song: ${opponentSongCard.fullName}\nCost: ${opponentSongCard.cost} | Inkable: ${opponentSongCard.inkwell ? 'Yes' : 'No'}\nEffect Snippet: ${(opponentSongCard.effects?.join('; ') || opponentSongCard.fullText || '').replace(/\n/g, ' ').substring(0, 70) + '...'}\nInteraction with Your Char (${contextCharCard?.name || 'Selected Char'}): ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;
                    }

                    const tooltipWrapper = createCardTooltipWrapper(cardForDisplay, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createAbilityImpactDOM(title, classifiedTargetChars, totalOpponentChars, bgColorClass = 'bg-gray-700', sourceCharCard, sourceAbilityName) {
            const section = document.createElement('div');
            section.className = `ability-impact-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalOpponentChars > 0 ? ((classifiedTargetChars.length / totalOpponentChars) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            if (bgColorClass.includes('text-black')) {
                titleElem.classList.add('text-black');
            }
            titleElem.textContent = `${title} (${classifiedTargetChars.length}/${totalOpponentChars} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (classifiedTargetChars.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs ${bgColorClass.includes('text-black') ? 'text-gray-700' : 'text-gray-400'} italic p-1">None.</p>`;
            } else {
                classifiedTargetChars.forEach(item => {
                    const targetCharCard = item.card;
                    const interactionSummary = item.details;
                    const classificationType = item.classification;

                    const keywords = extractCharacterKeywords(targetCharCard);
                    let keywordStr = Object.entries(keywords)
                        .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                        .map(([key, value]) => {
                            if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                            return key.charAt(0).toUpperCase() + key.slice(1);
                        }).join(', ');
                    if (!keywordStr) keywordStr = 'None';

                    const tooltipText = `Target Char: ${targetCharCard.fullName}\nCost: ${targetCharCard.cost}, Str: ${targetCharCard.strength}, Wp: ${targetCharCard.willpower}\nKeywords: ${keywordStr}\nAffected by ${sourceCharCard.name}'s Ability: "${sourceAbilityName}"\nInteraction: ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;

                    const tooltipWrapper = createCardTooltipWrapper(targetCharCard, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createLocationInteractorsDOM(title, interactingCards, bgColorClass = 'bg-gray-700') {
            const section = document.createElement('div');
            section.className = `location-interaction-subsection shadow-md ${bgColorClass} p-3`;

            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            titleElem.textContent = `${title} (${interactingCards.length})`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (interactingCards.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs text-gray-400 italic p-1">None found.</p>`;
            } else {
                interactingCards.forEach(item => {
                    const card = item.card; // This is the Character or Song card
                    const details = item.details;
                    const tooltipText = `Card: ${card.fullName}\nType: ${card.type}\nInteraction: ${details}`;
                    const tooltipWrapper = createCardTooltipWrapper(card, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }


        function createCardTooltipWrapper(cardData, tooltipTextContent) {
            const tooltipWrapper = document.createElement('div');
            tooltipWrapper.className = 'tooltip';

            const img = document.createElement('img');
            img.src = cardData.images?.thumbnail || `https://placehold.co/100x140/2d3748/e2e8f0?text=${cardData.name.substring(0, 10)}`;
            img.alt = cardData.fullName;
            img.className = 'card-image';
            img.onerror = () => { img.src = `https://placehold.co/100x140/2d3748/e2e8f0?text=Error`; };
            tooltipWrapper.appendChild(img);

            const tooltipSpan = document.createElement('span');
            tooltipSpan.className = 'tooltiptext';
            tooltipSpan.textContent = tooltipTextContent;
            tooltipWrapper.appendChild(tooltipSpan);

            return tooltipWrapper;
        }

        // --- Add this new helper function somewhere in the script ---
        function extractAllCharacterTraits(characterCard) {
            const traits = new Set();
            const abilitiesText = (characterCard.abilities || []).map(a => a.fullText).join(' ');

            // Extract standard keywords first
            const keywords = extractCharacterKeywords(characterCard);
            Object.entries(keywords).forEach(([key, value]) => {
                if (value === true) traits.add(key.charAt(0).toUpperCase() + key.slice(1));
                else if (typeof value === 'number' && value > 0) traits.add(`${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`);
            });

            // Use new regex patterns for other static abilities
            if (LORCANA_PATTERNS['Static']) {
                LORCANA_PATTERNS['Static'].forEach(pattern => {
                    if (pattern.regex.test(abilitiesText)) {
                        traits.add(pattern.name); // Add the descriptive pattern name
                    }
                });
            }
            // Add new keywords
            ['Vanish', 'Sing Together', 'Puppy Shift', 'Universal Shift'].forEach(kw => {
                 if (abilitiesText.includes(kw)) {
                     // Extract value if present, e.g., "Sing Together 7"
                     const match = abilitiesText.match(new RegExp(`(${kw}( \\d+)?)`));
                     if (match) traits.add(match[1]);
                 }
            });

            return traits.size > 0 ? Array.from(traits).join(', ') : 'No notable keywords/abilities.';
        }

        function getSongSingCost(songCardInfo) {
            const songCostPattern = LORCANA_PATTERNS['Play']?.find(p => p.name === 'Song');
            if (songCostPattern) {
                const match = (songCardInfo.fullText || '').match(songCostPattern.regex);
                if (match && match[1]) {
                    return parseInt(match[1], 10);
                }
            }
            return songCardInfo.cost; // Fallback to the song's main cost if pattern fails
        }

        // --- Start the app ---
        initializeApp();
    </script>
</body>

</html>