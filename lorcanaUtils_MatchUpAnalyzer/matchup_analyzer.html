<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorcana Deck Matchup Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            /* Dark mode background */
            color: #e2e8f0;
            /* Light text for dark mode */
        }

        .card-image {
            width: 100px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }

        .card-image:hover {
            transform: scale(1.1);
        }

        .selectable-card {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .selectable-card:hover {
            background-color: #4a5568;
        }

        .selectable-card.selected {
            background-color: #667eea;
            box-shadow: 0 0 0 2px #a0aec0;
        }

        .selectable-card .card-name {
            font-size: 0.75rem;
            text-align: center;
            margin-top: 4px;
            color: #e2e8f0;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .card-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            background-color: #2d3748;
            /* Slightly lighter dark background for sections */
            border-radius: 8px;
            min-height: 100px;
            /* Adjusted min-height */
            align-items: flex-start;
            /* Align items to the top */
        }

        .analysis-section {
            /* Generic class for major sections */
            background-color: #222b3c;
            /* Slightly different dark for main sections */
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .outcome-section,
        .song-breakdown-section,
        .ability-impact-section,
        .location-interaction-subsection {
            /* Specific styling for subsections */
            background-color: #2d3748;
            padding: 12px;
            /* Slightly reduced padding */
            border-radius: 8px;
            margin-bottom: 12px;
            /* Reduced margin */
        }

        .section-title {
            /* For main section titles like "Character Matchups" */
            font-size: 1.5rem;
            /* Larger */
            font-weight: bold;
            color: #c3dafe;
            /* Light blueish */
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #4a5568;
        }

        .subsection-title {
            /* For titles within outcome/song sections */
            font-weight: bold;
            margin-bottom: 8px;
            color: #a0aec0;
            font-size: 1rem;
            /* Standardized size */
        }

        .ability-title {
            /* For individual ability names */
            font-weight: bold;
            color: #b0c4de;
            /* Lighter blue for ability names */
            margin-top: 10px;
            margin-bottom: 5px;
        }

        textarea {
            background-color: #2d3748;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 8px;
        }

        button {
            background-color: #4a5fa0;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #3c4b80;
        }

        select {
            background-color: #2d3748;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 8px;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            /* Increased width for more text */
            background-color: #374151;
            color: #e5e7eb;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            /* Increased padding */
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            /* Half of new width */
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            line-height: 1.4;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            white-space: pre-line;
            /* Allow newlines in tooltip */
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #374151 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Styling for radio buttons */
        .radio-label {
            margin-right: 10px;
            cursor: pointer;
        }

        .radio-label input[type="radio"] {
            margin-right: 5px;
        }
    </style>
</head>

<body class="p-4 md:p-8">

    <header class="text-center mb-8">
        <h1 class="text-3xl font-bold text-purple-400">Lorcana Matchup Analyzer</h1>
        <p class="text-sm text-gray-400">Analyze character trade values, song threats, and location vulnerabilities.</p>
    </header>

    <div id="loadingIndicator" class="text-center my-4">
        <div class="loading-spinner"></div>
        <p>Loading Card Data & Patterns...</p>
    </div>

    <main id="appContent" class="hidden">
        <section class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                <h2 class="text-xl font-semibold mb-2">Your Deck</h2>
                <div class="flex items-center gap-2 mb-2">
                  <button id="loadPlayerDeckBtn" class="px-3 py-1.5 bg-purple-700 hover:bg-purple-800 rounded text-sm font-semibold">Load from Database</button>
                </div>
                <textarea id="playerDeckInput" rows="10" class="w-full p-2"
                    placeholder="4 Card Name&#10;2 Another Card Name..."></textarea>
            </div>
            <div>
                <h2 class="text-xl font-semibold mb-2">Opponent's Deck</h2>
                <div class="flex items-center gap-2 mb-2">
                  <button id="loadOpponentDeckBtn" class="px-3 py-1.5 bg-purple-700 hover:bg-purple-800 rounded text-sm font-semibold">Load from Database</button>
                </div>
                <textarea id="opponentDeckInput" rows="10" class="w-full p-2"
                    placeholder="4 Card Name&#10;2 Another Card Name..."></textarea>
            </div>
        </section>

        <div class="text-center mb-6">
            <button id="analyzeButton" class="px-6 py-3">Load Decks & Analyze</button>
        </div>

        <section id="analysisControls" class="hidden mt-8 p-4 bg-gray-700 rounded-lg shadow-md">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                <div class="mb-4 sm:mb-0">
                    <span class="mr-2 font-semibold">Analysis Mode:</span>
                    <label class="radio-label"><input type="radio" name="analysisMode" value="character" checked> My
                        Character</label>
                    <label class="radio-label"><input type="radio" name="analysisMode" value="song"> My Song</label>
                </div>

                <div id="challengePerspectiveContainer">
                    <label for="turnContextSelect" class="mr-2 font-semibold">Challenge Perspective:</label>
                    <select id="turnContextSelect">
                        <option value="player">My Turn (I Challenge)</option>
                        <option value="opponent">Opponent's Turn (They Challenge)</option>
                    </select>
                </div>
            </div>
        </section>

        <section id="cardSelectionGrid" class="hidden mt-6">
            <h3 class="text-xl font-semibold mb-4 text-center" id="cardSelectionTitle">Select a Character to Analyze
            </h3>
            <div id="playerCardsGrid"
                class="grid grid-cols-12 md:grid-cols-20 lg:grid-cols-25 xl:grid-cols-20 gap-1 p-1 bg-gray-800 rounded-lg">
                <!-- Cards will be populated here -->
            </div>
        </section>

        <section id="resultsDisplay" class="mt-8">
        </section>

        <!-- UWPM Win Probability Display -->
        <div class="mt-8 p-6 bg-gray-800 rounded-lg shadow-xl">
            <h2 class="text-2xl font-bold text-center text-purple-400 mb-4">Unified Win Probability Model (UWPM)</h2>
            <div id="win-probability-display" class="text-center">
                <p class="text-lg text-gray-400">Load both decks to calculate win probability.</p>
            </div>
        </div>
    </main>

    <!-- Deck Load Modal -->
    <div id="deckLoadModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 p-4 opacity-0 pointer-events-none transition-opacity duration-200">
      <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
        <h3 class="text-lg font-bold text-white mb-4">Select a Deck</h3>
        <input type="text" id="deckSearchInput" placeholder="Search decks by name..." class="w-full mb-4 px-3 py-2 rounded bg-gray-700 border border-gray-600 text-gray-200 focus:ring-2 focus:ring-purple-500 focus:outline-none">
        <div id="deckListContainer" class="max-h-64 overflow-y-auto space-y-2">
          <!-- Decks will be injected here -->
        </div>
        <div class="flex justify-end mt-6">
          <button id="closeDeckModalBtn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded font-semibold">Cancel</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>

    <script>
        // --- Globals ---
        let ALL_CARDS_DATA = null;
        let ALL_CARDS_MAP = new Map();
        let LORCANA_PATTERNS = {};
        let PLAYER_DECK_CHARS = [];
        let OPPONENT_DECK_CHARS = [];
        let PLAYER_DECK_SONGS = [];
        let OPPONENT_DECK_SONGS = [];
        let PLAYER_DECK_LOCATIONS = [];
        let OPPONENT_DECK_LOCATIONS = [];
        let PLAYER_DECK_ITEMS = [];
        let OPPONENT_DECK_ITEMS = [];
        let PLAYER_DECK_ACTIONS = [];
        let OPPONENT_DECK_ACTIONS = [];

        // --- Supabase Deck Loading ---
        const SUPABASE_URL = 'https://cjlhrfhximjldqrfblkj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNqbGhyZmh4aW1qbGRxcmZibGtqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA0MTcxNzQsImV4cCI6MjA2NTk5MzE3NH0.zLiQcPnKt2SnNfQIkUnOG7bOo6F7MPMh8MsasdFF6lw';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let allDecks = [];
        let deckFuse;
        let deckLoadTarget = null; // 'player' or 'opponent'

        // Modal elements
        const deckLoadModal = document.createElement('div');
        // (But we already inject it above, so just get by id)
        // --- DOM Elements ---
        // ... existing code ...
        // Add after DOMContentLoaded or in initializeApp
        document.addEventListener('DOMContentLoaded', () => {
          // ... existing code ...
          // Modal DOM
          const deckLoadModal = document.getElementById('deckLoadModal');
          const deckListContainer = document.getElementById('deckListContainer');
          const deckSearchInput = document.getElementById('deckSearchInput');
          const closeDeckModalBtn = document.getElementById('closeDeckModalBtn');
          const loadPlayerDeckBtn = document.getElementById('loadPlayerDeckBtn');
          const loadOpponentDeckBtn = document.getElementById('loadOpponentDeckBtn');
          const playerDeckInput = document.getElementById('playerDeckInput');
          const opponentDeckInput = document.getElementById('opponentDeckInput');

          // --- SESSION STORAGE LOGIC ---
          // Load from sessionStorage if available
          const sessionPlayerDeck = sessionStorage.getItem('playerDeckInput');
          const sessionOpponentDeck = sessionStorage.getItem('opponentDeckInput');
          if (sessionPlayerDeck !== null) {
            playerDeckInput.value = sessionPlayerDeck;
          }
          if (sessionOpponentDeck !== null) {
            opponentDeckInput.value = sessionOpponentDeck;
          }

          // Save to sessionStorage on input
          playerDeckInput.addEventListener('input', () => {
            sessionStorage.setItem('playerDeckInput', playerDeckInput.value);
          });
          opponentDeckInput.addEventListener('input', () => {
            sessionStorage.setItem('opponentDeckInput', opponentDeckInput.value);
          });

          // Modal show/hide helpers
          function showDeckModal(target) {
            deckLoadTarget = target;
            deckLoadModal.classList.remove('opacity-0', 'pointer-events-none');
            deckSearchInput.value = '';
            renderDeckList(allDecks);
            deckSearchInput.focus();
          }
          function hideDeckModal() {
            deckLoadModal.classList.add('opacity-0', 'pointer-events-none');
            deckLoadTarget = null;
          }

          // Fetch decks from Supabase
          async function fetchDecksFromDatabase() {
            const { data, error } = await supabaseClient.from('decks').select('*').order('created_at', { ascending: true });
            if (error) {
              console.error('Error fetching decks:', error);
              allDecks = [];
            } else {
              allDecks = data;
            }
            deckFuse = new Fuse(allDecks, { keys: ['name'], includeScore: true, threshold: 0.4 });
          }

          // Render deck list in modal
          function renderDeckList(decksToRender) {
            deckListContainer.innerHTML = '';
            if (!decksToRender.length) {
              deckListContainer.innerHTML = '<p class="text-gray-400 italic text-center">No decks found.</p>';
              return;
            }
            decksToRender.forEach(deck => {
              const btn = document.createElement('button');
              btn.className = 'w-full text-left p-3 rounded-md hover:bg-purple-700 focus:bg-purple-800 focus:outline-none transition-colors font-semibold text-gray-100';
              btn.textContent = deck.name;
              btn.addEventListener('click', () => {
                if (deckLoadTarget === 'player') {
                  playerDeckInput.value = deck.decklist || '';
                  sessionStorage.setItem('playerDeckInput', playerDeckInput.value);
                } else if (deckLoadTarget === 'opponent') {
                  opponentDeckInput.value = deck.decklist || '';
                  sessionStorage.setItem('opponentDeckInput', opponentDeckInput.value);
                }
                hideDeckModal();
              });
              deckListContainer.appendChild(btn);
            });
          }

          // Modal search
          deckSearchInput.addEventListener('input', () => {
            const searchTerm = deckSearchInput.value.trim();
            if (!searchTerm) {
              renderDeckList(allDecks);
              return;
            }
            const results = deckFuse.search(searchTerm);
            const filteredDecks = results.map(r => r.item);
            renderDeckList(filteredDecks);
          });

          // Modal close
          closeDeckModalBtn.addEventListener('click', hideDeckModal);

          // Open modal for player deck
          loadPlayerDeckBtn.addEventListener('click', async () => {
            await fetchDecksFromDatabase();
            showDeckModal('player');
          });
          // Open modal for opponent deck
          loadOpponentDeckBtn.addEventListener('click', async () => {
            await fetchDecksFromDatabase();
            showDeckModal('opponent');
          });
        });

        const CARD_DATA_URL = 'https://raw.githubusercontent.com/heavenideas/similcana/refs/heads/main/database/allCards.json';

        // Patterns will be loaded from external file
        const PATTERNS_URL = 'https://raw.githubusercontent.com/heavenideas/heavenideas.github.io/refs/heads/main/lorcanaUtils_MatchUpAnalyzer/lorcana_patterns.txt';

        const DEFAULT_PLAYER_DECK = `4 Be Prepared
4 Vision of the Future
4 How Far I'll Go
4 Tipo - Growing Son
4 Develop Your Brain
4 Pawpsicle
4 Sail The Azurite Sea
4 Maui - Half-Shark
4 A Pirate's Life
4 McDuck Manor - Scrooge's Mansion
4 Maui - Hero to All
4 Gramma Tala - Keeper of Ancient Stories
4 Tamatoa - Happy as a Clam
2 Sisu - Empowered Sibling
4 Goofy - Super Goof
2 Hades - Infernal Schemer`;

        const DEFAULT_OPPONENT_DECK = `4 Calhoun - Marine Sergeant
4 Cinderella - Ballroom Sensation
3 Daisy Duck - Donald's Date
4 Doc - Bold Knight
3 Happy - Lively Knight
4 Lady - Family Dog
4 Let the Storm Rage On
4 Mr. Smee - Bumbling Mate
4 Pete - Games Referee
4 Piglet - Pooh Pirate Captain
4 Rapunzel - Gifted with Healing
2 Rapunzel's Tower - Secluded Prison
4 Rhino - One-Sixteenth Wolf
4 Rhino - Power Hamster
4 Seven Dwarfs' Mine - Secure Fortress
4 Strength of a Raging Fire`;

        // --- DOM Elements ---
        const loadingIndicator = document.getElementById('loadingIndicator');
        const appContent = document.getElementById('appContent');
        const playerDeckInput = document.getElementById('playerDeckInput');
        const opponentDeckInput = document.getElementById('opponentDeckInput');
        const analyzeButton = document.getElementById('analyzeButton');
        const analysisControls = document.getElementById('analysisControls');
        const cardSelectionGrid = document.getElementById('cardSelectionGrid');
        const cardSelectionTitle = document.getElementById('cardSelectionTitle');
        const playerCardsGrid = document.getElementById('playerCardsGrid');

        const analysisModeRadios = document.querySelectorAll('input[name="analysisMode"]');
        const challengePerspectiveContainer = document.getElementById('challengePerspectiveContainer');

        const turnContextSelect = document.getElementById('turnContextSelect');
        const resultsDisplay = document.getElementById('resultsDisplay');

        // --- Selection State ---
        let selectedCardIndex = -1;
        let selectedCardType = null; // 'character' or 'song'


        // --- Functions ---
        function getNumberFromText(textNumber) {
            let number;
            
            if (/( a | one )/gi.test(textNumber)) {
                number = 1;
            } else if (/( two )/gi.test(textNumber)) {
                number = 2;
            } else if (/( three )/gi.test(textNumber)) {
                number = 3;
            } else {
                const [match] = textNumber.match(/(\d+)/) || [];
                number = parseInt(match, 10); // Ensure the extracted number is parsed as an integer
            }
            return number;
        }
        /**
         * @typedef {object} UWPCard - An enriched card object with features for the UWPM.
         * @property {string} name - The card's name.
         * @property {number} cost - The ink cost.
         * @property {number} strength - The strength value.
         * @property {number} willpower - The willpower value.
         * @property {number} lore - The lore value.
         * @property {boolean} isUninkable - True if the card cannot be put in the inkwell.
         * @property {Set<string>} keywords - A set of keywords (e.g., 'Rush', 'Ward', 'Evasive').
         * @property {Set<string>} abilityPatterns - A set of identified ability patterns from lorcana_patterns.txt.
         * @property {object} rawData - The original card data.
         * @property {object} freePlayEffect - Details about the card's free-play ability.
         * @property {number} freePlayEffect.maxCost - Max cost of the card that can be played for free.
         * @property {string} freePlayEffect.trigger - The condition to trigger the effect (e.g., 'OnPlay', 'OnQuest').
         * @property {object} scryEffect - Details about the card's scry ability.
         * @property {number} scryEffect.lookCount - The number of cards to look at.
         * @property {boolean} scryEffect.canFilterToBottom - True if the card can be filtered to the bottom of the deck.
         * @property {boolean} scryEffect.canTutorToHand - True if the card can be tutored to the hand.
         */

        /**
         * Processes a raw card object and extracts features required for UWPM calculations.
         * @param {object} rawCard - The card object from allCards.json.
         * @param {object} LORCANA_PATTERNS - The parsed regex patterns.
         * @returns {UWPCard} - The enriched card object.
         */
        function extractCardFeatures(rawCard, LORCANA_PATTERNS) {
            // 1. Initialize the UWPCard object with basic stats.
            const features = {
                name: rawCard.name,
                cost: rawCard.cost,
                strength: rawCard.strength || 0,
                willpower: rawCard.willpower || 0,
                lore: rawCard.lore || 0,
                isUninkable: rawCard.inkable === false,
                keywords: new Set(),
                abilityPatterns: new Set(),
                rawData: rawCard,
            };

            // 2. Extract keywords from both the keywords field and ability text
            // (a) From keywords field
            if (Array.isArray(rawCard.keywords)) {
                rawCard.keywords.forEach(kw => features.keywords.add(kw));
            }
            // (b) From abilities (look for keyword type or parse text)
            if (Array.isArray(rawCard.abilities)) {
                rawCard.abilities.forEach(ability => {
                    if (ability.type === 'keyword' && ability.keyword) {
                        features.keywords.add(ability.keyword);
                    }
                    // Also parse for common keywords in text (e.g., 'Rush', 'Ward', etc.)
                    const text = (ability.fullText || '').toLowerCase();
                    ['rush', 'ward', 'evasive', 'resist', 'challenger', 'support', 'bodyguard', 'reckless', 'singer'].forEach(kw => {
                        if (text.includes(kw)) features.keywords.add(kw.charAt(0).toUpperCase() + kw.slice(1));
                    });
                });
            }
            // (c) From subtypes (sometimes subtypes are used as keywords)
            if (Array.isArray(rawCard.subtypes)) {
                rawCard.subtypes.forEach(subtype => features.keywords.add(subtype));
            }

            // 3. Use the regex from LORCANA_PATTERNS to identify all matching ability patterns
            // in the card's `fullTextSections` which is conveiently already the fullText split into sections
            let allText = Array.from(rawCard.fullTextSections).join(' ').replace(/\s+/g, ' ').trim();

            console.log("\n---Starting Search for: ", rawCard.name);
            console.log("With text: ---", allText,"---");
                        
            // For each pattern in all categories, if it matches, add its name
            for (const category in LORCANA_PATTERNS) {
                for (const pattern of LORCANA_PATTERNS[category]) {
                    if (pattern.regex && pattern.name && pattern.regex.test(allText)) {
                        features.abilityPatterns.add(pattern.fullName);
                        console.log("Adding ability: ", pattern.fullName, "to: ", rawCard.name);

                    }
                }
            }
            console.log("\n---");

             // Add new logic here:
            features.scryEffect = { lookCount: 0, canFilterToBottom: false, canTutorToHand: false };


            // Look at Deck

            //const lookMatch = (allText || '').match(LORCANA_PATTERNS['Card Effect']['Look at Deck'].regex);
            
            const lookAtDeckPattern = LORCANA_PATTERNS['Card Effect']?.find(p => p.fullName === 'Card Effect: Look at Deck');
            const lookMatch = lookAtDeckPattern ? (allText || '').match(/Look at the top (\d+|one|two|three|four|five)?(?: )?card(?:s?) of your deck/i) : null;
            
            
            let lookCount = 0;
            
            if (lookMatch) {
                try {
                    features.scryEffect.lookCount = getNumberFromText(lookMatch[1]);
                } catch (err) {
                    console.error("Error extracting lookCount from lookMatch:", err, lookMatch, allText, lookAtDeckPattern.regex);
                    features.scryEffect.lookCount = 0; // fallback or handle as needed
                }

                const filterToBottomPattern = LORCANA_PATTERNS['Card Effect']?.find(p => p.fullName === 'Card Effect: Filter to Bottom');
                if (filterToBottomPattern && filterToBottomPattern.regex.test(allText)) {
                    features.scryEffect.canFilterToBottom = true;
                }
                const deckToHandBottomPattern = LORCANA_PATTERNS['Card Effect']?.find(p => p.fullName === 'Card Effect: Deck to Hand/Bottom');
                if (deckToHandBottomPattern && deckToHandBottomPattern.regex.test(allText)) {
                    features.scryEffect.canTutorToHand = true;
                }

            }


            /**
             * Cost Evasion Value (CEV)
             * We will introduce a new sub-metric to the RDS called Cost Evasion Value (CEV). 
             * The CEV score represents a card's ability to "cheat" on ink costs, generating a massive tempo swing by 
             * deploying threats to the board far ahead of the normal game curve.
             */

            features.freePlayEffect = { maxCost: 0, trigger: 'None' };

            //const freePlayMatch = (allText || '').match(LORCANA_PATTERNS['Play: For Free'].regex);
            const freePlayPattern = LORCANA_PATTERNS['Play']?.find(p => p.fullName === 'Play: For Free');
            
            const freePlayMatch = freePlayPattern ? (allText || '').match(freePlayPattern.regex) : null;
            

            if (freePlayMatch) {
                const costMatch = freePlayMatch[0].match(/with cost (\d+)/i);
                features.freePlayEffect.maxCost = costMatch ? parseInt(costMatch[1], 10) : 1;
                //features.freePlayEffect.maxCost = parseInt(freePlayMatch[0].match(/with cost (\d+)/i)[1], 10);

                // Determine the trigger condition for reliability scoring
                if (/(When you play this character)/gi.test(allText)) {
                    features.freePlayEffect.trigger = 'OnPlay';
                } else if (/(When this character quests)/gi.test(allText)) {
                    features.freePlayEffect.trigger = 'OnQuest';
                } else {
                    features.freePlayEffect.trigger = 'Other'; // A catch-all for less common triggers
                }
            }


            return features;
        }

        /**
         * Calculates the Resource Dominance Score (RDS) for a given deck and provides a breakdown.
         * @param {UWPCard[]} deck
         * @returns {{ total: number, breakdown: Array<{ name: string, value: number, explanation: string }> }}
         */
        function getRDS(deck) {
            let total = 0;
            let breakdown = [];
            let costEvasionValue = 0;        // NEW

            // Define weights for CEV calculation.
            const cevWeights = {
                baseMultiplier: 1.0, // The core value is the ink you save
                triggerReliability: {
                    'OnPlay': 1.0,   // Highest reliability
                    'OnQuest': 0.65, // Less reliable; character must survive
                    'Other': 0.5     // Default for other, potentially more complex triggers
                }
            };

            // DQI weights as in original
            const dqiWeights = {
                perCardLookedAt: 0.15,
                filterToBottom: 1.0,
                tutorToHand: 2.5
            };
            deck.forEach(card => {
                let explanation = [];
                let value = 0;
                // Card Advantage Generation
                if (card.abilityPatterns.has('Card Effect: Draw')) {
                    let drawCount = 1;
                    const drawPattern = LORCANA_PATTERNS['Card Effect']?.find(p => p.fullName === 'Card Effect: Draw');
                    const drawMatch = (card.rawData.fullText.replace(/\n/g, ' ').trim() || '').match(drawPattern.regex);

                    //if (drawMatch) drawCount = parseInt(drawMatch[1], 10);
                    //if (drawMatch) drawCount = getNumberFromText(drawMatch[1]);
                    drawCount = getNumberFromText(drawMatch[0] || '');
                    value += drawCount * (2 / (card.cost || 1));
                    explanation.push(`Draw (${drawCount})`);
                }
                if (card.abilityPatterns.has('Play: From Discard')) {
                    value += 1.5;
                    explanation.push('Play: From Discard');
                }
                if (card.abilityPatterns.has('Card Effect: Opponent Discards')) {
                    value += 1.5;
                    explanation.push('Opponent Discards');
                }
                if (card.abilityPatterns.has('Card Effect: Hand to Inkwell')) {
                    value += 2.0;
                    explanation.push('Hand to Inkwell');
                }
                if (card.abilityPatterns.has('Stat: Cost Reduction')) {
                    value += 1.0;
                    explanation.push('Cost Reduction');
                }
                // DQI (Deck Quality Improvement) for scry effects
                if (card.scryEffect && card.scryEffect.lookCount > 0) {
                    let cardDQI = 0;
                    cardDQI += card.scryEffect.lookCount * dqiWeights.perCardLookedAt;
                    let dqiParts = [`Scry: Look at ${card.scryEffect.lookCount}`];
                    if (card.scryEffect.canFilterToBottom) {
                        cardDQI += dqiWeights.filterToBottom;
                        dqiParts.push('Filter to Bottom');
                    }
                    if (card.scryEffect.canTutorToHand) {
                        cardDQI += dqiWeights.tutorToHand;
                        dqiParts.push('Tutor to Hand');
                        value += 0.8;
                        explanation.push('Tutor to Hand (Card Draw Adj)');
                    }
                    let dqiValue = cardDQI / (card.cost || 1);
                    value += dqiValue;
                    explanation.push(`DQI: ${dqiParts.join(', ')} (+${dqiValue.toFixed(2)})`);
                }
                if (card.isUninkable) {
                    value -= (card.cost || 1) * 0.25;
                    explanation.push('Uninkable Burden');
                }
                // NEW: Calculate Cost Evasion Value (CEV) score for the card
                if (card.freePlayEffect && card.freePlayEffect.maxCost > 0) {
                    const reliabilityMod = cevWeights.triggerReliability[card.freePlayEffect.trigger] || 0.5;

                    // The value is the ink saved, modified by how reliably you can trigger it.
                    const cardCEV = card.freePlayEffect.maxCost * cevWeights.baseMultiplier * reliabilityMod;

                    // This is a direct contribution to the deck's resource dominance.
                    
                    explanation.push(`Play this or other card for free: ${cardCEV.toFixed(2)}`);
                    value += cardCEV;
                }

                breakdown.push({ name: card.rawData.fullName, value, explanation: explanation.join(', ') });
                total += value;
            });
            return { total, breakdown };
        }

        /**
         * Calculates the Lore Velocity Index (LVI) for a given deck and provides a breakdown.
         * @param {UWPCard[]} deck
         * @returns {{ total: number, breakdown: Array<{ name: string, value: number, explanation: string }> }}
         */
        function getLVI(deck) {
            let total = 0;
            let breakdown = [];
            deck.forEach(card => {
                let value = 0;
                let explanation = [];
                if (card.lore > 0) {
                    let baseLorePotential = card.lore / (card.cost || 1);
                    let loreSurvivabilityModifier = 1.0;
                    let questSafetyModifier = 1.0;
                    if (card.keywords.has('Ward')) { loreSurvivabilityModifier *= 1.4; explanation.push('Ward'); }
                    if (card.keywords.has('Resist')) { loreSurvivabilityModifier *= 1.2; explanation.push('Resist'); }
                    if ((card.willpower || 0) >= 5) { loreSurvivabilityModifier *= 1.1; explanation.push('High Willpower'); }
                    if (card.keywords.has('Evasive')) { questSafetyModifier *= 1.5; explanation.push('Evasive'); }
                    value += baseLorePotential * loreSurvivabilityModifier * questSafetyModifier;
                    explanation.unshift(`Lore: ${card.lore}`);
                }
                if (card.abilityPatterns.has('Lore: Gain')) {
                    const loreMatch = (card.rawData.fullText.replace(/\n/g, ' ').trim() || '').match(/ain (\d+) (◊|lore)/gi);
                    if (loreMatch) {
                        const loreAmount = getNumberFromText(loreMatch[0])
                        loreBuff = 1.5 * loreAmount
                        value += loreBuff;
                        explanation.push('Lore: Gain' ,loreAmount);
                    }
                    
                }
                if (card.abilityPatterns.has('Static: Stat Buff')) {
                    const loreMatch = (card.rawData.fullText.replace(/\n/g, ' ').trim() || '').match(/get(?:s)? \+(\d+) ◊/gi);
                    if (loreMatch){
                        const loreAmount = getNumberFromText(loreMatch[0])
                        loreBuff = 1.5*loreAmount
                        value += loreBuff;
                        explanation.push('Static: Stat Buf: Lore:',loreAmount);
                    }
                }
                
                breakdown.push({ name: card.rawData.fullName, value, explanation: explanation.join(', ') });
                total += value;
            });
            return { total, breakdown };
        }

        /**
         * Calculates the Board Control Rating (BCR) for a given deck and provides a breakdown.
         * @param {UWPCard[]} deck
         * @returns {{ total: number, breakdown: Array<{ name: string, value: number, explanation: string }> }}
         */
        function getBCR(deck) {
            let total = 0;
            let breakdown = [];
            deck.forEach(card => {
                let value = 0;
                let explanation = [];
                // Oredered from more control rating to less in terms of weight
                //Banish all characters is the highest as it's the biggest board control
                if (card.abilityPatterns.has('Banish: All Characters')) {
                    value += 8.0;
                    explanation.push('Banish All');
                } 
                if (card.abilityPatterns.has('Banish: Chosen Target') || card.abilityPatterns.has('Banish: Any') || card.abilityPatterns.has('Banish: Opponent\'s Choice')) {
                    value += 7 / (card.cost || 1);
                    explanation.push('Banish Other Characters');
                }
                if (card.abilityPatterns.has('Add to Inkwell: Opposing Character')) {
                    value += 5 / (card.cost || 1);
                    explanation.push('Add opposing character to their inkwell');
                }
                if (card.abilityPatterns.has('Damage: Put Damage Counters')) {
                    value += 4.5 / (card.cost || 1);
                    explanation.push('Put Damage Counters');
                }
                if (card.abilityPatterns.has('Damage: Deal to One') || card.abilityPatterns.has('Damage: Deal to Many')) {
                    value += 4 / (card.cost || 1);
                    explanation.push('Deal Damage');
                }
                if (card.abilityPatterns.has('Bounce: Opposing Character')) {
                    value += 4 / (card.cost || 1);
                    explanation.push('Bounce Opposing Character');
                }             
                if (card.abilityPatterns.has('Stat: Strength Buff')){
                    const strengthMatch = (card.rawData.fullText.replace(/\n/g, ' ').trim() || '').match(/(?:get(?:s)?|has|gain(?:s)?) \+(\d+) (¤|strength)/gi);
                    if (strengthMatch) {
                        const strengthAmount = getNumberFromText(strengthMatch[0])
                        strengthBuff = (1.5 * strengthAmount) / (card.cost || 1)
                        value += strengthBuff;
                        explanation.push('Static: Stat Buf: Strength:+', strengthAmount);
                    }
                }
                if (card.abilityPatterns.has('Stat: Willpower Buff')) {
                    const willpowerMatch = (card.rawData.fullText.replace(/\n/g, ' ').trim() || '').match(/(?:get(?:s)?|has|gain(?:s)?) \+(\d+) (⛉|willpower)/gi);
                    if (willpowerMatch) {
                        const willpowerAmount = getNumberFromText(willpowerMatch[0])
                        willpowerBuff = (1.5 * willpowerAmount)  / (card.cost || 1)
                        value += willpowerBuff;
                        explanation.push('Static: Stat Buf: Willpower:+', willpowerAmount);
                    }
                }
                if (card.abilityPatterns.has('Static: Grant Keyword (Aura)')) {
                    const resistMatch = (card.rawData.fullText.replace(/\n/g, ' ').trim() || '').match(/(?:Your other characters|they|it) gain(?:s)? (Resist \+\d+)/gi);
                    if (resistMatch) {
                        const resistAmount = getNumberFromText(resistMatch[0])
                        resistBuff = (1.5 * resistAmount) / (card.cost || 1)
                        value += resistBuff;
                        explanation.push('Static: Grant Keyword(Resist):+', resistAmount);
                    }
                }
                if (card.keywords.has('Rush')) {
                    value += (card.strength || 0) * 0.5;
                    explanation.push('Rush');
                }
                breakdown.push({ name: card.rawData.fullName, value, explanation: explanation.join(', ') });
                total += value;
            });
            return { total, breakdown };
        }

        /**
         * Calculates the final win probability for Deck A against Deck B.
         * @param {UWPCard[]} deckA - The player's deck.
         * @param {UWPCard[]} deckB - The opponent's deck.
         * @returns {number} - The win probability for Deck A (e.g., 0.55 for 55%).
         */
        function calculateWinProbability(deckA, deckB, tfaA = 0, tfaB = 0) {
            // 1. Calculate Intrinsic Scores for both decks
            const rdsA = getRDS(deckA);
            const lviA = getLVI(deckA);
            const bcrA = getBCR(deckA);

            const rdsB = getRDS(deckB);
            const lviB = getLVI(deckB);
            const bcrB = getBCR(deckB);

            // 2. Calculate Matchup-Specific Modifiers (now use provided TFA)
            const aim = 0; // Archetype Interaction Modifier
            const tfa = 0; // Use provided TFA values
            const taes = 0; // Threat-Answer Efficiency Score

            // 3. Define weights (tunable)
            const weights = { rds: 0.15, lvi: 0.25, bcr: 0.25, aim: 1.0, tfa: 0.5, taes: 1.0 };

            // 4. Calculate the final Matchup Score using the Master Equation
            const matchupScore =
                weights.rds * (rdsA.total - rdsB.total) +
                weights.lvi * (lviA.total - lviB.total) +
                weights.bcr * (bcrA.total - bcrB.total) +
                weights.aim * aim +
                weights.tfa * (tfaA - tfaB) +
                weights.taes * taes;

            // 5. Convert the score to a probability using the Logistic Function
            const k = 1; // Scaling factor, tunable
            const winProbability = 1 / (1 + Math.exp(-k * matchupScore));

            return winProbability;
        }

        // --- Initialization ---
        async function initializeApp() {
            console.log("Initializing app...");
            try {
                // Fetch card data
                const cardsResponse = await fetch(CARD_DATA_URL);

                if (!cardsResponse.ok) throw new Error(`HTTP error! status: ${cardsResponse.status}`);
                ALL_CARDS_DATA = await cardsResponse.json();
                console.log("Card data fetched successfully:", ALL_CARDS_DATA.cards.length, "cards loaded.");

                ALL_CARDS_DATA.cards.forEach(card => {
                    ALL_CARDS_MAP.set(card.fullName, card);
                    if (card.simpleName && card.simpleName !== card.fullName) {
                        ALL_CARDS_MAP.set(card.simpleName, card);
                    }
                });
                console.log("ALL_CARDS_MAP populated with", ALL_CARDS_MAP.size, "entries.");

                // Fetch patterns from external file
                const patternsResponse = await fetch(PATTERNS_URL);
                if (!patternsResponse.ok) throw new Error(`HTTP error! status: ${patternsResponse.status}`);
                const patternsText = await patternsResponse.text();
                parseAndStorePatterns(patternsText);

                loadingIndicator.classList.add('hidden');
                appContent.classList.remove('hidden');

                // Only set defaults if sessionStorage is empty
                if (sessionStorage.getItem('playerDeckInput') === null) {
                  playerDeckInput.value = DEFAULT_PLAYER_DECK;
                }
                if (sessionStorage.getItem('opponentDeckInput') === null) {
                  opponentDeckInput.value = DEFAULT_OPPONENT_DECK;
                }
                console.log("Default decklists set.");

                analyzeButton.addEventListener('click', handleAnalyzeButtonClick);
                turnContextSelect.addEventListener('change', displayAnalysisResults);

                analysisModeRadios.forEach(radio => {
                    radio.addEventListener('change', handleAnalysisModeChange);
                });
                console.log("Event listeners attached.");

            } catch (error) {
                console.error("Error during app initialization:", error);
                loadingIndicator.innerHTML = `<p class="text-red-500">Error loading data. Please try refreshing. Details: ${error.message}</p>`;
            }
        }

        // --- Pattern Parsing ---
        function parseAndStorePatterns(text) {
            const patternBlocks = text.split('----------------------------------------').map(s => s.trim()).filter(Boolean);
            patternBlocks.forEach(block => {
                const nameMatch = block.match(/Pattern Name: (.*)/);
                const regexMatch = block.match(/Regex: \/(.*)\/(.*)/);

                if (nameMatch && regexMatch) {
                    const fullName = nameMatch[1].trim();
                    const [category, name] = fullName.split(': ');
                    const regexString = regexMatch[1];
                    const flags = regexMatch[2]; // Includes 'g' and 'i'

                    if (!LORCANA_PATTERNS[category]) {
                        LORCANA_PATTERNS[category] = [];
                    }

                    LORCANA_PATTERNS[category].push({
                        name: name,
                        fullName: fullName,
                        regex: new RegExp(regexString, flags) // The 'i' flag makes it case-insensitive
                    });
                }
            });
            console.log("Lorcana patterns parsed and stored:", LORCANA_PATTERNS);
        }

        // --- Deck Parsing ---
        function parseDeckString(deckString) {
            console.log("Parsing deck string:", deckString.substring(0, 50) + "...");
            const lines = deckString.trim().split('\n');
            const characters = [];
            const songs = [];
            const locations = []; // Added for locations
            const items = []; // Added for items
            const actions = []; // Added for actions
            const uniqueCharNames = new Set();
            const uniqueSongNames = new Set();
            const uniqueLocationNames = new Set(); // Added for locations
            const uniqueItemNames = new Set(); // Added for items
            const uniqueActionNames = new Set(); // Added for actions


            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                const match = line.match(/^(\d+)\s+(.+)/);
                if (match) {
                    const count = parseInt(match[1], 10);
                    const cardName = match[2].trim();
                    const cardData = ALL_CARDS_MAP.get(cardName);

                    if (cardData) {
                        if (cardData.type === 'Character') {
                            if (!uniqueCharNames.has(cardData.fullName)) {
                                characters.push({ cardInfo: cardData, count: count });
                                uniqueCharNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Action' && cardData.subtypes?.includes('Song')) {
                            if (!uniqueSongNames.has(cardData.fullName)) {
                                songs.push({ cardInfo: cardData, count: count });
                                uniqueSongNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Location') { // Added location check
                            if (!uniqueLocationNames.has(cardData.fullName)) {
                                locations.push({ cardInfo: cardData, count: count });
                                uniqueLocationNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Item') { // Added item check
                            if (!uniqueItemNames.has(cardData.fullName)) {
                                items.push({ cardInfo: cardData, count: count });
                                uniqueItemNames.add(cardData.fullName);
                            }
                        } else if (cardData.type === 'Action') { // Added action check (non-song actions)
                            if (!uniqueActionNames.has(cardData.fullName)) {
                                actions.push({ cardInfo: cardData, count: count });
                                uniqueActionNames.add(cardData.fullName);
                            }
                        }
                    } else {
                        console.warn(`Card not found during parsing: ${cardName}`);
                    }
                } else {
                    console.warn(`Invalid deck line format during parsing: ${line}`);
                }
            });
            const parsedResult = {
                characters: Array.from(uniqueCharNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })),
                songs: Array.from(uniqueSongNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })),
                locations: Array.from(uniqueLocationNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })), // Added locations
                items: Array.from(uniqueItemNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })), // Added items
                actions: Array.from(uniqueActionNames).map(name => ({ cardInfo: ALL_CARDS_MAP.get(name) })) // Added actions
            };
            console.log("Deck parsed. Characters:", parsedResult.characters.length, "Songs:", parsedResult.songs.length, "Locations:", parsedResult.locations.length, "Items:", parsedResult.items.length, "Actions:", parsedResult.actions.length);
            return parsedResult;
        }

        // --- Keyword Extraction ---
        function extractCharacterKeywords(card) {
            const keywords = { Resist: 0, Challenger: 0, Evasive: false, Ward: false };
            const otherKeywords = ['support', 'bodyguard', 'reckless', 'singer'];

            if (card.abilities && Array.isArray(card.abilities)) {
                card.abilities.forEach(ability => {
                    if (ability.type === 'keyword') {
                        const lowerKeyword = ability.keyword.toLowerCase();
                        if (lowerKeyword === 'resist') keywords.Resist = ability.keywordValueNumber || 0;
                        else if (lowerKeyword === 'challenger') keywords.Challenger = ability.keywordValueNumber || 0;
                        else if (lowerKeyword === 'evasive') keywords.Evasive = true;
                        else if (lowerKeyword === 'ward') keywords.Ward = true;
                        else if (otherKeywords.includes(lowerKeyword)) {
                            keywords[ability.keyword.toLowerCase()] = true;
                        }
                    }
                });
            }
            if (card.subtypes && Array.isArray(card.subtypes)) {
                card.subtypes.forEach(subtype => {
                    keywords[subtype.toLowerCase()] = true;
                });
            }
            return keywords;
        }

        // --- Banish Condition Checker ---
        function checkBanishConditions(pattern, match, targetCharacterCard, abilityText) {
            console.log(`Checking banish conditions for pattern: ${pattern.name}, target: ${targetCharacterCard.fullName}, ability: ${abilityText.substring(0, 50)}...`);

            // Handle special cases that don't target opponent characters
            if (pattern.name === 'This Character') {
                return {
                    canBanish: false,
                    details: `'${pattern.name}' only affects the source character, not opponent characters.`
                };
            }

            if (pattern.name === 'As a Cost/Choice') {
                return {
                    canBanish: false,
                    details: `'${pattern.name}' is a cost/choice effect, not targeting opponent characters.`
                };
            }

            if (pattern.name === "Opponent's Choice") {
                return {
                    canBanish: true,
                    details: `'${pattern.name}' lets opponent choose their own character to banish.`
                };
            }

            const targetCharStrength = targetCharacterCard.strength || 0;
            const targetCharWillpower = targetCharacterCard.willpower || 0;
            const targetCharCost = targetCharacterCard.cost || 0;

            // Extract the condition part from the ability text
            const conditionMatch = abilityText.match(/with (\d+) (¤|⬡|⛉) or (less|more)/i);

            if (!conditionMatch) {
                // No specific condition - can banish any character
                console.log(`No condition found, can banish any character`);
                return {
                    canBanish: true,
                    details: `Can banish any character via '${pattern.name}'.`
                };
            }

            const conditionValue = parseInt(conditionMatch[1], 10);
            const statType = conditionMatch[2]; // ¤ (strength), ⬡ (cost), ⛉ (willpower)
            const comparison = conditionMatch[3]; // "less" or "more"

            console.log(`Condition found: ${conditionValue} ${statType} or ${comparison}`);

            let targetStat;
            let statName;

            switch (statType) {
                case '¤': // Strength
                    targetStat = targetCharStrength;
                    statName = 'strength';
                    break;
                case '⬡': // Cost
                    targetStat = targetCharCost;
                    statName = 'cost';
                    break;
                case '⛉': // Willpower
                    targetStat = targetCharWillpower;
                    statName = 'willpower';
                    break;
                default:
                    // Unknown stat type, assume it can banish
                    return {
                        canBanish: true,
                        details: `Can banish via '${pattern.name}' (unknown stat condition).`
                    };
            }

            let canBanish;
            if (comparison === 'less') {
                canBanish = targetStat <= conditionValue;
            } else if (comparison === 'more') {
                canBanish = targetStat >= conditionValue;
            } else {
                // Unknown comparison, assume it can banish
                canBanish = true;
            }

            console.log(`Target has ${statName} ${targetStat}, condition: ${comparison} than ${conditionValue}, canBanish: ${canBanish}`);

            if (canBanish) {
                return {
                    canBanish: true,
                    details: `Can banish character with ${statName} ${comparison} than or equal to ${conditionValue} (target has ${targetStat}).`
                };
            } else {
                return {
                    canBanish: false,
                    details: `Cannot banish character with ${statName} ${comparison} than or equal to ${conditionValue} (target has ${targetStat}).`
                };
            }
        }

        // --- Matchup Calculation (Characters) ---
        function calculateSingleMatchup(playerCharData, opponentCharData, turnType) {
            const pKeywords = extractCharacterKeywords(playerCharData);
            const oKeywords = extractCharacterKeywords(opponentCharData);
            let pStrength = playerCharData.strength || 0;
            const pWillpower = playerCharData.willpower || 0;
            const pCost = playerCharData.cost || 0;
            let oStrength = opponentCharData.strength || 0;
            const oWillpower = opponentCharData.willpower || 0;
            const oCost = opponentCharData.cost || 0;

            if (turnType === 'player' && oKeywords.Evasive && !pKeywords.Evasive) return { outcomeName: "NoInteraction_OpponentEvasive", classification: "Neutral", details: "Opponent is Evasive" };
            if (turnType === 'opponent' && pKeywords.Evasive && !oKeywords.Evasive) return { outcomeName: "NoInteraction_PlayerEvasive", classification: "Neutral", details: "Your character is Evasive" };

            if (turnType === 'player' && pKeywords.Challenger > 0) pStrength += pKeywords.Challenger;
            if (turnType === 'opponent' && oKeywords.Challenger > 0) oStrength += oKeywords.Challenger;

            let damageToPlayer = Math.max(0, oStrength - pKeywords.Resist);
            let damageToOpponent = Math.max(0, pStrength - oKeywords.Resist);

            const playerBanished = damageToPlayer >= pWillpower;
            const opponentBanished = damageToOpponent >= oWillpower;

            let result;
            if (playerBanished && opponentBanished) {
                const inkDiff = oCost - pCost;
                let classification = "Neutral";
                if (inkDiff >= 2) classification = "Positive";
                else if (inkDiff <= -2) classification = "Negative";
                result = { outcomeName: "BothBanished", classification, details: `Ink Diff (Opp-Player): ${inkDiff}` };
            } else if (!opponentBanished && playerBanished) {
                result = { outcomeName: "OpponentSurvives_PlayerBanished", classification: "Negative", details: "Your character banished" };
            } else if (opponentBanished && !playerBanished) {
                result = { outcomeName: "PlayerSurvives_OpponentBanished", classification: "Positive", details: "Opponent character banished" };
            } else if (!opponentBanished && !playerBanished) {
                result = { outcomeName: "BothSurvive", classification: "Neutral", details: "Stalemate, both survive" };
            } else {
                result = { outcomeName: "Unknown", classification: "Neutral", details: "Error in logic" };
            }
            return result;
        }

        // --- Generic Ability/Effect Interaction Analysis (Refactored) ---
        function classifyAbilityEffectOnTarget(sourceCardInfo, abilityText, targetCharacterCard, sourceIsPlayerPerspective) {
            const cleanedAbilityText = (abilityText || "").replace(/\n/g, ' ').trim();
            if (!cleanedAbilityText) {
                return { classification: "NoInteraction", details: "No ability text.", card: sourceCardInfo };
            }

            const targetCharKeywords = extractCharacterKeywords(targetCharacterCard);
            const targetCharWillpower = targetCharacterCard.willpower || 0;

            // Ward Check: Ward protects from being CHOSEN, except by effects that say "each" or "all".
            const isSingleTarget = cleanedAbilityText.toLowerCase().includes('chosen');
            if (targetCharKeywords.Ward && isSingleTarget) {
                return { classification: "NoInteractionDueToWard", details: "Target character has Ward, protected from 'chosen' effects.", card: sourceCardInfo };
            }

            for (const category in LORCANA_PATTERNS) {
                for (const pattern of LORCANA_PATTERNS[category]) {
                    const match = cleanedAbilityText.match(pattern.regex);
                    if (match) {
                        // We have a match, now we interpret it based on the category and name
                        switch (category) {
                            case 'Banish':
                                console.log(`Banish match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                // Check specific banish conditions against target character
                                const banishResult = checkBanishConditions(pattern, match, targetCharacterCard, cleanedAbilityText);
                                if (banishResult.canBanish) {
                                    console.log(`Banish result: ${banishResult.details}`);
                                    return { classification: "DirectRemoval", details: banishResult.details, card: sourceCardInfo };
                                } else {
                                    return { classification: "NoInteraction", details: banishResult.details, card: sourceCardInfo };
                                }

                            case 'Damage':
                                console.log(`Damage match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                const damageAmount = getNumberFromText(match[0]) || 0;
                                
                                console.log(`Damage amount: ${damageAmount}`);
                                if (damageAmount > 0) {
                                    if (damageAmount >= targetCharWillpower) {
                                        return { classification: "DirectRemoval", details: `Deals ${damageAmount} damage (lethal).`, card: sourceCardInfo };
                                    } else {
                                        return { classification: "PotentialRemoval", details: `Deals ${damageAmount} damage.`, card: sourceCardInfo };
                                    }
                                }
                                break; // Continue if damage amount is not clear
                            case 'Bounce':
                                console.log(`Bounce match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName}`);
                                return { classification: "DirectRemoval", details: `Bounces ${pattern.name}.`, card: sourceCardInfo };
                            case 'Add to Inkwell':
                                console.log(`Add to Inkwell match: ${match} ${sourceCardInfo.fullName}, ${targetCharacterCard.fullName} `);
                                return { classification: "DirectRemoval", details: `Adds to Inkwell ${pattern.name}.`, card: sourceCardInfo };
                            case 'State':
                                // These affect the character but don't remove it
                                return { classification: "AffectsNoRemoval", details: `Matched '${pattern.fullName}'.`, card: sourceCardInfo };

                            case 'Static':
                                if (pattern.name.includes('Cannot Be Challenged')) {
                                    return { classification: "AffectsNoRemoval", details: `Cannot be challenged.`, card: sourceCardInfo };
                                }
                                break;
                        }
                    }
                }
            }

            // Fallback for text that doesn't match a specific pattern but might still be relevant
            // const genericTargeting = /character|item|location/i;
            // if (genericTargeting.test(cleanedAbilityText)) {
            //     return { classification: "PotentialRemoval", details: "Targets character with an unclassified effect.", card: sourceCardInfo };
            // }

            return { classification: "NoInteraction", details: "Effect does not appear to target characters.", card: sourceCardInfo };
        }

        // --- Location Interaction Analysis (Refactored) ---
        function classifyLocationInteraction(sourceCardInfo, abilityText, sourceIsPlayerPerspective) {
            const cleanedAbilityText = (abilityText || "").replace(/\n/g, ' ').trim();
            if (!cleanedAbilityText) return null;

            const banishPatterns = LORCANA_PATTERNS['Banish'] || [];
            const damagePatterns = LORCANA_PATTERNS['Damage'] || [];

            for (const pattern of banishPatterns) {
                if (pattern.regex.test(cleanedAbilityText) && cleanedAbilityText.toLowerCase().includes('location')) {
                    return { canInteract: true, interactionType: "Banish", details: `Can banish a location via '${pattern.name}'.`, card: sourceCardInfo };
                }
            }
            for (const pattern of damagePatterns) {
                if (pattern.regex.test(cleanedAbilityText) && cleanedAbilityText.toLowerCase().includes('location')) {
                    return { canInteract: true, interactionType: "Damage", details: `Can damage a location via '${pattern.name}'.`, card: sourceCardInfo };
                }
            }

            // Generic fallback
            if (cleanedAbilityText.toLowerCase().includes('chosen location')) {
                return { canInteract: true, interactionType: "Target", details: "Can target a location.", card: sourceCardInfo };
            }

            return null;
        }


        function getActiveAbilitiesForCharacter(characterCard, analysisContext) {
            const activeAbilities = [];
            if (!characterCard.abilities || !Array.isArray(characterCard.abilities)) {
                return activeAbilities;
            }

            // Expanded list of player-turn triggers using new patterns
            const playerTurnTriggers = [
                'On Play', 'On Challenging', 'On Quest', 'Start of Turn',
                'On Playing Other Character', 'On Playing Song', 'On Banishing Other',
                'On Readying', 'On Healing', 'On Opponent Damaged', 'On Any Character Challenging',
                'On Inking', 'On Moving to Location', 'On Drawing Card'
            ];

            // Opponent-turn triggers
            const opponentTurnTriggers = [
                'On Being Challenged', 'On Being Challenged and Banished',
                'Start of Turn'
            ];

            characterCard.abilities.forEach(ability => {
                const cleanedFullText = (ability.fullText || "").replace(/\n/g, ' ');
                let isRelevant = false;
                let hasSpecificTrigger = false;

                const relevantPatterns = analysisContext.perspective === "playerTurn" ? playerTurnTriggers : opponentTurnTriggers;

                for (const patternName of relevantPatterns) {
                    const patternCategory = LORCANA_PATTERNS['Trigger'] || [];
                    const pattern = patternCategory.find(p => p.name === patternName);
                    if (pattern && pattern.regex.test(cleanedFullText)) {
                        isRelevant = true;
                        hasSpecificTrigger = true;
                        break;
                    }
                }

                // If it's a static ability or activated ability (which can be used on your turn),
                // or if it has no specific, parsed trigger, assume it's potentially active.
                if (ability.type === 'static' || (cleanedFullText.includes('—') && analysisContext.perspective === "playerTurn") || !hasSpecificTrigger) {
                    isRelevant = true;
                }

                if (isRelevant && ability.fullText) {
                    activeAbilities.push({ text: cleanedFullText, name: ability.name || "Unnamed Ability" });
                }
            });
            return activeAbilities;
        }

        // --- Event Handlers & UI Updates ---
        function populateCardGrid() {
            playerCardsGrid.innerHTML = '';
            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;

            let cardsToShow = [];
            if (selectedMode === 'character') {
                cardsToShow = PLAYER_DECK_CHARS;
                cardSelectionTitle.textContent = 'Select a Character to Analyze';
            } else {
                cardsToShow = PLAYER_DECK_SONGS;
                cardSelectionTitle.textContent = 'Select a Song to Analyze';
            }

            if (cardsToShow.length === 0) {
                playerCardsGrid.innerHTML = `<p class="text-center text-gray-400 italic col-span-full">No ${selectedMode}s in your deck.</p>`;
                return;
            }

            cardsToShow.forEach((cardEntry, index) => {
                const card = cardEntry.cardInfo;
                const cardElement = document.createElement('div');
                cardElement.className = 'selectable-card';
                cardElement.dataset.index = index;
                cardElement.dataset.type = selectedMode;

                const img = document.createElement('img');
                img.src = card.images?.thumbnail || `https://placehold.co/100x140/2d3748/e2e8f0?text=${card.name.substring(0, 10)}`;
                img.alt = card.fullName;
                img.className = 'card-image';
                img.onerror = () => { img.src = `https://placehold.co/100x140/2d3748/e2e8f0?text=Error`; };

                const nameElement = document.createElement('div');
                nameElement.className = 'card-name';
                nameElement.textContent = card.name;

                cardElement.appendChild(img);
                cardElement.appendChild(nameElement);

                // Add click handler
                cardElement.addEventListener('click', () => {
                    // Remove previous selection
                    const previouslySelected = playerCardsGrid.querySelector('.selectable-card.selected');
                    if (previouslySelected) {
                        previouslySelected.classList.remove('selected');
                    }

                    // Select this card
                    cardElement.classList.add('selected');
                    selectedCardIndex = index;
                    selectedCardType = selectedMode;

                    // Trigger analysis
                    displayAnalysisResults();
                });

                playerCardsGrid.appendChild(cardElement);
            });
        }

        function handleAnalysisModeChange() {
            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;
            console.log("Analysis mode changed to:", selectedMode);

            // Reset selection when mode changes
            selectedCardIndex = -1;
            selectedCardType = null;

            // Update challenge perspective visibility
            if (selectedMode === 'character') {
                challengePerspectiveContainer.classList.remove('hidden');
            } else { // song mode
                challengePerspectiveContainer.classList.add('hidden');
            }

            // Repopulate grid with new card type
            if (cardSelectionGrid.classList.contains('hidden') === false) {
                populateCardGrid();
            }

            // Clear results
            resultsDisplay.innerHTML = '';
        }

        function handleAnalyzeButtonClick() {
            console.log("Analyze button clicked.");
            const playerData = parseDeckString(playerDeckInput.value);
            PLAYER_DECK_CHARS = playerData.characters;
            PLAYER_DECK_SONGS = playerData.songs;
            PLAYER_DECK_LOCATIONS = playerData.locations;
            PLAYER_DECK_ITEMS = playerData.items;
            PLAYER_DECK_ACTIONS = playerData.actions;

            const opponentData = parseDeckString(opponentDeckInput.value);
            OPPONENT_DECK_CHARS = opponentData.characters;
            OPPONENT_DECK_SONGS = opponentData.songs;
            OPPONENT_DECK_LOCATIONS = opponentData.locations;
            OPPONENT_DECK_ITEMS = opponentData.items;
            OPPONENT_DECK_ACTIONS = opponentData.actions;

            // --- UWPM Phase 1: Enrich cards with features ---
            // Combine all card types for UWPM calculation
            const allPlayerCards = [
                ...PLAYER_DECK_CHARS,
                ...PLAYER_DECK_SONGS,
                ...PLAYER_DECK_LOCATIONS,
                ...PLAYER_DECK_ITEMS || [],
                ...PLAYER_DECK_ACTIONS || []
            ];
            const allOpponentCards = [
                ...OPPONENT_DECK_CHARS,
                ...OPPONENT_DECK_SONGS,
                ...OPPONENT_DECK_LOCATIONS,
                ...OPPONENT_DECK_ITEMS || [],
                ...OPPONENT_DECK_ACTIONS || []
            ];
            
            const playerUWPCards = allPlayerCards.map(entry => extractCardFeatures(entry.cardInfo, LORCANA_PATTERNS));
            const opponentUWPCards = allOpponentCards.map(entry => extractCardFeatures(entry.cardInfo, LORCANA_PATTERNS));
            console.log('UWPM Player UWPCard objects:', playerUWPCards);
            console.log('UWPM Opponent UWPCard objects:', opponentUWPCards);

            // --- UWPM Phase 2: Calculate intrinsic deck scores ---
            const playerRDSObj = getRDS(playerUWPCards);
            const playerLVIObj = getLVI(playerUWPCards);
            const playerBCRObj = getBCR(playerUWPCards);
            const opponentRDSObj = getRDS(opponentUWPCards);
            const opponentLVIObj = getLVI(opponentUWPCards);
            const opponentBCRObj = getBCR(opponentUWPCards);
            const playerRDS = playerRDSObj.total;
            const playerLVI = playerLVIObj.total;
            const playerBCR = playerBCRObj.total;
            const opponentRDS = opponentRDSObj.total;
            const opponentLVI = opponentLVIObj.total;
            const opponentBCR = opponentBCRObj.total;
            console.log('UWPM Player RDS:', playerRDS, 'LVI:', playerLVI, 'BCR:', playerBCR);
            console.log('UWPM Opponent RDS:', opponentRDS, 'LVI:', opponentLVI, 'BCR:', opponentBCR);

            // --- TFA Phase: Calculate TFA for both decks ---
            // Default phase weights (user-adjustable in UI)
            if (!window.tfaPhaseWeights) window.tfaPhaseWeights = { early: 1, mid: 2, late: 1 };
            const tfaPhaseWeights = window.tfaPhaseWeights;
            const playerTFAObj = calculateTFA(
                [
                    ...PLAYER_DECK_CHARS,
                    ...PLAYER_DECK_SONGS,
                    ...PLAYER_DECK_LOCATIONS,
                    ...PLAYER_DECK_ITEMS,
                    ...PLAYER_DECK_ACTIONS,
                ],
                playerUWPCards,
                playerRDSObj.breakdown,
                playerLVIObj.breakdown,
                playerBCRObj.breakdown,
                tfaPhaseWeights
            );
            const opponentTFAObj = calculateTFA(
                [
                    ...OPPONENT_DECK_CHARS,
                    ...OPPONENT_DECK_SONGS,
                    ...OPPONENT_DECK_LOCATIONS,
                    ...OPPONENT_DECK_ITEMS,
                    ...OPPONENT_DECK_ACTIONS,
                ],
                opponentUWPCards,
                opponentRDSObj.breakdown,
                opponentLVIObj.breakdown,
                opponentBCRObj.breakdown,
                tfaPhaseWeights
            );
            const playerTFA = playerTFAObj.total;
            const opponentTFA = opponentTFAObj.total;

            // --- UWPM Phase 3: Calculate win probability ---
            // (For now, TFA is not yet included in the win probability calculation, but will be soon)
            const winProb = calculateWinProbability(playerUWPCards, opponentUWPCards, playerTFA, opponentTFA);
            console.log('UWPM Win Probability (Player Deck):', winProb, '(', (winProb * 100).toFixed(1) + '% )');

            console.log("Decks loaded. Player Chars:", PLAYER_DECK_CHARS.length, "Player Songs:", PLAYER_DECK_SONGS.length, "Player Locations:", PLAYER_DECK_LOCATIONS.length, "Player Items:", PLAYER_DECK_ITEMS.length, "Player Actions:", PLAYER_DECK_ACTIONS.length);
            console.log("Opponent Chars:", OPPONENT_DECK_CHARS.length, "Opponent Songs:", OPPONENT_DECK_SONGS.length, "Opponent Locations:", OPPONENT_DECK_LOCATIONS.length, "Opponent Items:", OPPONENT_DECK_ITEMS.length, "Opponent Actions:", OPPONENT_DECK_ACTIONS.length);

            // Reset selection state
            selectedCardIndex = -1;
            selectedCardType = null;

            // Populate the card grid
            populateCardGrid();

            analysisControls.classList.remove('hidden');
            cardSelectionGrid.classList.remove('hidden');
            handleAnalysisModeChange();

            // --- UWPM Phase 4: UI Integration ---
            const winProbDisplay = document.getElementById('win-probability-display');
            if (playerUWPCards.length > 0 && opponentUWPCards.length > 0) {
                // Store weights in a mutable object for live editing
                const weights = { rds: 0.15, lvi: 0.15, bcr: 0.25, aim: 1.0, tfa: 0.0, taes: 1.0 };
                const k = 1;

                // Helper for tooltips
                function infoIcon(text) {
                    return `<span class=\"ml-1 cursor-pointer text-blue-300\" title=\"${text.replace(/\"/g, '&quot;')}\">&#9432;</span>`;
                }

                // Function to recalculate and update the table and probability
                function updateUWPMTable() {
                    // Parse weights from inputs
                    weights.rds = parseFloat(document.getElementById('uwpm-weight-rds').value) || 0;
                    weights.lvi = parseFloat(document.getElementById('uwpm-weight-lvi').value) || 0;
                    weights.bcr = parseFloat(document.getElementById('uwpm-weight-bcr').value) || 0;
                    weights.aim = parseFloat(document.getElementById('uwpm-weight-aim').value) || 0;
                    weights.tfa = parseFloat(document.getElementById('uwpm-weight-tfa').value) || 0;
                    weights.taes = parseFloat(document.getElementById('uwpm-weight-taes').value) || 0;

                    // Calculate contributions
                    const contribRDS = weights.rds * (playerRDS - opponentRDS);
                    const contribLVI = weights.lvi * (playerLVI - opponentLVI);
                    const contribBCR = weights.bcr * (playerBCR - opponentBCR);
                    const contribAIM = weights.aim * 0;
                    const contribTFA = weights.tfa * (playerTFA - opponentTFA);
                    const contribTAES = weights.taes * 0;
                    const matchupScore = contribRDS + contribLVI + contribBCR + contribAIM + contribTFA + contribTAES;
                    const winProb = 1 / (1 + Math.exp(-k * matchupScore));
                    const winPercent = (winProb * 100).toFixed(1);
                    const lossPercent = (100 - winPercent).toFixed(1);
                    console.log("updateUWPMTable", winPercent)
                    // Update the table and probability
                    document.getElementById('uwpm-win-chance').textContent = `${winPercent}%`;
                    document.getElementById('uwpm-opp-chance').textContent = `(Opponent's Chance: ${lossPercent}%)`;
                    document.getElementById('uwpm-matchup-score').textContent = matchupScore.toFixed(3);
                    document.getElementById('uwpm-logistic').textContent = `1 / (1 + exp(-k × Matchup Score)), k = ${k}`;
                    document.getElementById('uwpm-final-prob').textContent = `${winPercent}%`;
                    document.getElementById('uwpm-contrib-rds').textContent = contribRDS.toFixed(3);
                    document.getElementById('uwpm-contrib-lvi').textContent = contribLVI.toFixed(3);
                    document.getElementById('uwpm-contrib-bcr').textContent = contribBCR.toFixed(3);
                    document.getElementById('uwpm-contrib-aim').textContent = contribAIM.toFixed(3);
                    document.getElementById('uwpm-contrib-tfa').textContent = contribTFA.toFixed(3);
                    document.getElementById('uwpm-contrib-taes').textContent = contribTAES.toFixed(3);
                }

                // Initial values
                const contribRDS = weights.rds * (playerRDS - opponentRDS);
                const contribLVI = weights.lvi * (playerLVI - opponentLVI);
                const contribBCR = weights.bcr * (playerBCR - opponentBCR);
                const contribAIM = weights.aim * 0;
                const contribTFA = weights.tfa * (playerTFA - opponentTFA);
                const contribTAES = weights.taes * 0;
                const matchupScore = contribRDS + contribLVI + contribBCR + contribAIM + contribTFA + contribTAES;
                const winProb = 1 / (1 + Math.exp(-k * matchupScore));
                const winPercent = (winProb * 100).toFixed(1);
                const lossPercent = (100 - winPercent).toFixed(1);

                winProbDisplay.innerHTML = `
                    <p class=\"text-xl\">Your Deck's Estimated Win Chance:</p>
                    <p id=\"uwpm-win-chance\" class=\"text-5xl font-bold text-green-400 my-2\">${winPercent}%</p>
                    <p id=\"uwpm-opp-chance\" class=\"text-lg text-gray-400\">(Opponent's Chance: ${lossPercent}%)</p>
                    <div class=\"mt-6 text-left max-w-2xl mx-auto bg-gray-900 rounded-lg p-4 shadow-inner\">
                        <h3 class=\"text-lg font-semibold text-purple-300 mb-2\">UWPM Calculation Breakdown</h3>
                        <div class=\"overflow-x-auto\">
                        <table class=\"w-full text-sm text-left border-collapse\">
                            <thead>
                                <tr class=\"border-b border-gray-700\">
                                    <th class=\"py-1 px-2\">Metric</th>
                                    <th class=\"py-1 px-2\">Player</th>
                                    <th class=\"py-1 px-2\">Opponent</th>
                                    <th class=\"py-1 px-2\">Weight</th>
                                    <th class=\"py-1 px-2\">Contribution</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class=\"py-1 px-2\">RDS Resource Dominance Score ${infoIcon('Resource Dominance Score: Measures card advantage, ink acceleration, and uninkable burden.')}
                                        <button id=\"toggle-detail-rds\" class=\"ml-2 text-xs text-blue-400 underline\">Details</button>
                                    </td>
                                    <td class=\"py-1 px-2 text-blue-300\">${playerRDS.toFixed(2)}</td>
                                    <td class=\"py-1 px-2 text-pink-300\">${opponentRDS.toFixed(2)}</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-rds\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.rds}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-rds\">${contribRDS.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">LVI Lore Velocity Index ${infoIcon('Lore Velocity Index: Measures lore gain potential, survivability, and quest safety.')}
                                        <button id=\"toggle-detail-lvi\" class=\"ml-2 text-xs text-blue-400 underline\">Details</button>
                                    </td>
                                    <td class=\"py-1 px-2 text-blue-300\">${playerLVI.toFixed(2)}</td>
                                    <td class=\"py-1 px-2 text-pink-300\">${opponentLVI.toFixed(2)}</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-lvi\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.lvi}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-lvi\">${contribLVI.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">BCR Board Control Rating ${infoIcon('Board Control Rating: Measures removal, versatility, and proactive board presence.')}
                                        <button id=\"toggle-detail-bcr\" class=\"ml-2 text-xs text-blue-400 underline\">Details</button>
                                    </td>
                                    <td class=\"py-1 px-2 text-blue-300\">${playerBCR.toFixed(2)}</td>
                                    <td class=\"py-1 px-2 text-pink-300\">${opponentBCR.toFixed(2)}</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-bcr\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.bcr}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-bcr\">${contribBCR.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">AIM Archetype Interaction Modifier ${infoIcon('Archetype Interaction Modifier: Placeholder for matchup-specific archetype effects.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">0</td>
                                    <td class=\"py-1 px-2 text-pink-300\">0</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-aim\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.aim}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-aim\">${contribAIM.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">TFA Tempo Flow Analysis ${infoIcon('Tempo Flow Analysis: Compares phase-by-phase threat deployment and consistency.')}
                                        <button id=\"toggle-detail-tfa\" class=\"ml-2 text-xs text-blue-400 underline\">Details</button>
                                    </td>
                                    <td class=\"py-1 px-2 text-blue-300\">${playerTFA.toFixed(2)}</td>
                                    <td class=\"py-1 px-2 text-pink-300\">${opponentTFA.toFixed(2)}</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-tfa\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.tfa}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-tfa\">${contribTFA.toFixed(3)}</span></td>
                                </tr>
                                <tr>
                                    <td class=\"py-1 px-2\">TAES Threat-Answer Efficiency Score ${infoIcon('Threat-Answer Efficiency Score: Placeholder for threat/answer matchup effects.')}</td>
                                    <td class=\"py-1 px-2 text-blue-300\">0</td>
                                    <td class=\"py-1 px-2 text-pink-300\">0</td>
                                    <td class=\"py-1 px-2\"><input id=\"uwpm-weight-taes\" type=\"number\" step=\"0.01\" min=\"-2\" max=\"2\" value=\"${weights.taes}\" class=\"w-16 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                                    <td class=\"py-1 px-2\"><span id=\"uwpm-contrib-taes\">${contribTAES.toFixed(3)}</span></td>
                                </tr>
                            </tbody>
                        </table>
                        </div>
                        <div class=\"mt-4 mb-2\"><b>Matchup Score:</b> <span id=\"uwpm-matchup-score\" class=\"text-yellow-200\">${matchupScore.toFixed(3)}</span></div>
                        <div class=\"mb-2\"><b>Logistic Function:</b> <span id=\"uwpm-logistic\" class=\"text-gray-300\">1 / (1 + exp(-k × Matchup Score)), k = ${k}</span></div>
                        <div class=\"mb-2\"><b>Final Win Probability:</b> <span id=\"uwpm-final-prob\" class=\"text-green-400\">${winPercent}%</span></div>

                        <!-- Detailed per-card breakdowns (hidden by default) -->
                        <div id=\"uwpm-detail-rds\" class=\"hidden mt-4\"></div>
                        <div id=\"uwpm-detail-lvi\" class=\"hidden mt-4\"></div>
                        <div id=\"uwpm-detail-bcr\" class=\"hidden mt-4\"></div>
                        <div id=\"uwpm-detail-tfa\" class=\"hidden mt-4\"></div>
                    </div>
                `;

                // Add event listeners for all weight inputs
                [
                    'uwpm-weight-rds',
                    'uwpm-weight-lvi',
                    'uwpm-weight-bcr',
                    'uwpm-weight-aim',
                    'uwpm-weight-tfa',
                    'uwpm-weight-taes',
                ].forEach(id => {
                    const input = document.getElementById(id);
                    if (input) {
                        input.addEventListener('input', updateUWPMTable);
                    }
                });

                // Tooltips are handled via the title attribute for now

                // Attach expand/collapse logic for details buttons after DOM is ready
                setTimeout(() => {
                    const rdsBtn = document.getElementById('toggle-detail-rds');
                    if (rdsBtn) {
                        rdsBtn.addEventListener('click', function() {
                            const el = document.getElementById('uwpm-detail-rds');
                            if (el.classList.contains('hidden')) {
                                el.innerHTML = renderCardMetricTable('Resource Dominance Score (RDS)', playerRDSObj.breakdown, opponentRDSObj.breakdown);
                                el.classList.remove('hidden');
                            } else {
                                el.classList.add('hidden');
                            }
                        });
                    }
                    const lviBtn = document.getElementById('toggle-detail-lvi');
                    if (lviBtn) {
                        lviBtn.addEventListener('click', function() {
                            const el = document.getElementById('uwpm-detail-lvi');
                            if (el.classList.contains('hidden')) {
                                el.innerHTML = renderCardMetricTable('Lore Velocity Index (LVI)', playerLVIObj.breakdown, opponentLVIObj.breakdown);
                                el.classList.remove('hidden');
                            } else {
                                el.classList.add('hidden');
                            }
                        });
                    }
                    const bcrBtn = document.getElementById('toggle-detail-bcr');
                    if (bcrBtn) {
                        bcrBtn.addEventListener('click', function() {
                            const el = document.getElementById('uwpm-detail-bcr');
                            if (el.classList.contains('hidden')) {
                                el.innerHTML = renderCardMetricTable('Board Control Rating (BCR)', playerBCRObj.breakdown, opponentBCRObj.breakdown);
                                el.classList.remove('hidden');
                            } else {
                                el.classList.add('hidden');
                            }
                        });
                    }
                    const tfaBtn = document.getElementById('toggle-detail-tfa');
                    if (tfaBtn) {
                        tfaBtn.addEventListener('click', function() {
                            const el = document.getElementById('uwpm-detail-tfa');
                            if (el.classList.contains('hidden')) {
                                el.innerHTML = renderTFADetailTable(playerTFAObj, opponentTFAObj, tfaPhaseWeights);
                                el.classList.remove('hidden');
                            } else {
                                el.classList.add('hidden');
                            }
                        });
                    }
                }, 0);
                // Add event listeners to update TFA phase weights and recalculate
                setTimeout(() => {
                    ['early', 'mid', 'late'].forEach(phase => {
                        const input = document.getElementById(`tfa-weight-${phase}`);
                        if (input) {
                            input.addEventListener('input', function() {
                                tfaPhaseWeights[phase] = parseFloat(input.value) || 1;
                                // Re-run analysis button to update everything
                                handleAnalyzeButtonClick();
                            });
                        }
                    });
                }, 0);
            } else {
                winProbDisplay.innerHTML = `<p class=\"text-lg text-gray-400\">Load both decks to calculate win probability.</p>`;
            }

            // ... inside handleAnalyzeButtonClick, after winProbDisplay.innerHTML is set and after the setTimeout for details buttons ...
            setTimeout(() => {
                // Replace old details logic with unified tables
                const rdsDetail = document.getElementById('uwpm-detail-rds');
                const lviDetail = document.getElementById('uwpm-detail-lvi');
                const bcrDetail = document.getElementById('uwpm-detail-bcr');
                if (rdsDetail) {
                    rdsDetail.innerHTML =
                        renderUnifiedDeckMetricTable(
                            [ ...PLAYER_DECK_CHARS, ...PLAYER_DECK_SONGS, ...PLAYER_DECK_LOCATIONS, ...PLAYER_DECK_ITEMS, ...PLAYER_DECK_ACTIONS ],
                            playerRDSObj.breakdown,
                            playerLVIObj.breakdown,
                            playerBCRObj.breakdown,
                            'Player'
                        ) +
                        renderUnifiedDeckMetricTable(
                            [ ...OPPONENT_DECK_CHARS, ...OPPONENT_DECK_SONGS, ...OPPONENT_DECK_LOCATIONS, ...OPPONENT_DECK_ITEMS, ...OPPONENT_DECK_ACTIONS ],
                            opponentRDSObj.breakdown,
                            opponentLVIObj.breakdown,
                            opponentBCRObj.breakdown,
                            'Opponent'
                        );
                    rdsDetail.classList.remove('hidden');
                }
                if (lviDetail) lviDetail.classList.add('hidden');
                if (bcrDetail) bcrDetail.classList.add('hidden');
            }, 0);
        }

        function displayAnalysisResults() {
            console.log("Displaying analysis results...");
            resultsDisplay.innerHTML = '';

            // Check if a card is selected
            if (selectedCardIndex === -1 || selectedCardType === null) {
                resultsDisplay.innerHTML = `<p class="text-center text-gray-400 italic">Please select a card from the grid above to analyze.</p>`;
                return;
            }

            const selectedMode = document.querySelector('input[name="analysisMode"]:checked').value;
            console.log("Current analysis mode for display:", selectedMode);

            if (selectedMode === 'character') {
                displayCharacterAnalysis();
            } else {
                displayPlayerSongAnalysis();
            }
            // Always display location analysis regardless of character/song mode, if decks are loaded
            if (PLAYER_DECK_CHARS.length > 0 || PLAYER_DECK_SONGS.length > 0 || OPPONENT_DECK_CHARS.length > 0 || OPPONENT_DECK_SONGS.length > 0) {
                displayLocationInteractionAnalysis();
            }
        }

        function displayCharacterAnalysis() {
            console.log("Displaying Character Analysis.");
            if (PLAYER_DECK_CHARS.length === 0 || selectedCardIndex === -1 || selectedCardType !== 'character') {
                resultsDisplay.innerHTML += `<p class="text-center text-gray-400 italic">Please load decks and select a character to analyze.</p>`;
                return;
            }

            const playerCharEntry = PLAYER_DECK_CHARS[selectedCardIndex];
            if (!playerCharEntry) {
                resultsDisplay.innerHTML += `<p class="text-yellow-400 text-center">Invalid character selection.</p>`;
                console.warn("Invalid player character selection index:", selectedCardIndex);
                return;
            }
            const playerChar = playerCharEntry.cardInfo;
            const turnType = turnContextSelect.value;
            console.log(`Analyzing player character: ${playerChar.fullName}, Turn type: ${turnType}`);

            const overallAnalysisContainer = document.createElement('div');

            const playerCharDisplay = document.createElement('div');
            playerCharDisplay.className = 'text-center mb-6 pb-4 border-b border-gray-700';
            const pKeywords = extractCharacterKeywords(playerChar);
            let pKeywordStr = Object.entries(pKeywords)
                .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                .map(([key, value]) => {
                    if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                    return key.charAt(0).toUpperCase() + key.slice(1);
                }).join(', ');
            if (!pKeywordStr) pKeywordStr = 'No notable keywords/subtypes';

            const pAllTraitsStr = extractAllCharacterTraits(playerChar);

            playerCharDisplay.innerHTML = `
                <h2 class="text-2xl font-bold text-purple-300 mb-2">Analysis for Your Character: ${playerChar.fullName}</h2>
                <img src="${playerChar.images?.thumbnail || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Img'}" alt="${playerChar.fullName}" class="card-image mx-auto mb-2">
                <p class="text-sm text-gray-300">Cost: ${playerChar.cost || 'N/A'} | Str: ${playerChar.strength || 'N/A'} | Wp: ${playerChar.willpower || 'N/A'} | Lore: ${playerChar.lore || '0'}</p>
                <p class="text-xs text-gray-400"><b>Traits:</b> ${pAllTraitsStr}</p>
            `;
            overallAnalysisContainer.appendChild(playerCharDisplay);

            // Character Matchups Section
            const charMatchupSection = document.createElement('section');
            charMatchupSection.className = 'analysis-section';
            const charMatchupTitle = document.createElement('h3');
            charMatchupTitle.className = 'section-title';
            charMatchupTitle.textContent = "Character Matchups (vs Opponent's Characters)";
            charMatchupSection.appendChild(charMatchupTitle);

            if (OPPONENT_DECK_CHARS.length > 0) {
                const analysisResults = { noInteraction: [], bothBanishedPositive: [], bothBanishedNeutral: [], bothBanishedNegative: [], opponentSurvivesPlayerBanished: [], playerSurvivesOpponentBanished: [], bothSurvive: [] };
                OPPONENT_DECK_CHARS.forEach(opponentCharEntry => {
                    const matchup = calculateSingleMatchup(playerChar, opponentCharEntry.cardInfo, turnType);
                    const opponentCard = opponentCharEntry.cardInfo;
                    if (matchup.outcomeName.startsWith("NoInteraction")) analysisResults.noInteraction.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "BothBanished") {
                        if (matchup.classification === "Positive") analysisResults.bothBanishedPositive.push({ card: opponentCard, details: matchup.details });
                        else if (matchup.classification === "Negative") analysisResults.bothBanishedNegative.push({ card: opponentCard, details: matchup.details });
                        else analysisResults.bothBanishedNeutral.push({ card: opponentCard, details: matchup.details });
                    }
                    else if (matchup.outcomeName === "OpponentSurvives_PlayerBanished") analysisResults.opponentSurvivesPlayerBanished.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "PlayerSurvives_OpponentBanished") analysisResults.playerSurvivesOpponentBanished.push({ card: opponentCard, details: matchup.details });
                    else if (matchup.outcomeName === "BothSurvive") analysisResults.bothSurvive.push({ card: opponentCard, details: matchup.details });
                });

                const charGrid = document.createElement('div');
                charGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';
                charGrid.appendChild(createOutcomeSectionDOM("CAN'T CHALLENGE/BE CHALLENGED BY", analysisResults.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-600'));
                charGrid.appendChild(createOutcomeSectionDOM("FAVORABLE (Player Survives, Opp Banished)", analysisResults.playerSurvivesOpponentBanished, OPPONENT_DECK_CHARS.length, 'bg-green-700'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Favorable Ink)", analysisResults.bothBanishedPositive, OPPONENT_DECK_CHARS.length, 'bg-green-600'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Neutral Ink)", analysisResults.bothBanishedNeutral, OPPONENT_DECK_CHARS.length, 'bg-yellow-600'));
                charGrid.appendChild(createOutcomeSectionDOM("MUTUAL BANISH (Unfavorable Ink)", analysisResults.bothBanishedNegative, OPPONENT_DECK_CHARS.length, 'bg-red-600'));
                charGrid.appendChild(createOutcomeSectionDOM("UNFAVORABLE (Opp Survives, Player Banished)", analysisResults.opponentSurvivesPlayerBanished, OPPONENT_DECK_CHARS.length, 'bg-red-700'));
                charGrid.appendChild(createOutcomeSectionDOM("STALEMATE (Both Survive Challenge)", analysisResults.bothSurvive, OPPONENT_DECK_CHARS.length, 'bg-blue-600'));
                charMatchupSection.appendChild(charGrid);
            } else {
                charMatchupSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters loaded for matchup analysis.</p>`;
            }
            overallAnalysisContainer.appendChild(charMatchupSection);

            // Player Character's Abilities Impact Section
            if (turnType === "player") {
                const playerAbilitiesSection = document.createElement('section');
                playerAbilitiesSection.className = 'analysis-section';
                const playerAbilitiesTitle = document.createElement('h3');
                playerAbilitiesTitle.className = 'section-title';
                playerAbilitiesTitle.textContent = `Your "${playerChar.name}" Abilities vs Opponent's Characters`;
                playerAbilitiesSection.appendChild(playerAbilitiesTitle);
                console.log(`Analyzing abilities for ${playerChar.name} on player's turn.`);

                const activePlayerAbilities = getActiveAbilitiesForCharacter(playerChar, { perspective: "playerTurn", action: "onPlayOrChallenge" });
                if (activePlayerAbilities.length > 0 && OPPONENT_DECK_CHARS.length > 0) {
                    activePlayerAbilities.forEach(ability => {
                        if (ability.name === "Unnamed Ability") return;
                        console.log(`Processing ability: ${ability.name}`);
                        const abilityImpactTitle = document.createElement('h4');
                        abilityImpactTitle.className = 'ability-title';
                        abilityImpactTitle.textContent = `Ability: ${ability.name}`;
                        playerAbilitiesSection.appendChild(abilityImpactTitle);

                        const abilityImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                        OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                            const classificationResult = classifyAbilityEffectOnTarget(playerChar, ability.text, oppCharEntry.cardInfo, true);
                            const displayItem = {
                                card: oppCharEntry.cardInfo,
                                details: classificationResult.details,
                                classification: classificationResult.classification,
                            };
                            if (classificationResult.classification === "DirectRemoval") abilityImpactOnOppChars.directRemoval.push(displayItem);
                            else if (classificationResult.classification === "PotentialRemoval") abilityImpactOnOppChars.potentialRemoval.push(displayItem);
                            else if (classificationResult.classification === "AffectsNoRemoval") abilityImpactOnOppChars.affectsNoRemoval.push(displayItem);
                            else abilityImpactOnOppChars.noInteraction.push(displayItem);
                        });
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Directly Removes Opp Chars (via ${ability.name})`, abilityImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-800', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Potentially Removes Opp Chars (via ${ability.name})`, abilityImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-700 text-black', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`Affects Opp Chars (No Direct Removal via ${ability.name})`, abilityImpactOnOppChars.affectsNoRemoval, OPPONENT_DECK_CHARS.length, 'bg-teal-800', playerChar, ability.name));
                        playerAbilitiesSection.appendChild(createAbilityImpactDOM(`No Interaction with Opp Chars / Warded (via ${ability.name})`, abilityImpactOnOppChars.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-700', playerChar, ability.name));
                    });
                } else if (activePlayerAbilities.length === 0) {
                    playerAbilitiesSection.innerHTML += `<p class="text-center text-gray-400 italic">Your selected character has no relevant active abilities for this turn context.</p>`;
                } else {
                    playerAbilitiesSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters to analyze abilities against.</p>`;
                }
                overallAnalysisContainer.appendChild(playerAbilitiesSection);
            }


            // Opponent's Song Interaction Section
            const opponentSongSection = document.createElement('section');
            opponentSongSection.className = 'analysis-section';
            const opponentSongTitle = document.createElement('h3');
            opponentSongTitle.className = 'section-title';
            opponentSongTitle.textContent = `Opponent's Song Threats vs Your ${playerChar.name}`;
            opponentSongSection.appendChild(opponentSongTitle);
            console.log(`Analyzing opponent songs vs ${playerChar.name}`);

            if (OPPONENT_DECK_SONGS.length > 0) {
                const songAnalysis = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                OPPONENT_DECK_SONGS.forEach(songEntry => {
                    const songFullText = songEntry.cardInfo.effects?.join(' ') || songEntry.cardInfo.fullText || "";
                    const result = classifyAbilityEffectOnTarget(songEntry.cardInfo, songFullText, playerChar, false);
                    if (result.classification === "DirectRemoval") songAnalysis.directRemoval.push(result);
                    else if (result.classification === "PotentialRemoval") songAnalysis.potentialRemoval.push(result);
                    else if (result.classification === "AffectsNoRemoval") songAnalysis.affectsNoRemoval.push(result);
                    else songAnalysis.noInteraction.push(result);
                });

                opponentSongSection.appendChild(createSongBreakdownDOM("DIRECT REMOVAL THREATS", songAnalysis.directRemoval, OPPONENT_DECK_SONGS.length, 'bg-red-700', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("POTENTIAL REMOVAL / HIGH IMPACT", songAnalysis.potentialRemoval, OPPONENT_DECK_SONGS.length, 'bg-yellow-700 text-black', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("AFFECTS (No Direct Removal)", songAnalysis.affectsNoRemoval, OPPONENT_DECK_SONGS.length, 'bg-blue-700', null, playerChar));
                opponentSongSection.appendChild(createSongBreakdownDOM("NO INTERACTION / WARDED", songAnalysis.noInteraction, OPPONENT_DECK_SONGS.length, 'bg-gray-600', null, playerChar));
            } else {
                opponentSongSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent songs loaded for analysis.</p>`;
            }
            overallAnalysisContainer.appendChild(opponentSongSection);

            // Activated Ability Analysis
            const activatedAbilitySection = document.createElement('section');
            activatedAbilitySection.className = 'analysis-section';
            const activatedAbilityTitle = document.createElement('h3');
            activatedAbilityTitle.className = 'section-title';
            activatedAbilityTitle.textContent = `Your "${playerChar.name}" Activated Abilities vs Opponent's Board`;
            activatedAbilitySection.appendChild(activatedAbilityTitle);

            const activatedPattern = LORCANA_PATTERNS['Activated']?.find(p => p.name === 'Cost-Effect');
            const allAbilitiesText = (playerChar.abilities || []).map(a => a.fullText).join('\n');
            const activatedMatches = activatedPattern ? allAbilitiesText.match(activatedPattern.regex) : null;

            if (activatedMatches && activatedMatches.length > 0) {
                activatedMatches.forEach(abilityText => {
                    const effectText = abilityText.split('—')[1] || '';
                    const abilityImpactTitle = document.createElement('h4');
                    abilityImpactTitle.className = 'ability-title';
                    abilityImpactTitle.textContent = `Activated Ability: "${abilityText}"`;
                    activatedAbilitySection.appendChild(abilityImpactTitle);

                    const abilityImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                    OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                        const classificationResult = classifyAbilityEffectOnTarget(playerChar, effectText, oppCharEntry.cardInfo, true);
                        const displayItem = { card: oppCharEntry.cardInfo, details: classificationResult.details, classification: classificationResult.classification };
                        if (classificationResult.classification === "DirectRemoval") abilityImpactOnOppChars.directRemoval.push(displayItem);
                        else if (classificationResult.classification === "PotentialRemoval") abilityImpactOnOppChars.potentialRemoval.push(displayItem);
                        else if (classificationResult.classification === "AffectsNoRemoval") abilityImpactOnOppChars.affectsNoRemoval.push(displayItem);
                        else abilityImpactOnOppChars.noInteraction.push(displayItem);
                    });

                    activatedAbilitySection.appendChild(createAbilityImpactDOM(`Directly Removes`, abilityImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-800', playerChar, abilityText));
                    activatedAbilitySection.appendChild(createAbilityImpactDOM(`Potentially Affects/Removes`, abilityImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-700 text-black', playerChar, abilityText));
                });
            } else {
                activatedAbilitySection.innerHTML += `<p class="text-center text-gray-400 italic">No activated abilities found on this character.</p>`;
            }
            overallAnalysisContainer.appendChild(activatedAbilitySection);

            // Song Synergy Section
            const songSynergySection = document.createElement('section');
            songSynergySection.className = 'analysis-section';
            songSynergySection.innerHTML = `<h3 class="section-title">Song Synergies (for Your ${playerChar.name})</h3>`;

            const singerAbility = (playerChar.abilities || []).find(a => a.keyword === 'Singer');
            const characterSingValue = singerAbility ? singerAbility.keywordValueNumber : playerChar.cost;

            let canSingList = [];
            let cannotSingList = [];

            PLAYER_DECK_SONGS.forEach(songEntry => {
                const song = songEntry.cardInfo;
                const singCost = getSongSingCost(song);
                if (characterSingValue >= singCost) {
                    canSingList.push({card: song, details: `Can sing (Value ${characterSingValue} >= Cost ${singCost})`});
                } else {
                    cannotSingList.push({card: song, details: `Cannot sing (Value ${characterSingValue} < Cost ${singCost})`});
                }
            });

            songSynergySection.appendChild(createLocationInteractorsDOM("Can Sing These Songs", canSingList, 'bg-blue-800'));
            songSynergySection.appendChild(createLocationInteractorsDOM("Cannot Sing These Songs", cannotSingList, 'bg-gray-700'));
            overallAnalysisContainer.appendChild(songSynergySection);

            resultsDisplay.appendChild(overallAnalysisContainer);
        }

        function displayPlayerSongAnalysis() {
            console.log("Displaying Player Song Analysis.");
            if (PLAYER_DECK_SONGS.length === 0 || selectedCardIndex === -1 || selectedCardType !== 'song') {
                resultsDisplay.innerHTML += `<p class="text-center text-gray-400 italic">Please load decks and select a song to analyze.</p>`;
                return;
            }
            const playerSongEntry = PLAYER_DECK_SONGS[selectedCardIndex];
            if (!playerSongEntry) {
                resultsDisplay.innerHTML += `<p class="text-yellow-400 text-center">Invalid song selection.</p>`;
                console.warn("Invalid player song selection index:", selectedCardIndex);
                return;
            }
            const playerSongToAnalyze = playerSongEntry.cardInfo;
            console.log(`Analyzing player song: ${playerSongToAnalyze.fullName}`);

            const overallAnalysisContainer = document.createElement('div');

            const playerSongDisplay = document.createElement('div');
            playerSongDisplay.className = 'text-center mb-6 pb-4 border-b border-gray-700';
            const songFullTextForDisplay = (playerSongToAnalyze.effects?.join(' ') || playerSongToAnalyze.fullText || 'No effect text.').replace(/\n/g, ' ');
            playerSongDisplay.innerHTML = `
                <h2 class="text-2xl font-bold text-purple-300 mb-2">Analysis for Your Song: ${playerSongToAnalyze.fullName}</h2>
                <img src="${playerSongToAnalyze.images?.thumbnail || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Img'}" alt="${playerSongToAnalyze.fullName}" class="card-image mx-auto mb-2">
                <p class="text-sm text-gray-300">Cost: ${playerSongToAnalyze.cost || 'N/A'} | Inkable: ${playerSongToAnalyze.inkwell ? 'Yes' : 'No'}</p>
                <p class="text-xs text-gray-400">${songFullTextForDisplay}</p>
            `;
            overallAnalysisContainer.appendChild(playerSongDisplay);

            const playerSongImpactSection = document.createElement('section');
            playerSongImpactSection.className = 'analysis-section';
            const playerSongImpactTitle = document.createElement('h3');
            playerSongImpactTitle.className = 'section-title';
            playerSongImpactTitle.textContent = `Impact of Your "${playerSongToAnalyze.name}" on Opponent's Characters`;
            playerSongImpactSection.appendChild(playerSongImpactTitle);

            if (OPPONENT_DECK_CHARS.length > 0) {
                const songImpactOnOppChars = { directRemoval: [], potentialRemoval: [], affectsNoRemoval: [], noInteraction: [] };
                const songFullTextForAnalysis = playerSongToAnalyze.effects?.join(' ') || playerSongToAnalyze.fullText || "";

                OPPONENT_DECK_CHARS.forEach(oppCharEntry => {
                    const classificationResult = classifyAbilityEffectOnTarget(playerSongToAnalyze, songFullTextForAnalysis, oppCharEntry.cardInfo, true);
                    const displayItem = {
                        card: oppCharEntry.cardInfo,
                        details: classificationResult.details,
                        classification: classificationResult.classification,
                    };
                    if (classificationResult.classification === "DirectRemoval") songImpactOnOppChars.directRemoval.push(displayItem);
                    else if (classificationResult.classification === "PotentialRemoval") songImpactOnOppChars.potentialRemoval.push(displayItem);
                    else if (classificationResult.classification === "AffectsNoRemoval") songImpactOnOppChars.affectsNoRemoval.push(displayItem);
                    else songImpactOnOppChars.noInteraction.push(displayItem);
                });

                playerSongImpactSection.appendChild(createSongBreakdownDOM("DIRECTLY REMOVES OPP CHARS", songImpactOnOppChars.directRemoval, OPPONENT_DECK_CHARS.length, 'bg-green-700', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("POTENTIALLY REMOVES OPP CHARS", songImpactOnOppChars.potentialRemoval, OPPONENT_DECK_CHARS.length, 'bg-lime-600 text-black', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("AFFECTS OPP CHARS (No Direct Removal)", songImpactOnOppChars.affectsNoRemoval, OPPONENT_DECK_CHARS.length, 'bg-teal-700', playerSongToAnalyze));
                playerSongImpactSection.appendChild(createSongBreakdownDOM("NO INTERACTION WITH OPP CHARS / WARDED", songImpactOnOppChars.noInteraction, OPPONENT_DECK_CHARS.length, 'bg-gray-600', playerSongToAnalyze));

            } else {
                playerSongImpactSection.innerHTML += `<p class="text-center text-gray-400 italic">No opponent characters loaded to analyze song against.</p>`;
            }
            overallAnalysisContainer.appendChild(playerSongImpactSection);

            // Eligible Singers Section
            const singersSection = document.createElement('section');
            singersSection.className = 'analysis-section';
            singersSection.innerHTML = `<h3 class="section-title">Eligible Singers in Your Deck (for ${playerSongToAnalyze.name})</h3>`;

            const songSingCost = getSongSingCost(playerSongToAnalyze);
            let eligibleSingers = [];

            PLAYER_DECK_CHARS.forEach(charEntry => {
                const character = charEntry.cardInfo;
                const singerAbility = (character.abilities || []).find(a => a.keyword === 'Singer');
                const singValue = singerAbility ? singerAbility.keywordValueNumber : character.cost;
                if (singValue >= songSingCost) {
                    eligibleSingers.push({card: character, details: `Eligible (Value ${singValue} >= Cost ${songSingCost})`});
                }
            });

            singersSection.appendChild(createLocationInteractorsDOM("Can Sing This Song", eligibleSingers, 'bg-blue-800'));
            overallAnalysisContainer.appendChild(singersSection);

            resultsDisplay.appendChild(overallAnalysisContainer);
        }

        function displayLocationInteractionAnalysis() {
            console.log("Displaying Location Interaction Analysis.");
            const locationAnalysisSection = document.createElement('section');
            locationAnalysisSection.className = 'analysis-section';
            const locationTitle = document.createElement('h3');
            locationTitle.className = 'section-title';
            locationTitle.textContent = 'Location Interaction Analysis';
            locationAnalysisSection.appendChild(locationTitle);

            // Opponent's Threats to Your Locations
            const oppThreatsContainer = document.createElement('div');
            oppThreatsContainer.className = 'mb-6';
            const oppThreatsTitle = document.createElement('h4');
            oppThreatsTitle.className = 'text-lg font-semibold text-red-400 mb-2';
            oppThreatsTitle.textContent = "Opponent's Threats to Your Locations";
            oppThreatsContainer.appendChild(oppThreatsTitle);

            let oppCharsThreateningLocations = [];
            OPPONENT_DECK_CHARS.forEach(oppChar => {
                const activeAbilities = getActiveAbilitiesForCharacter(oppChar.cardInfo, { perspective: "opponentTurn", action: "any" }); // Generic context for location abilities
                activeAbilities.forEach(ability => {
                    const interaction = classifyLocationInteraction(oppChar.cardInfo, ability.text, false); // false: opponent's card
                    if (interaction && interaction.canInteract) {
                        oppCharsThreateningLocations.push({ card: oppChar.cardInfo, details: `Ability: ${ability.name} - ${interaction.details}` });
                    }
                });
            });
            // --- NEW LOGIC: Check for strength-based removal of locations ---
            if (PLAYER_DECK_LOCATIONS.length > 0) {
                PLAYER_DECK_LOCATIONS.forEach(locationEntry => {
                    const location = locationEntry.cardInfo;
                    const locationWillpower = location.willpower || 0;
                    OPPONENT_DECK_CHARS.forEach(oppChar => {
                        const oppStrength = oppChar.cardInfo.strength || 0;
                        if (oppStrength >= locationWillpower && locationWillpower > 0) {
                            oppCharsThreateningLocations.push({
                                card: oppChar.cardInfo,
                                details: `Can remove your location '${location.fullName}' by strength (${oppStrength} ≥ ${locationWillpower})`
                            });
                        }
                    });
                });
            }
            // Remove duplicates by card name if a char has multiple abilities affecting locations
            oppCharsThreateningLocations = Array.from(new Set(oppCharsThreateningLocations.map(item => item.card.fullName + (item.details || '')))
                ).map(key => oppCharsThreateningLocations.find(item => (item.card.fullName + (item.details || '')) === key));
            oppThreatsContainer.appendChild(createLocationInteractorsDOM("Opponent Characters That Can Remove/Target Your Locations", oppCharsThreateningLocations, 'bg-red-800'));

            let oppSongsThreateningLocations = [];
            OPPONENT_DECK_SONGS.forEach(oppSong => {
                const songText = oppSong.cardInfo.effects?.join(' ') || oppSong.cardInfo.fullText || "";
                const interaction = classifyLocationInteraction(oppSong.cardInfo, songText, false);
                if (interaction && interaction.canInteract) {
                    oppSongsThreateningLocations.push({ card: oppSong.cardInfo, details: interaction.details });
                }
            });
            oppThreatsContainer.appendChild(createLocationInteractorsDOM("Opponent Songs That Can Remove/Target Your Locations", oppSongsThreateningLocations, 'bg-red-700'));
            locationAnalysisSection.appendChild(oppThreatsContainer);


            // Your Options Against Opponent's Locations
            const playerOptionsContainer = document.createElement('div');
            const playerOptionsTitle = document.createElement('h4');
            playerOptionsTitle.className = 'text-lg font-semibold text-green-400 mb-2';
            playerOptionsTitle.textContent = "Your Options Against Opponent's Locations";
            playerOptionsContainer.appendChild(playerOptionsTitle);

            let playerCharsRemovingLocations = [];
            PLAYER_DECK_CHARS.forEach(playerChar => {
                const activeAbilities = getActiveAbilitiesForCharacter(playerChar.cardInfo, { perspective: "playerTurn", action: "any" });
                activeAbilities.forEach(ability => {
                    const interaction = classifyLocationInteraction(playerChar.cardInfo, ability.text, true); // true: player's card
                    if (interaction && interaction.canInteract) {
                        playerCharsRemovingLocations.push({ card: playerChar.cardInfo, details: `Ability: ${ability.name} - ${interaction.details}` });
                    }
                });
            });
            playerCharsRemovingLocations = Array.from(new Set(playerCharsRemovingLocations.map(item => item.card.fullName)))
                .map(name => playerCharsRemovingLocations.find(item => item.card.fullName === name));
            playerOptionsContainer.appendChild(createLocationInteractorsDOM("Your Characters That Can Remove/Target Opponent's Locations", playerCharsRemovingLocations, 'bg-green-800'));

            let playerSongsRemovingLocations = [];
            PLAYER_DECK_SONGS.forEach(playerSong => {
                const songText = playerSong.cardInfo.effects?.join(' ') || playerSong.cardInfo.fullText || "";
                const interaction = classifyLocationInteraction(playerSong.cardInfo, songText, true);
                if (interaction && interaction.canInteract) {
                    playerSongsRemovingLocations.push({ card: playerSong.cardInfo, details: interaction.details });
                }
            });
            playerOptionsContainer.appendChild(createLocationInteractorsDOM("Your Songs That Can Remove/Target Opponent's Locations", playerSongsRemovingLocations, 'bg-green-700'));
            locationAnalysisSection.appendChild(playerOptionsContainer);

            resultsDisplay.appendChild(locationAnalysisSection);
        }

        function createOutcomeSectionDOM(title, cardsWithObjects, totalTargetChars, bgColorClass = 'bg-gray-700') {
            const section = document.createElement('div');
            section.className = `outcome-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalTargetChars > 0 ? ((cardsWithObjects.length / totalTargetChars) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            titleElem.textContent = `${title} (${cardsWithObjects.length}/${totalTargetChars} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (cardsWithObjects.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs text-gray-400 italic p-1">None.</p>`;
            } else {
                cardsWithObjects.forEach(obj => {
                    const card = obj.card;
                    const details = obj.details;
                    const keywords = extractCharacterKeywords(card);
                    let keywordStr = Object.entries(keywords)
                        .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                        .map(([key, value]) => {
                            if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                            return key.charAt(0).toUpperCase() + key.slice(1);
                        }).join(', ');
                    if (!keywordStr) keywordStr = 'None';

                    const tooltipText = `Name: ${card.fullName}\nCost: ${card.cost}, Str: ${card.strength}, Wp: ${card.willpower}, Lore: ${card.lore || 0}\nKeywords: ${keywordStr}\nMatchup: ${details || 'N/A'}`;

                    const tooltipWrapper = createCardTooltipWrapper(card, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createSongBreakdownDOM(title, classifiedItems, totalTargetableItemsCount, bgColorClass = 'bg-gray-700', contextSongCard = null, contextCharCard = null) {
            const section = document.createElement('div');
            section.className = `song-breakdown-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalTargetableItemsCount > 0 ? ((classifiedItems.length / totalTargetableItemsCount) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            if (bgColorClass.includes('text-black')) {
                titleElem.classList.add('text-black');
            }
            titleElem.textContent = `${title} (${classifiedItems.length}/${totalTargetableItemsCount} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (classifiedItems.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs ${bgColorClass.includes('text-black') ? 'text-gray-700' : 'text-gray-400'} italic p-1">None.</p>`;
            } else {
                classifiedItems.forEach(item => {
                    const cardForDisplay = item.card;
                    const interactionSummary = item.details;
                    const classificationType = item.classification;
                    let tooltipText;

                    if (contextSongCard) {
                        const targetCharCard = cardForDisplay;
                        const keywords = extractCharacterKeywords(targetCharCard);
                        let keywordStr = Object.entries(keywords)
                            .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                            .map(([key, value]) => {
                                if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                                return key.charAt(0).toUpperCase() + key.slice(1);
                            }).join(', ');
                        if (!keywordStr) keywordStr = 'None';
                        tooltipText = `Target Char: ${targetCharCard.fullName}\nCost: ${targetCharCard.cost}, Str: ${targetCharCard.strength}, Wp: ${targetCharCard.willpower}\nKeywords: ${keywordStr}\nAffected by Your Song: "${contextSongCard.fullName}"\nInteraction: ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;
                    } else {
                        const opponentSongCard = cardForDisplay; // Here, item.card is the song itself
                        tooltipText = `Opponent's Song: ${opponentSongCard.fullName}\nCost: ${opponentSongCard.cost} | Inkable: ${opponentSongCard.inkwell ? 'Yes' : 'No'}\nEffect Snippet: ${(opponentSongCard.effects?.join('; ') || opponentSongCard.fullText || '').replace(/\n/g, ' ').substring(0, 70) + '...'}\nInteraction with Your Char (${contextCharCard?.name || 'Selected Char'}): ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;
                    }

                    const tooltipWrapper = createCardTooltipWrapper(cardForDisplay, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createAbilityImpactDOM(title, classifiedTargetChars, totalOpponentChars, bgColorClass = 'bg-gray-700', sourceCharCard, sourceAbilityName) {
            const section = document.createElement('div');
            section.className = `ability-impact-section shadow-md ${bgColorClass} p-3`;

            const percentage = totalOpponentChars > 0 ? ((classifiedTargetChars.length / totalOpponentChars) * 100).toFixed(0) : 0;
            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            if (bgColorClass.includes('text-black')) {
                titleElem.classList.add('text-black');
            }
            titleElem.textContent = `${title} (${classifiedTargetChars.length}/${totalOpponentChars} - ${percentage}%)`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (classifiedTargetChars.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs ${bgColorClass.includes('text-black') ? 'text-gray-700' : 'text-gray-400'} italic p-1">None.</p>`;
            } else {
                classifiedTargetChars.forEach(item => {
                    const targetCharCard = item.card;
                    const interactionSummary = item.details;
                    const classificationType = item.classification;

                    const keywords = extractCharacterKeywords(targetCharCard);
                    let keywordStr = Object.entries(keywords)
                        .filter(([key, value]) => value === true || (typeof value === 'number' && value > 0))
                        .map(([key, value]) => {
                            if (typeof value === 'number' && value > 0) return `${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`;
                            return key.charAt(0).toUpperCase() + key.slice(1);
                        }).join(', ');
                    if (!keywordStr) keywordStr = 'None';

                    const tooltipText = `Target Char: ${targetCharCard.fullName}\nCost: ${targetCharCard.cost}, Str: ${targetCharCard.strength}, Wp: ${targetCharCard.willpower}\nKeywords: ${keywordStr}\nAffected by ${sourceCharCard.name}'s Ability: "${sourceAbilityName}"\nInteraction: ${interactionSummary || 'N/A'}\nClassification: ${classificationType}`;

                    const tooltipWrapper = createCardTooltipWrapper(targetCharCard, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }

        function createLocationInteractorsDOM(title, interactingCards, bgColorClass = 'bg-gray-700') {
            const section = document.createElement('div');
            section.className = `location-interaction-subsection shadow-md ${bgColorClass} p-3`;

            const titleElem = document.createElement('h4');
            titleElem.className = 'subsection-title text-sm';
            titleElem.textContent = `${title} (${interactingCards.length})`;
            section.appendChild(titleElem);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container py-1';
            if (interactingCards.length === 0) {
                cardContainer.innerHTML = `<p class="text-xs text-gray-400 italic p-1">None found.</p>`;
            } else {
                interactingCards.forEach(item => {
                    const card = item.card; // This is the Character or Song card
                    const details = item.details;
                    const tooltipText = `Card: ${card.fullName}\nType: ${card.type}\nInteraction: ${details}`;
                    const tooltipWrapper = createCardTooltipWrapper(card, tooltipText);
                    cardContainer.appendChild(tooltipWrapper);
                });
            }
            section.appendChild(cardContainer);
            return section;
        }


        function createCardTooltipWrapper(cardData, tooltipTextContent) {
            const tooltipWrapper = document.createElement('div');
            tooltipWrapper.className = 'tooltip';

            const img = document.createElement('img');
            img.src = cardData.images?.thumbnail || `https://placehold.co/100x140/2d3748/e2e8f0?text=${cardData.name.substring(0, 10)}`;
            img.alt = cardData.fullName;
            img.className = 'card-image';
            img.onerror = () => { img.src = `https://placehold.co/100x140/2d3748/e2e8f0?text=Error`; };
            tooltipWrapper.appendChild(img);

            const tooltipSpan = document.createElement('span');
            tooltipSpan.className = 'tooltiptext';
            tooltipSpan.textContent = tooltipTextContent;
            tooltipWrapper.appendChild(tooltipSpan);

            return tooltipWrapper;
        }

        // --- Add this new helper function somewhere in the script ---
        function extractAllCharacterTraits(characterCard) {
            const traits = new Set();
            const abilitiesText = (characterCard.abilities || []).map(a => a.fullText).join(' ');

            // Extract standard keywords first
            const keywords = extractCharacterKeywords(characterCard);
            Object.entries(keywords).forEach(([key, value]) => {
                if (value === true) traits.add(key.charAt(0).toUpperCase() + key.slice(1));
                else if (typeof value === 'number' && value > 0) traits.add(`${key.charAt(0).toUpperCase() + key.slice(1)} +${value}`);
            });

            // Use new regex patterns for other static abilities
            if (LORCANA_PATTERNS['Static']) {
                LORCANA_PATTERNS['Static'].forEach(pattern => {
                    if (pattern.regex.test(abilitiesText)) {
                        traits.add(pattern.name); // Add the descriptive pattern name
                    }
                });
            }
            // Add new keywords
            ['Vanish', 'Sing Together', 'Puppy Shift', 'Universal Shift'].forEach(kw => {
                 if (abilitiesText.includes(kw)) {
                     // Extract value if present, e.g., "Sing Together 7"
                     const match = abilitiesText.match(new RegExp(`(${kw}( \\d+)?)`));
                     if (match) traits.add(match[1]);
                 }
            });

            return traits.size > 0 ? Array.from(traits).join(', ') : 'No notable keywords/abilities.';
        }

        function getSongSingCost(songCardInfo) {
            const songCostPattern = LORCANA_PATTERNS['Play']?.find(p => p.name === 'Song');
            if (songCostPattern) {
                const match = (songCardInfo.fullText || '').match(songCostPattern.regex);
                if (match && match[1]) {
                    return parseInt(match[1], 10);
                }
            }
            return songCardInfo.cost; // Fallback to the song's main cost if pattern fails
        }

        // --- Per-card breakdown logic ---
        function renderCardMetricTable(title, playerBreakdown, oppBreakdown) {
            // (Old function, will be replaced by unified tables)
            return `
                <div class=\"mb-4\"><b>${title} - Player Deck</b></div>
                <table class=\"w-full text-xs mb-4 border-collapse\">
                    <thead><tr class=\"border-b border-gray-700\"><th class=\"py-1 px-2\">Card</th><th class=\"py-1 px-2\">Value</th><th class=\"py-1 px-2\">Explanation</th></tr></thead>
                    <tbody>
                        ${playerBreakdown.map(row => `<tr><td class=\"py-1 px-2\">${row.name}</td><td class=\"py-1 px-2\">${row.value.toFixed(2)}</td><td class=\"py-1 px-2\">${row.explanation}</td></tr>`).join('')}
                    </tbody>
                </table>
                <div class=\"mb-4\"><b>${title} - Opponent Deck</b></div>
                <table class=\"w-full text-xs border-collapse\">
                    <thead><tr class=\"border-b border-gray-700\"><th class=\"py-1 px-2\">Card</th><th class=\"py-1 px-2\">Value</th><th class=\"py-1 px-2\">Explanation</th></tr></thead>
                    <tbody>
                        ${oppBreakdown.map(row => `<tr><td class=\"py-1 px-2\">${row.name}</td><td class=\"py-1 px-2\">${row.value.toFixed(2)}</td><td class=\"py-1 px-2\">${row.explanation}</td></tr>`).join('')}
                    </tbody>
                </table>
            `;
        }

        // --- Unified per-deck, per-card metric table with heatmap and responsive layout ---
        function renderUnifiedDeckMetricTable(deckCards, rdsBreakdown, lviBreakdown, bcrBreakdown, deckLabel) {
            // Build lookup maps for fast access
            const rdsMap = Object.fromEntries(rdsBreakdown.map(row => [row.name, row]));
            const lviMap = Object.fromEntries(lviBreakdown.map(row => [row.name, row]));
            const bcrMap = Object.fromEntries(bcrBreakdown.map(row => [row.name, row]));
            // Get all unique cards (by fullName)
            const allCards = deckCards.map(entry => entry.cardInfo);
            // Compute min/max for each metric
            function getMinMax(map) {
                const values = allCards.map(card => (map[card.fullName]?.value ?? 0));
                return { min: Math.min(...values), max: Math.max(...values) };
            }
            const rdsMinMax = getMinMax(rdsMap);
            const lviMinMax = getMinMax(lviMap);
            const bcrMinMax = getMinMax(bcrMap);
            // Helper for heatmap color (blue for low, yellow for mid, red for high)
            function getHeatColor(val, min, max) {
                if (max === min) return '';
                const t = (val - min) / (max - min);
                // 0 = no color, 1 = strong color
                // Use HSL: 220 (blue) to 60 (yellow) to 0 (red)
                let hue;
                if (t < 0.5) {
                    // Blue to yellow
                    hue = 220 + (60 - 220) * (t / 0.5);
                } else {
                    // Yellow to red
                    hue = 60 + (0 - 60) * ((t - 0.5) / 0.5);
                }
                return `background-color: hsl(${hue}, 45%, 40%); color: #fff;`;
            }
            // Responsive table: stack on small screens, show images+names on large
            return `
            <div class=\"mb-4\"><b>${deckLabel} Deck: Per-Card Metrics</b></div>
            <div class=\"overflow-x-auto\">
            <table class=\"w-full text-xs border-collapse\">
                <thead>
                    <tr class=\"border-b border-gray-700\">
                        <th class=\"py-1 px-2 text-left\">Card</th>
                        <th class=\"py-1 px-2 text-center\">RDS</th>
                        <th class=\"py-1 px-2 text-center\">LVI</th>
                        <th class=\"py-1 px-2 text-center\">BCR</th>
                    </tr>
                </thead>
                <tbody>
                    ${allCards.map(card => {
                        const rds = rdsMap[card.fullName]?.value ?? 0;
                        const lvi = lviMap[card.fullName]?.value ?? 0;
                        const bcr = bcrMap[card.fullName]?.value ?? 0;
                        const rdsExp = rdsMap[card.fullName]?.explanation || '';
                        const lviExp = lviMap[card.fullName]?.explanation || '';
                        const bcrExp = bcrMap[card.fullName]?.explanation || '';
                        // Responsive: show image+name on md+, name only on sm
                        const cardCell = `
                          <div class=\"flex items-center gap-2\">
                            <img src=\"${card.images?.thumbnail || 'https://placehold.co/40x56/2d3748/e2e8f0?text=No+Img'}\" alt=\"${card.fullName}\" class=\"hidden md:inline-block rounded w-10 h-auto\" style=\"min-width:40px;\">
                            <span class=\"block\">${card.name}</span>
                          </div>
                        `;
                        return `<tr>
                            <td class=\"py-1 px-2 align-top\">${cardCell}</td>
                            <td class=\"py-1 px-2 align-top text-center\" style=\"${getHeatColor(rds, rdsMinMax.min, rdsMinMax.max)}\">
                                <div>${rds.toFixed(2)}</div>
                                <div class=\"whitespace-normal break-words text-xs mt-1\">${rdsExp}</div>
                            </td>
                            <td class=\"py-1 px-2 align-top text-center\" style=\"${getHeatColor(lvi, lviMinMax.min, lviMinMax.max)}\">
                                <div>${lvi.toFixed(2)}</div>
                                <div class=\"whitespace-normal break-words text-xs mt-1\">${lviExp}</div>
                            </td>
                            <td class=\"py-1 px-2 align-top text-center\" style=\"${getHeatColor(bcr, bcrMinMax.min, bcrMinMax.max)}\">
                                <div>${bcr.toFixed(2)}</div>
                                <div class=\"whitespace-normal break-words text-xs mt-1\">${bcrExp}</div>
                            </td>
                        </tr>`;
                    }).join('')}
                </tbody>
            </table>
            </div>
            <style>
            @media (max-width: 640px) {
              table td, table th { display: block; width: 100%; }
              table tr { display: block; margin-bottom: 1rem; border-bottom: 2px solid #374151; }
              table thead { display: none; }
            }
            </style>
            `;
        }

        // --- TFA (Tempo Flow Analysis) ---
        /**
         * Calculates the Tempo Flow Analysis (TFA) score for a deck, using existing RDS/LVI/BCR breakdowns and card counts.
         * @param {Array<{cardInfo: object, count: number}>} deckEntries - Original deck entries with counts.
         * @param {Array<object>} uwpCards - Enriched UWPCard objects (same order as deckEntries).
         * @param {Array<{name: string, value: number}>} rdsBreakdown - getRDS(deck).breakdown
         * @param {Array<{name: string, value: number}>} lviBreakdown - getLVI(deck).breakdown
         * @param {Array<{name: string, value: number}>} bcrBreakdown - getBCR(deck).breakdown
         * @param {object} phaseWeights - { early: number, mid: number, late: number }
         * @returns {{ total: number, phaseScores: object, details: object }}
         */
        function calculateTFA(deckEntries, uwpCards, rdsBreakdown, lviBreakdown, bcrBreakdown, phaseWeights) {
            const rdsMap = Object.fromEntries(rdsBreakdown.map(row => [row.name, row.value]));
            const lviMap = Object.fromEntries(lviBreakdown.map(row => [row.name, row.value]));
            const bcrMap = Object.fromEntries(bcrBreakdown.map(row => [row.name, row.value]));
            const phases = {
                early: { turns: [1, 2, 3], threatPower: 0, consistency: 0, perTurn: {}, turnDetails: [] },
                mid: { turns: [4, 5, 6], threatPower: 0, consistency: 0, perTurn: {}, turnDetails: [] },
                late: { turns: [7, 8, 9, 10, 11, 12], threatPower: 0, consistency: 0, perTurn: {}, turnDetails: [] },
            };
            Object.entries(phases).forEach(([phase, obj]) => {
                obj.turns.forEach(cost => {
                    obj.perTurn[cost] = { threatPower: 0, count: 0, cards: [] };
                });
            });
            deckEntries.forEach((entry, idx) => {
                const card = entry.cardInfo;
                const count = entry.count || 1;
                const cost = card.cost;
                const name = card.fullName;
                const threatPower = (rdsMap[name] || 0) + (lviMap[name] || 0) + (bcrMap[name] || 0);
                Object.entries(phases).forEach(([phase, obj]) => {
                    if (obj.turns.includes(cost)) {
                        obj.perTurn[cost].threatPower += threatPower * count;
                        obj.perTurn[cost].count += count;
                        obj.perTurn[cost].cards.push({ card, count, threatPower });
                    }
                });
            });
            Object.entries(phases).forEach(([phase, obj]) => {
                let totalThreat = 0;
                let turnsWithThreat = 0;
                obj.turnDetails = [];
                obj.turns.forEach(cost => {
                    const turn = obj.perTurn[cost];
                    let turnReason = '';
                    let selectedCards = [];
                    if (turn.count > 0) {
                        turnsWithThreat++;
                        // Select the card(s) with the highest threat power for this turn
                        let maxThreat = Math.max(...turn.cards.map(c => c.threatPower));
                        selectedCards = turn.cards.filter(c => c.threatPower === maxThreat);
                        if (selectedCards.length === 1) {
                            turnReason = `Highest threat power for cost ${cost}`;
                        } else if (selectedCards.length > 1) {
                            turnReason = `Tie for highest threat power for cost ${cost}`;
                        }
                    } else {
                        turnReason = 'No card available for this cost';
                    }
                    totalThreat += turn.threatPower;
                    obj.turnDetails.push({
                        cost,
                        selectedCards,
                        totalThreat: turn.threatPower,
                        reason: turnReason
                    });
                });
                obj.threatPower = totalThreat;
                obj.consistency = turnsWithThreat / obj.turns.length;
            });
            const total =
                (phases.early.threatPower * phases.early.consistency * (phaseWeights.early || 1)) +
                (phases.mid.threatPower * phases.mid.consistency * (phaseWeights.mid || 1)) +
                (phases.late.threatPower * phases.late.consistency * (phaseWeights.late || 1));
            return {
                total,
                phaseScores: {
                    early: phases.early.threatPower * phases.early.consistency,
                    mid: phases.mid.threatPower * phases.mid.consistency,
                    late: phases.late.threatPower * phases.late.consistency,
                },
                details: phases,
            };
        }

        // --- Start the app ---
        initializeApp();

        // --- Helper to render TFA phase-by-phase breakdown ---
        function renderTFADetailTable(playerTFAObj, opponentTFAObj, phaseWeights) {
            const phases = ['early', 'mid', 'late'];
            const phaseNames = { early: 'Early (1-3)', mid: 'Mid (4-6)', late: 'Late (7+)' };
            let html = `<div class=\"mb-4\"><b>TFA Phase-by-Phase Breakdown</b></div>`;
            html += `<table class=\"w-full text-xs mb-4 border-collapse\">
                <thead><tr class=\"border-b border-gray-700\">
                    <th class=\"py-1 px-2\">Phase</th>
                    <th class=\"py-1 px-2\">Player Threat Power × Consistency</th>
                    <th class=\"py-1 px-2\">Opponent Threat Power × Consistency</th>
                    <th class=\"py-1 px-2\">Weight</th>
                </tr></thead><tbody>`;
            phases.forEach(phase => {
                html += `<tr>
                    <td class=\"py-1 px-2\">${phaseNames[phase]}</td>
                    <td class=\"py-1 px-2\">${playerTFAObj.phaseScores[phase].toFixed(2)}</td>
                    <td class=\"py-1 px-2\">${opponentTFAObj.phaseScores[phase].toFixed(2)}</td>
                    <td class=\"py-1 px-2\"><input type=\"number\" step=\"0.1\" min=\"0\" max=\"5\" value=\"${phaseWeights[phase]}\" id=\"tfa-weight-${phase}\" class=\"w-12 bg-gray-800 border border-gray-600 rounded px-1 text-center\"></td>
                </tr>`;
            });
            html += `</tbody></table>`;
            // Per-turn breakdown for each phase
            phases.forEach(phase => {
                const playerTurns = playerTFAObj.details[phase].turnDetails;
                const oppTurns = opponentTFAObj.details[phase].turnDetails;
                html += `<div class=\"mb-2 mt-4\"><b>${phaseNames[phase]}: Per-Turn Threat Selection</b></div>`;
                html += `<table class=\"w-full text-xs mb-2 border-collapse\">
                    <thead><tr class=\"border-b border-gray-700\">
                        <th class=\"py-1 px-2\">Turn (Cost)</th>
                        <th class=\"py-1 px-2\">Player Threat Card(s)</th>
                        <th class=\"py-1 px-2\">Player Threat Power</th>
                        <th class=\"py-1 px-2\">Player Reason</th>
                        <th class=\"py-1 px-2\">Opponent Threat Card(s)</th>
                        <th class=\"py-1 px-2\">Opponent Threat Power</th>
                        <th class=\"py-1 px-2\">Opponent Reason</th>
                    </tr></thead><tbody>`;
                for (let i = 0; i < playerTurns.length; i++) {
                    const p = playerTurns[i];
                    const o = oppTurns[i];
                    html += `<tr>
                        <td class=\"py-1 px-2\">${p.cost}</td>
                        <td class=\"py-1 px-2\">${p.selectedCards.length > 0 ? p.selectedCards.map(c => `${c.card.fullName} (x${c.count})`).join('<br>') : '-'}</td>
                        <td class=\"py-1 px-2\">${p.totalThreat.toFixed(2)}</td>
                        <td class=\"py-1 px-2\">${p.reason}</td>
                        <td class=\"py-1 px-2\">${o.selectedCards.length > 0 ? o.selectedCards.map(c => `${c.card.fullName} (x${c.count})`).join('<br>') : '-'}</td>
                        <td class=\"py-1 px-2\">${o.totalThreat.toFixed(2)}</td>
                        <td class=\"py-1 px-2\">${o.reason}</td>
                    </tr>`;
                }
                html += `</tbody></table>`;
            });
            html += `<div class=\"text-xs text-gray-400\">Threat Power = (RDS + LVI + BCR) × Copies, Consistency = Fraction of turns in phase with at least one playable card. For each turn, the card(s) with the highest threat power are selected as the main threat(s).</div>`;
            return html;
        }
    </script>
</body>

</html>